// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(breez_sdkFFI)
import breez_sdkFFI
#endif

fileprivate extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_breez_sdk_d64f_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_breez_sdk_d64f_rustbuffer_free(self, $0) }
    }
}

fileprivate extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a libray of its own.

fileprivate extension Data {
    init(rustBuffer: RustBuffer) {
        // TODO: This copies the buffer. Can we read directly from a
        // Rust buffer?
        self.init(bytes: rustBuffer.data!, count: Int(rustBuffer.len))
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

fileprivate func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
fileprivate func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset..<reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value, { reader.data.copyBytes(to: $0, from: range)})
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
fileprivate func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> Array<UInt8> {
    let range = reader.offset..<(reader.offset+count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer({ buffer in
        reader.data.copyBytes(to: buffer, from: range)
    })
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
fileprivate func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return Float(bitPattern: try readInt(&reader))
}

// Reads a float at the current offset.
fileprivate func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return Double(bitPattern: try readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
fileprivate func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

fileprivate func createWriter() -> [UInt8] {
    return []
}

fileprivate func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
fileprivate func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

fileprivate func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

fileprivate func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous go the Rust trait of the same name.
fileprivate protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
fileprivate protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType { }

extension FfiConverterPrimitive {
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
fileprivate protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

    public static func lower(_ value: SwiftType) -> RustBuffer {
          var writer = createWriter()
          write(value, into: &writer)
          return RustBuffer(bytes: writer)
    }
}
// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
fileprivate enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

fileprivate let CALL_SUCCESS: Int8 = 0
fileprivate let CALL_ERROR: Int8 = 1
fileprivate let CALL_PANIC: Int8 = 2

fileprivate extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer.init(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: {
        $0.deallocate()
        return UniffiInternalError.unexpectedRustCallError
    })
}

private func rustCallWithError<T, F: FfiConverter>
    (_ errorFfiConverter: F.Type, _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T
    where F.SwiftType: Error, F.FfiType == RustBuffer
    {
    try makeRustCall(callback, errorHandler: { return try errorFfiConverter.lift($0) })
}

private func makeRustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T, errorHandler: (RustBuffer) throws -> Error) throws -> T {
    var callStatus = RustCallStatus.init()
    let returnedVal = callback(&callStatus)
    switch callStatus.code {
        case CALL_SUCCESS:
            return returnedVal

        case CALL_ERROR:
            throw try errorHandler(callStatus.errorBuf)

        case CALL_PANIC:
            // When the rust code sees a panic, it tries to construct a RustBuffer
            // with the message.  But if that code panics, then it just sends back
            // an empty buffer.
            if callStatus.errorBuf.len > 0 {
                throw UniffiInternalError.rustPanic(try FfiConverterString.lift(callStatus.errorBuf))
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.rustPanic("Rust panic")
            }

        default:
            throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

// Public interface members begin here.


fileprivate struct FfiConverterUInt8: FfiConverterPrimitive {
    typealias FfiType = UInt8
    typealias SwiftType = UInt8

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt8 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: UInt8, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterUInt16: FfiConverterPrimitive {
    typealias FfiType = UInt16
    typealias SwiftType = UInt16

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt16 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterUInt32: FfiConverterPrimitive {
    typealias FfiType = UInt32
    typealias SwiftType = UInt32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterInt32: FfiConverterPrimitive {
    typealias FfiType = Int32
    typealias SwiftType = Int32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int32, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterUInt64: FfiConverterPrimitive {
    typealias FfiType = UInt64
    typealias SwiftType = UInt64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterInt64: FfiConverterPrimitive {
    typealias FfiType = Int64
    typealias SwiftType = Int64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int64, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterDouble: FfiConverterPrimitive {
    typealias FfiType = Double
    typealias SwiftType = Double

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Double {
        return try lift(readDouble(&buf))
    }

    public static func write(_ value: Double, into buf: inout [UInt8]) {
        writeDouble(&buf, lower(value))
    }
}

fileprivate struct FfiConverterBool : FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    public static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    public static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bool {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Bool, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return String(bytes: try readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}


public protocol BlockingBreezServicesProtocol {
    func `start`() throws
    func `stop`() throws
    func `sendPayment`(`bolt11`: String, `amountSats`: UInt64?) throws -> Payment
    func `sendSpontaneousPayment`(`nodeId`: String, `amountSats`: UInt64) throws -> Payment
    func `receivePayment`(`amountSats`: UInt64, `description`: String) throws -> LnInvoice
    func `withdrawLnurl`(`reqData`: LnUrlWithdrawRequestData, `amountSats`: UInt64, `description`: String?) throws -> LnUrlWithdrawCallbackStatus
    func `nodeInfo`() throws -> NodeState?
    func `listPayments`(`filter`: PaymentTypeFilter, `fromTimestamp`: Int64?, `toTimestamp`: Int64?) throws -> [Payment]
    func `sweep`(`toAddress`: String, `feeRateSatsPerByte`: UInt64) throws
    func `fetchFiatRates`() throws -> [Rate]
    func `listFiatCurrencies`() throws -> [FiatCurrency]
    func `listLsps`() throws -> [LspInformation]
    func `connectLsp`(`lspId`: String) throws
    func `fetchLspInfo`(`lspId`: String) throws -> LspInformation?
    func `lspId`() throws -> String?
    func `closeLspChannels`() throws
    func `receiveOnchain`() throws -> SwapInfo
    func `inProgressSwap`() throws -> SwapInfo?
    func `listRefundables`() throws -> [SwapInfo]
    func `refund`(`swapAddress`: String, `toAddress`: String, `satPerVbyte`: UInt32) throws -> String
    func `executeDevCommand`(`command`: String) throws -> String
    func `sync`() throws
    func `recommendedFees`() throws -> RecommendedFees
    
}

public class BlockingBreezServices: BlockingBreezServicesProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { ffi_breez_sdk_d64f_BlockingBreezServices_object_free(pointer, $0) }
    }

    

    
    public func `start`() throws {
        try
    rustCallWithError(FfiConverterTypeSdkError.self) {
    breez_sdk_d64f_BlockingBreezServices_start(self.pointer, $0
    )
}
    }
    public func `stop`() throws {
        try
    rustCallWithError(FfiConverterTypeSdkError.self) {
    breez_sdk_d64f_BlockingBreezServices_stop(self.pointer, $0
    )
}
    }
    public func `sendPayment`(`bolt11`: String, `amountSats`: UInt64?) throws -> Payment {
        return try FfiConverterTypePayment.lift(
            try
    rustCallWithError(FfiConverterTypeSdkError.self) {
    breez_sdk_d64f_BlockingBreezServices_send_payment(self.pointer, 
        FfiConverterString.lower(`bolt11`), 
        FfiConverterOptionUInt64.lower(`amountSats`), $0
    )
}
        )
    }
    public func `sendSpontaneousPayment`(`nodeId`: String, `amountSats`: UInt64) throws -> Payment {
        return try FfiConverterTypePayment.lift(
            try
    rustCallWithError(FfiConverterTypeSdkError.self) {
    breez_sdk_d64f_BlockingBreezServices_send_spontaneous_payment(self.pointer, 
        FfiConverterString.lower(`nodeId`), 
        FfiConverterUInt64.lower(`amountSats`), $0
    )
}
        )
    }
    public func `receivePayment`(`amountSats`: UInt64, `description`: String) throws -> LnInvoice {
        return try FfiConverterTypeLnInvoice.lift(
            try
    rustCallWithError(FfiConverterTypeSdkError.self) {
    breez_sdk_d64f_BlockingBreezServices_receive_payment(self.pointer, 
        FfiConverterUInt64.lower(`amountSats`), 
        FfiConverterString.lower(`description`), $0
    )
}
        )
    }
    public func `withdrawLnurl`(`reqData`: LnUrlWithdrawRequestData, `amountSats`: UInt64, `description`: String?) throws -> LnUrlWithdrawCallbackStatus {
        return try FfiConverterTypeLnUrlWithdrawCallbackStatus.lift(
            try
    rustCallWithError(FfiConverterTypeSdkError.self) {
    breez_sdk_d64f_BlockingBreezServices_withdraw_lnurl(self.pointer, 
        FfiConverterTypeLnUrlWithdrawRequestData.lower(`reqData`), 
        FfiConverterUInt64.lower(`amountSats`), 
        FfiConverterOptionString.lower(`description`), $0
    )
}
        )
    }
    public func `nodeInfo`() throws -> NodeState? {
        return try FfiConverterOptionTypeNodeState.lift(
            try
    rustCallWithError(FfiConverterTypeSdkError.self) {
    breez_sdk_d64f_BlockingBreezServices_node_info(self.pointer, $0
    )
}
        )
    }
    public func `listPayments`(`filter`: PaymentTypeFilter, `fromTimestamp`: Int64?, `toTimestamp`: Int64?) throws -> [Payment] {
        return try FfiConverterSequenceTypePayment.lift(
            try
    rustCallWithError(FfiConverterTypeSdkError.self) {
    breez_sdk_d64f_BlockingBreezServices_list_payments(self.pointer, 
        FfiConverterTypePaymentTypeFilter.lower(`filter`), 
        FfiConverterOptionInt64.lower(`fromTimestamp`), 
        FfiConverterOptionInt64.lower(`toTimestamp`), $0
    )
}
        )
    }
    public func `sweep`(`toAddress`: String, `feeRateSatsPerByte`: UInt64) throws {
        try
    rustCallWithError(FfiConverterTypeSdkError.self) {
    breez_sdk_d64f_BlockingBreezServices_sweep(self.pointer, 
        FfiConverterString.lower(`toAddress`), 
        FfiConverterUInt64.lower(`feeRateSatsPerByte`), $0
    )
}
    }
    public func `fetchFiatRates`() throws -> [Rate] {
        return try FfiConverterSequenceTypeRate.lift(
            try
    rustCallWithError(FfiConverterTypeSdkError.self) {
    breez_sdk_d64f_BlockingBreezServices_fetch_fiat_rates(self.pointer, $0
    )
}
        )
    }
    public func `listFiatCurrencies`() throws -> [FiatCurrency] {
        return try FfiConverterSequenceTypeFiatCurrency.lift(
            try
    rustCallWithError(FfiConverterTypeSdkError.self) {
    breez_sdk_d64f_BlockingBreezServices_list_fiat_currencies(self.pointer, $0
    )
}
        )
    }
    public func `listLsps`() throws -> [LspInformation] {
        return try FfiConverterSequenceTypeLspInformation.lift(
            try
    rustCallWithError(FfiConverterTypeSdkError.self) {
    breez_sdk_d64f_BlockingBreezServices_list_lsps(self.pointer, $0
    )
}
        )
    }
    public func `connectLsp`(`lspId`: String) throws {
        try
    rustCallWithError(FfiConverterTypeSdkError.self) {
    breez_sdk_d64f_BlockingBreezServices_connect_lsp(self.pointer, 
        FfiConverterString.lower(`lspId`), $0
    )
}
    }
    public func `fetchLspInfo`(`lspId`: String) throws -> LspInformation? {
        return try FfiConverterOptionTypeLspInformation.lift(
            try
    rustCallWithError(FfiConverterTypeSdkError.self) {
    breez_sdk_d64f_BlockingBreezServices_fetch_lsp_info(self.pointer, 
        FfiConverterString.lower(`lspId`), $0
    )
}
        )
    }
    public func `lspId`() throws -> String? {
        return try FfiConverterOptionString.lift(
            try
    rustCallWithError(FfiConverterTypeSdkError.self) {
    breez_sdk_d64f_BlockingBreezServices_lsp_id(self.pointer, $0
    )
}
        )
    }
    public func `closeLspChannels`() throws {
        try
    rustCallWithError(FfiConverterTypeSdkError.self) {
    breez_sdk_d64f_BlockingBreezServices_close_lsp_channels(self.pointer, $0
    )
}
    }
    public func `receiveOnchain`() throws -> SwapInfo {
        return try FfiConverterTypeSwapInfo.lift(
            try
    rustCallWithError(FfiConverterTypeSdkError.self) {
    breez_sdk_d64f_BlockingBreezServices_receive_onchain(self.pointer, $0
    )
}
        )
    }
    public func `inProgressSwap`() throws -> SwapInfo? {
        return try FfiConverterOptionTypeSwapInfo.lift(
            try
    rustCallWithError(FfiConverterTypeSdkError.self) {
    breez_sdk_d64f_BlockingBreezServices_in_progress_swap(self.pointer, $0
    )
}
        )
    }
    public func `listRefundables`() throws -> [SwapInfo] {
        return try FfiConverterSequenceTypeSwapInfo.lift(
            try
    rustCallWithError(FfiConverterTypeSdkError.self) {
    breez_sdk_d64f_BlockingBreezServices_list_refundables(self.pointer, $0
    )
}
        )
    }
    public func `refund`(`swapAddress`: String, `toAddress`: String, `satPerVbyte`: UInt32) throws -> String {
        return try FfiConverterString.lift(
            try
    rustCallWithError(FfiConverterTypeSdkError.self) {
    breez_sdk_d64f_BlockingBreezServices_refund(self.pointer, 
        FfiConverterString.lower(`swapAddress`), 
        FfiConverterString.lower(`toAddress`), 
        FfiConverterUInt32.lower(`satPerVbyte`), $0
    )
}
        )
    }
    public func `executeDevCommand`(`command`: String) throws -> String {
        return try FfiConverterString.lift(
            try
    rustCallWithError(FfiConverterTypeSdkError.self) {
    breez_sdk_d64f_BlockingBreezServices_execute_dev_command(self.pointer, 
        FfiConverterString.lower(`command`), $0
    )
}
        )
    }
    public func `sync`() throws {
        try
    rustCallWithError(FfiConverterTypeSdkError.self) {
    breez_sdk_d64f_BlockingBreezServices_sync(self.pointer, $0
    )
}
    }
    public func `recommendedFees`() throws -> RecommendedFees {
        return try FfiConverterTypeRecommendedFees.lift(
            try
    rustCallWithError(FfiConverterTypeSdkError.self) {
    breez_sdk_d64f_BlockingBreezServices_recommended_fees(self.pointer, $0
    )
}
        )
    }
    
}


public struct FfiConverterTypeBlockingBreezServices: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = BlockingBreezServices

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BlockingBreezServices {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: BlockingBreezServices, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> BlockingBreezServices {
        return BlockingBreezServices(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: BlockingBreezServices) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public struct AesSuccessActionDataDecrypted {
    public var `description`: String
    public var `plaintext`: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`description`: String, `plaintext`: String) {
        self.`description` = `description`
        self.`plaintext` = `plaintext`
    }
}


extension AesSuccessActionDataDecrypted: Equatable, Hashable {
    public static func ==(lhs: AesSuccessActionDataDecrypted, rhs: AesSuccessActionDataDecrypted) -> Bool {
        if lhs.`description` != rhs.`description` {
            return false
        }
        if lhs.`plaintext` != rhs.`plaintext` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`description`)
        hasher.combine(`plaintext`)
    }
}


public struct FfiConverterTypeAesSuccessActionDataDecrypted: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AesSuccessActionDataDecrypted {
        return try AesSuccessActionDataDecrypted(
            `description`: FfiConverterString.read(from: &buf), 
            `plaintext`: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: AesSuccessActionDataDecrypted, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`description`, into: &buf)
        FfiConverterString.write(value.`plaintext`, into: &buf)
    }
}


public struct BitcoinAddressData {
    public var `address`: String
    public var `network`: Network
    public var `amountSat`: UInt64?
    public var `label`: String?
    public var `message`: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`address`: String, `network`: Network, `amountSat`: UInt64?, `label`: String?, `message`: String?) {
        self.`address` = `address`
        self.`network` = `network`
        self.`amountSat` = `amountSat`
        self.`label` = `label`
        self.`message` = `message`
    }
}


extension BitcoinAddressData: Equatable, Hashable {
    public static func ==(lhs: BitcoinAddressData, rhs: BitcoinAddressData) -> Bool {
        if lhs.`address` != rhs.`address` {
            return false
        }
        if lhs.`network` != rhs.`network` {
            return false
        }
        if lhs.`amountSat` != rhs.`amountSat` {
            return false
        }
        if lhs.`label` != rhs.`label` {
            return false
        }
        if lhs.`message` != rhs.`message` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`address`)
        hasher.combine(`network`)
        hasher.combine(`amountSat`)
        hasher.combine(`label`)
        hasher.combine(`message`)
    }
}


public struct FfiConverterTypeBitcoinAddressData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BitcoinAddressData {
        return try BitcoinAddressData(
            `address`: FfiConverterString.read(from: &buf), 
            `network`: FfiConverterTypeNetwork.read(from: &buf), 
            `amountSat`: FfiConverterOptionUInt64.read(from: &buf), 
            `label`: FfiConverterOptionString.read(from: &buf), 
            `message`: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: BitcoinAddressData, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`address`, into: &buf)
        FfiConverterTypeNetwork.write(value.`network`, into: &buf)
        FfiConverterOptionUInt64.write(value.`amountSat`, into: &buf)
        FfiConverterOptionString.write(value.`label`, into: &buf)
        FfiConverterOptionString.write(value.`message`, into: &buf)
    }
}


public struct ClosedChannelPaymentDetails {
    public var `shortChannelId`: String
    public var `state`: ChannelState
    public var `fundingTxid`: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`shortChannelId`: String, `state`: ChannelState, `fundingTxid`: String) {
        self.`shortChannelId` = `shortChannelId`
        self.`state` = `state`
        self.`fundingTxid` = `fundingTxid`
    }
}


extension ClosedChannelPaymentDetails: Equatable, Hashable {
    public static func ==(lhs: ClosedChannelPaymentDetails, rhs: ClosedChannelPaymentDetails) -> Bool {
        if lhs.`shortChannelId` != rhs.`shortChannelId` {
            return false
        }
        if lhs.`state` != rhs.`state` {
            return false
        }
        if lhs.`fundingTxid` != rhs.`fundingTxid` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`shortChannelId`)
        hasher.combine(`state`)
        hasher.combine(`fundingTxid`)
    }
}


public struct FfiConverterTypeClosedChannelPaymentDetails: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ClosedChannelPaymentDetails {
        return try ClosedChannelPaymentDetails(
            `shortChannelId`: FfiConverterString.read(from: &buf), 
            `state`: FfiConverterTypeChannelState.read(from: &buf), 
            `fundingTxid`: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: ClosedChannelPaymentDetails, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`shortChannelId`, into: &buf)
        FfiConverterTypeChannelState.write(value.`state`, into: &buf)
        FfiConverterString.write(value.`fundingTxid`, into: &buf)
    }
}


public struct Config {
    public var `breezserver`: String
    public var `mempoolspaceUrl`: String
    public var `workingDir`: String
    public var `network`: Network
    public var `paymentTimeoutSec`: UInt32
    public var `defaultLspId`: String?
    public var `apiKey`: String?
    public var `maxfeeSat`: UInt64?
    public var `maxfeepercent`: Double

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`breezserver`: String, `mempoolspaceUrl`: String, `workingDir`: String, `network`: Network, `paymentTimeoutSec`: UInt32, `defaultLspId`: String?, `apiKey`: String?, `maxfeeSat`: UInt64?, `maxfeepercent`: Double) {
        self.`breezserver` = `breezserver`
        self.`mempoolspaceUrl` = `mempoolspaceUrl`
        self.`workingDir` = `workingDir`
        self.`network` = `network`
        self.`paymentTimeoutSec` = `paymentTimeoutSec`
        self.`defaultLspId` = `defaultLspId`
        self.`apiKey` = `apiKey`
        self.`maxfeeSat` = `maxfeeSat`
        self.`maxfeepercent` = `maxfeepercent`
    }
}


extension Config: Equatable, Hashable {
    public static func ==(lhs: Config, rhs: Config) -> Bool {
        if lhs.`breezserver` != rhs.`breezserver` {
            return false
        }
        if lhs.`mempoolspaceUrl` != rhs.`mempoolspaceUrl` {
            return false
        }
        if lhs.`workingDir` != rhs.`workingDir` {
            return false
        }
        if lhs.`network` != rhs.`network` {
            return false
        }
        if lhs.`paymentTimeoutSec` != rhs.`paymentTimeoutSec` {
            return false
        }
        if lhs.`defaultLspId` != rhs.`defaultLspId` {
            return false
        }
        if lhs.`apiKey` != rhs.`apiKey` {
            return false
        }
        if lhs.`maxfeeSat` != rhs.`maxfeeSat` {
            return false
        }
        if lhs.`maxfeepercent` != rhs.`maxfeepercent` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`breezserver`)
        hasher.combine(`mempoolspaceUrl`)
        hasher.combine(`workingDir`)
        hasher.combine(`network`)
        hasher.combine(`paymentTimeoutSec`)
        hasher.combine(`defaultLspId`)
        hasher.combine(`apiKey`)
        hasher.combine(`maxfeeSat`)
        hasher.combine(`maxfeepercent`)
    }
}


public struct FfiConverterTypeConfig: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Config {
        return try Config(
            `breezserver`: FfiConverterString.read(from: &buf), 
            `mempoolspaceUrl`: FfiConverterString.read(from: &buf), 
            `workingDir`: FfiConverterString.read(from: &buf), 
            `network`: FfiConverterTypeNetwork.read(from: &buf), 
            `paymentTimeoutSec`: FfiConverterUInt32.read(from: &buf), 
            `defaultLspId`: FfiConverterOptionString.read(from: &buf), 
            `apiKey`: FfiConverterOptionString.read(from: &buf), 
            `maxfeeSat`: FfiConverterOptionUInt64.read(from: &buf), 
            `maxfeepercent`: FfiConverterDouble.read(from: &buf)
        )
    }

    public static func write(_ value: Config, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`breezserver`, into: &buf)
        FfiConverterString.write(value.`mempoolspaceUrl`, into: &buf)
        FfiConverterString.write(value.`workingDir`, into: &buf)
        FfiConverterTypeNetwork.write(value.`network`, into: &buf)
        FfiConverterUInt32.write(value.`paymentTimeoutSec`, into: &buf)
        FfiConverterOptionString.write(value.`defaultLspId`, into: &buf)
        FfiConverterOptionString.write(value.`apiKey`, into: &buf)
        FfiConverterOptionUInt64.write(value.`maxfeeSat`, into: &buf)
        FfiConverterDouble.write(value.`maxfeepercent`, into: &buf)
    }
}


public struct CurrencyInfo {
    public var `name`: String
    public var `fractionSize`: UInt32
    public var `spacing`: UInt32?
    public var `symbol`: Symbol?
    public var `uniqSymbol`: Symbol?
    public var `localizedName`: [LocalizedName]?
    public var `localeOverrides`: [LocaleOverrides]?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`name`: String, `fractionSize`: UInt32, `spacing`: UInt32?, `symbol`: Symbol?, `uniqSymbol`: Symbol?, `localizedName`: [LocalizedName]?, `localeOverrides`: [LocaleOverrides]?) {
        self.`name` = `name`
        self.`fractionSize` = `fractionSize`
        self.`spacing` = `spacing`
        self.`symbol` = `symbol`
        self.`uniqSymbol` = `uniqSymbol`
        self.`localizedName` = `localizedName`
        self.`localeOverrides` = `localeOverrides`
    }
}


extension CurrencyInfo: Equatable, Hashable {
    public static func ==(lhs: CurrencyInfo, rhs: CurrencyInfo) -> Bool {
        if lhs.`name` != rhs.`name` {
            return false
        }
        if lhs.`fractionSize` != rhs.`fractionSize` {
            return false
        }
        if lhs.`spacing` != rhs.`spacing` {
            return false
        }
        if lhs.`symbol` != rhs.`symbol` {
            return false
        }
        if lhs.`uniqSymbol` != rhs.`uniqSymbol` {
            return false
        }
        if lhs.`localizedName` != rhs.`localizedName` {
            return false
        }
        if lhs.`localeOverrides` != rhs.`localeOverrides` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`name`)
        hasher.combine(`fractionSize`)
        hasher.combine(`spacing`)
        hasher.combine(`symbol`)
        hasher.combine(`uniqSymbol`)
        hasher.combine(`localizedName`)
        hasher.combine(`localeOverrides`)
    }
}


public struct FfiConverterTypeCurrencyInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CurrencyInfo {
        return try CurrencyInfo(
            `name`: FfiConverterString.read(from: &buf), 
            `fractionSize`: FfiConverterUInt32.read(from: &buf), 
            `spacing`: FfiConverterOptionUInt32.read(from: &buf), 
            `symbol`: FfiConverterOptionTypeSymbol.read(from: &buf), 
            `uniqSymbol`: FfiConverterOptionTypeSymbol.read(from: &buf), 
            `localizedName`: FfiConverterOptionSequenceTypeLocalizedName.read(from: &buf), 
            `localeOverrides`: FfiConverterOptionSequenceTypeLocaleOverrides.read(from: &buf)
        )
    }

    public static func write(_ value: CurrencyInfo, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`name`, into: &buf)
        FfiConverterUInt32.write(value.`fractionSize`, into: &buf)
        FfiConverterOptionUInt32.write(value.`spacing`, into: &buf)
        FfiConverterOptionTypeSymbol.write(value.`symbol`, into: &buf)
        FfiConverterOptionTypeSymbol.write(value.`uniqSymbol`, into: &buf)
        FfiConverterOptionSequenceTypeLocalizedName.write(value.`localizedName`, into: &buf)
        FfiConverterOptionSequenceTypeLocaleOverrides.write(value.`localeOverrides`, into: &buf)
    }
}


public struct FiatCurrency {
    public var `id`: String
    public var `info`: CurrencyInfo

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`id`: String, `info`: CurrencyInfo) {
        self.`id` = `id`
        self.`info` = `info`
    }
}


extension FiatCurrency: Equatable, Hashable {
    public static func ==(lhs: FiatCurrency, rhs: FiatCurrency) -> Bool {
        if lhs.`id` != rhs.`id` {
            return false
        }
        if lhs.`info` != rhs.`info` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`id`)
        hasher.combine(`info`)
    }
}


public struct FfiConverterTypeFiatCurrency: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FiatCurrency {
        return try FiatCurrency(
            `id`: FfiConverterString.read(from: &buf), 
            `info`: FfiConverterTypeCurrencyInfo.read(from: &buf)
        )
    }

    public static func write(_ value: FiatCurrency, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`id`, into: &buf)
        FfiConverterTypeCurrencyInfo.write(value.`info`, into: &buf)
    }
}


public struct GreenlightCredentials {
    public var `deviceKey`: [UInt8]
    public var `deviceCert`: [UInt8]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`deviceKey`: [UInt8], `deviceCert`: [UInt8]) {
        self.`deviceKey` = `deviceKey`
        self.`deviceCert` = `deviceCert`
    }
}


extension GreenlightCredentials: Equatable, Hashable {
    public static func ==(lhs: GreenlightCredentials, rhs: GreenlightCredentials) -> Bool {
        if lhs.`deviceKey` != rhs.`deviceKey` {
            return false
        }
        if lhs.`deviceCert` != rhs.`deviceCert` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`deviceKey`)
        hasher.combine(`deviceCert`)
    }
}


public struct FfiConverterTypeGreenlightCredentials: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GreenlightCredentials {
        return try GreenlightCredentials(
            `deviceKey`: FfiConverterSequenceUInt8.read(from: &buf), 
            `deviceCert`: FfiConverterSequenceUInt8.read(from: &buf)
        )
    }

    public static func write(_ value: GreenlightCredentials, into buf: inout [UInt8]) {
        FfiConverterSequenceUInt8.write(value.`deviceKey`, into: &buf)
        FfiConverterSequenceUInt8.write(value.`deviceCert`, into: &buf)
    }
}


public struct InvoicePaidDetails {
    public var `paymentHash`: String
    public var `bolt11`: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`paymentHash`: String, `bolt11`: String) {
        self.`paymentHash` = `paymentHash`
        self.`bolt11` = `bolt11`
    }
}


extension InvoicePaidDetails: Equatable, Hashable {
    public static func ==(lhs: InvoicePaidDetails, rhs: InvoicePaidDetails) -> Bool {
        if lhs.`paymentHash` != rhs.`paymentHash` {
            return false
        }
        if lhs.`bolt11` != rhs.`bolt11` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`paymentHash`)
        hasher.combine(`bolt11`)
    }
}


public struct FfiConverterTypeInvoicePaidDetails: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> InvoicePaidDetails {
        return try InvoicePaidDetails(
            `paymentHash`: FfiConverterString.read(from: &buf), 
            `bolt11`: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: InvoicePaidDetails, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`paymentHash`, into: &buf)
        FfiConverterString.write(value.`bolt11`, into: &buf)
    }
}


public struct LnInvoice {
    public var `bolt11`: String
    public var `payeePubkey`: String
    public var `paymentHash`: String
    public var `description`: String?
    public var `descriptionHash`: String?
    public var `amountMsat`: UInt64?
    public var `timestamp`: UInt64
    public var `expiry`: UInt64
    public var `routingHints`: [RouteHint]
    public var `paymentSecret`: [UInt8]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`bolt11`: String, `payeePubkey`: String, `paymentHash`: String, `description`: String?, `descriptionHash`: String?, `amountMsat`: UInt64?, `timestamp`: UInt64, `expiry`: UInt64, `routingHints`: [RouteHint], `paymentSecret`: [UInt8]) {
        self.`bolt11` = `bolt11`
        self.`payeePubkey` = `payeePubkey`
        self.`paymentHash` = `paymentHash`
        self.`description` = `description`
        self.`descriptionHash` = `descriptionHash`
        self.`amountMsat` = `amountMsat`
        self.`timestamp` = `timestamp`
        self.`expiry` = `expiry`
        self.`routingHints` = `routingHints`
        self.`paymentSecret` = `paymentSecret`
    }
}


extension LnInvoice: Equatable, Hashable {
    public static func ==(lhs: LnInvoice, rhs: LnInvoice) -> Bool {
        if lhs.`bolt11` != rhs.`bolt11` {
            return false
        }
        if lhs.`payeePubkey` != rhs.`payeePubkey` {
            return false
        }
        if lhs.`paymentHash` != rhs.`paymentHash` {
            return false
        }
        if lhs.`description` != rhs.`description` {
            return false
        }
        if lhs.`descriptionHash` != rhs.`descriptionHash` {
            return false
        }
        if lhs.`amountMsat` != rhs.`amountMsat` {
            return false
        }
        if lhs.`timestamp` != rhs.`timestamp` {
            return false
        }
        if lhs.`expiry` != rhs.`expiry` {
            return false
        }
        if lhs.`routingHints` != rhs.`routingHints` {
            return false
        }
        if lhs.`paymentSecret` != rhs.`paymentSecret` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`bolt11`)
        hasher.combine(`payeePubkey`)
        hasher.combine(`paymentHash`)
        hasher.combine(`description`)
        hasher.combine(`descriptionHash`)
        hasher.combine(`amountMsat`)
        hasher.combine(`timestamp`)
        hasher.combine(`expiry`)
        hasher.combine(`routingHints`)
        hasher.combine(`paymentSecret`)
    }
}


public struct FfiConverterTypeLnInvoice: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LnInvoice {
        return try LnInvoice(
            `bolt11`: FfiConverterString.read(from: &buf), 
            `payeePubkey`: FfiConverterString.read(from: &buf), 
            `paymentHash`: FfiConverterString.read(from: &buf), 
            `description`: FfiConverterOptionString.read(from: &buf), 
            `descriptionHash`: FfiConverterOptionString.read(from: &buf), 
            `amountMsat`: FfiConverterOptionUInt64.read(from: &buf), 
            `timestamp`: FfiConverterUInt64.read(from: &buf), 
            `expiry`: FfiConverterUInt64.read(from: &buf), 
            `routingHints`: FfiConverterSequenceTypeRouteHint.read(from: &buf), 
            `paymentSecret`: FfiConverterSequenceUInt8.read(from: &buf)
        )
    }

    public static func write(_ value: LnInvoice, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`bolt11`, into: &buf)
        FfiConverterString.write(value.`payeePubkey`, into: &buf)
        FfiConverterString.write(value.`paymentHash`, into: &buf)
        FfiConverterOptionString.write(value.`description`, into: &buf)
        FfiConverterOptionString.write(value.`descriptionHash`, into: &buf)
        FfiConverterOptionUInt64.write(value.`amountMsat`, into: &buf)
        FfiConverterUInt64.write(value.`timestamp`, into: &buf)
        FfiConverterUInt64.write(value.`expiry`, into: &buf)
        FfiConverterSequenceTypeRouteHint.write(value.`routingHints`, into: &buf)
        FfiConverterSequenceUInt8.write(value.`paymentSecret`, into: &buf)
    }
}


public struct LnPaymentDetails {
    public var `paymentHash`: String
    public var `label`: String
    public var `destinationPubkey`: String
    public var `paymentPreimage`: String
    public var `keysend`: Bool
    public var `bolt11`: String
    public var `lnurlSuccessAction`: SuccessActionProcessed?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`paymentHash`: String, `label`: String, `destinationPubkey`: String, `paymentPreimage`: String, `keysend`: Bool, `bolt11`: String, `lnurlSuccessAction`: SuccessActionProcessed?) {
        self.`paymentHash` = `paymentHash`
        self.`label` = `label`
        self.`destinationPubkey` = `destinationPubkey`
        self.`paymentPreimage` = `paymentPreimage`
        self.`keysend` = `keysend`
        self.`bolt11` = `bolt11`
        self.`lnurlSuccessAction` = `lnurlSuccessAction`
    }
}


extension LnPaymentDetails: Equatable, Hashable {
    public static func ==(lhs: LnPaymentDetails, rhs: LnPaymentDetails) -> Bool {
        if lhs.`paymentHash` != rhs.`paymentHash` {
            return false
        }
        if lhs.`label` != rhs.`label` {
            return false
        }
        if lhs.`destinationPubkey` != rhs.`destinationPubkey` {
            return false
        }
        if lhs.`paymentPreimage` != rhs.`paymentPreimage` {
            return false
        }
        if lhs.`keysend` != rhs.`keysend` {
            return false
        }
        if lhs.`bolt11` != rhs.`bolt11` {
            return false
        }
        if lhs.`lnurlSuccessAction` != rhs.`lnurlSuccessAction` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`paymentHash`)
        hasher.combine(`label`)
        hasher.combine(`destinationPubkey`)
        hasher.combine(`paymentPreimage`)
        hasher.combine(`keysend`)
        hasher.combine(`bolt11`)
        hasher.combine(`lnurlSuccessAction`)
    }
}


public struct FfiConverterTypeLnPaymentDetails: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LnPaymentDetails {
        return try LnPaymentDetails(
            `paymentHash`: FfiConverterString.read(from: &buf), 
            `label`: FfiConverterString.read(from: &buf), 
            `destinationPubkey`: FfiConverterString.read(from: &buf), 
            `paymentPreimage`: FfiConverterString.read(from: &buf), 
            `keysend`: FfiConverterBool.read(from: &buf), 
            `bolt11`: FfiConverterString.read(from: &buf), 
            `lnurlSuccessAction`: FfiConverterOptionTypeSuccessActionProcessed.read(from: &buf)
        )
    }

    public static func write(_ value: LnPaymentDetails, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`paymentHash`, into: &buf)
        FfiConverterString.write(value.`label`, into: &buf)
        FfiConverterString.write(value.`destinationPubkey`, into: &buf)
        FfiConverterString.write(value.`paymentPreimage`, into: &buf)
        FfiConverterBool.write(value.`keysend`, into: &buf)
        FfiConverterString.write(value.`bolt11`, into: &buf)
        FfiConverterOptionTypeSuccessActionProcessed.write(value.`lnurlSuccessAction`, into: &buf)
    }
}


public struct LnUrlAuthRequestData {
    public var `k1`: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`k1`: String) {
        self.`k1` = `k1`
    }
}


extension LnUrlAuthRequestData: Equatable, Hashable {
    public static func ==(lhs: LnUrlAuthRequestData, rhs: LnUrlAuthRequestData) -> Bool {
        if lhs.`k1` != rhs.`k1` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`k1`)
    }
}


public struct FfiConverterTypeLnUrlAuthRequestData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LnUrlAuthRequestData {
        return try LnUrlAuthRequestData(
            `k1`: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: LnUrlAuthRequestData, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`k1`, into: &buf)
    }
}


public struct LnUrlErrorData {
    public var `reason`: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`reason`: String) {
        self.`reason` = `reason`
    }
}


extension LnUrlErrorData: Equatable, Hashable {
    public static func ==(lhs: LnUrlErrorData, rhs: LnUrlErrorData) -> Bool {
        if lhs.`reason` != rhs.`reason` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`reason`)
    }
}


public struct FfiConverterTypeLnUrlErrorData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LnUrlErrorData {
        return try LnUrlErrorData(
            `reason`: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: LnUrlErrorData, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`reason`, into: &buf)
    }
}


public struct LnUrlPayRequestData {
    public var `callback`: String
    public var `minSendable`: UInt64
    public var `maxSendable`: UInt64
    public var `metadataStr`: String
    public var `commentAllowed`: UInt16

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`callback`: String, `minSendable`: UInt64, `maxSendable`: UInt64, `metadataStr`: String, `commentAllowed`: UInt16) {
        self.`callback` = `callback`
        self.`minSendable` = `minSendable`
        self.`maxSendable` = `maxSendable`
        self.`metadataStr` = `metadataStr`
        self.`commentAllowed` = `commentAllowed`
    }
}


extension LnUrlPayRequestData: Equatable, Hashable {
    public static func ==(lhs: LnUrlPayRequestData, rhs: LnUrlPayRequestData) -> Bool {
        if lhs.`callback` != rhs.`callback` {
            return false
        }
        if lhs.`minSendable` != rhs.`minSendable` {
            return false
        }
        if lhs.`maxSendable` != rhs.`maxSendable` {
            return false
        }
        if lhs.`metadataStr` != rhs.`metadataStr` {
            return false
        }
        if lhs.`commentAllowed` != rhs.`commentAllowed` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`callback`)
        hasher.combine(`minSendable`)
        hasher.combine(`maxSendable`)
        hasher.combine(`metadataStr`)
        hasher.combine(`commentAllowed`)
    }
}


public struct FfiConverterTypeLnUrlPayRequestData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LnUrlPayRequestData {
        return try LnUrlPayRequestData(
            `callback`: FfiConverterString.read(from: &buf), 
            `minSendable`: FfiConverterUInt64.read(from: &buf), 
            `maxSendable`: FfiConverterUInt64.read(from: &buf), 
            `metadataStr`: FfiConverterString.read(from: &buf), 
            `commentAllowed`: FfiConverterUInt16.read(from: &buf)
        )
    }

    public static func write(_ value: LnUrlPayRequestData, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`callback`, into: &buf)
        FfiConverterUInt64.write(value.`minSendable`, into: &buf)
        FfiConverterUInt64.write(value.`maxSendable`, into: &buf)
        FfiConverterString.write(value.`metadataStr`, into: &buf)
        FfiConverterUInt16.write(value.`commentAllowed`, into: &buf)
    }
}


public struct LnUrlWithdrawRequestData {
    public var `callback`: String
    public var `k1`: String
    public var `defaultDescription`: String
    public var `minWithdrawable`: UInt64
    public var `maxWithdrawable`: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`callback`: String, `k1`: String, `defaultDescription`: String, `minWithdrawable`: UInt64, `maxWithdrawable`: UInt64) {
        self.`callback` = `callback`
        self.`k1` = `k1`
        self.`defaultDescription` = `defaultDescription`
        self.`minWithdrawable` = `minWithdrawable`
        self.`maxWithdrawable` = `maxWithdrawable`
    }
}


extension LnUrlWithdrawRequestData: Equatable, Hashable {
    public static func ==(lhs: LnUrlWithdrawRequestData, rhs: LnUrlWithdrawRequestData) -> Bool {
        if lhs.`callback` != rhs.`callback` {
            return false
        }
        if lhs.`k1` != rhs.`k1` {
            return false
        }
        if lhs.`defaultDescription` != rhs.`defaultDescription` {
            return false
        }
        if lhs.`minWithdrawable` != rhs.`minWithdrawable` {
            return false
        }
        if lhs.`maxWithdrawable` != rhs.`maxWithdrawable` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`callback`)
        hasher.combine(`k1`)
        hasher.combine(`defaultDescription`)
        hasher.combine(`minWithdrawable`)
        hasher.combine(`maxWithdrawable`)
    }
}


public struct FfiConverterTypeLnUrlWithdrawRequestData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LnUrlWithdrawRequestData {
        return try LnUrlWithdrawRequestData(
            `callback`: FfiConverterString.read(from: &buf), 
            `k1`: FfiConverterString.read(from: &buf), 
            `defaultDescription`: FfiConverterString.read(from: &buf), 
            `minWithdrawable`: FfiConverterUInt64.read(from: &buf), 
            `maxWithdrawable`: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: LnUrlWithdrawRequestData, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`callback`, into: &buf)
        FfiConverterString.write(value.`k1`, into: &buf)
        FfiConverterString.write(value.`defaultDescription`, into: &buf)
        FfiConverterUInt64.write(value.`minWithdrawable`, into: &buf)
        FfiConverterUInt64.write(value.`maxWithdrawable`, into: &buf)
    }
}


public struct LocaleOverrides {
    public var `locale`: String
    public var `spacing`: UInt32?
    public var `symbol`: Symbol

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`locale`: String, `spacing`: UInt32?, `symbol`: Symbol) {
        self.`locale` = `locale`
        self.`spacing` = `spacing`
        self.`symbol` = `symbol`
    }
}


extension LocaleOverrides: Equatable, Hashable {
    public static func ==(lhs: LocaleOverrides, rhs: LocaleOverrides) -> Bool {
        if lhs.`locale` != rhs.`locale` {
            return false
        }
        if lhs.`spacing` != rhs.`spacing` {
            return false
        }
        if lhs.`symbol` != rhs.`symbol` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`locale`)
        hasher.combine(`spacing`)
        hasher.combine(`symbol`)
    }
}


public struct FfiConverterTypeLocaleOverrides: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LocaleOverrides {
        return try LocaleOverrides(
            `locale`: FfiConverterString.read(from: &buf), 
            `spacing`: FfiConverterOptionUInt32.read(from: &buf), 
            `symbol`: FfiConverterTypeSymbol.read(from: &buf)
        )
    }

    public static func write(_ value: LocaleOverrides, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`locale`, into: &buf)
        FfiConverterOptionUInt32.write(value.`spacing`, into: &buf)
        FfiConverterTypeSymbol.write(value.`symbol`, into: &buf)
    }
}


public struct LocalizedName {
    public var `locale`: String
    public var `name`: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`locale`: String, `name`: String) {
        self.`locale` = `locale`
        self.`name` = `name`
    }
}


extension LocalizedName: Equatable, Hashable {
    public static func ==(lhs: LocalizedName, rhs: LocalizedName) -> Bool {
        if lhs.`locale` != rhs.`locale` {
            return false
        }
        if lhs.`name` != rhs.`name` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`locale`)
        hasher.combine(`name`)
    }
}


public struct FfiConverterTypeLocalizedName: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LocalizedName {
        return try LocalizedName(
            `locale`: FfiConverterString.read(from: &buf), 
            `name`: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: LocalizedName, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`locale`, into: &buf)
        FfiConverterString.write(value.`name`, into: &buf)
    }
}


public struct LogEntry {
    public var `line`: String
    public var `level`: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`line`: String, `level`: String) {
        self.`line` = `line`
        self.`level` = `level`
    }
}


extension LogEntry: Equatable, Hashable {
    public static func ==(lhs: LogEntry, rhs: LogEntry) -> Bool {
        if lhs.`line` != rhs.`line` {
            return false
        }
        if lhs.`level` != rhs.`level` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`line`)
        hasher.combine(`level`)
    }
}


public struct FfiConverterTypeLogEntry: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LogEntry {
        return try LogEntry(
            `line`: FfiConverterString.read(from: &buf), 
            `level`: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: LogEntry, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`line`, into: &buf)
        FfiConverterString.write(value.`level`, into: &buf)
    }
}


public struct LspInformation {
    public var `id`: String
    public var `name`: String
    public var `widgetUrl`: String
    public var `pubkey`: String
    public var `host`: String
    public var `channelCapacity`: Int64
    public var `targetConf`: Int32
    public var `baseFeeMsat`: Int64
    public var `feeRate`: Double
    public var `timeLockDelta`: UInt32
    public var `minHtlcMsat`: Int64
    public var `channelFeePermyriad`: Int64
    public var `lspPubkey`: [UInt8]
    public var `maxInactiveDuration`: Int64
    public var `channelMinimumFeeMsat`: Int64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`id`: String, `name`: String, `widgetUrl`: String, `pubkey`: String, `host`: String, `channelCapacity`: Int64, `targetConf`: Int32, `baseFeeMsat`: Int64, `feeRate`: Double, `timeLockDelta`: UInt32, `minHtlcMsat`: Int64, `channelFeePermyriad`: Int64, `lspPubkey`: [UInt8], `maxInactiveDuration`: Int64, `channelMinimumFeeMsat`: Int64) {
        self.`id` = `id`
        self.`name` = `name`
        self.`widgetUrl` = `widgetUrl`
        self.`pubkey` = `pubkey`
        self.`host` = `host`
        self.`channelCapacity` = `channelCapacity`
        self.`targetConf` = `targetConf`
        self.`baseFeeMsat` = `baseFeeMsat`
        self.`feeRate` = `feeRate`
        self.`timeLockDelta` = `timeLockDelta`
        self.`minHtlcMsat` = `minHtlcMsat`
        self.`channelFeePermyriad` = `channelFeePermyriad`
        self.`lspPubkey` = `lspPubkey`
        self.`maxInactiveDuration` = `maxInactiveDuration`
        self.`channelMinimumFeeMsat` = `channelMinimumFeeMsat`
    }
}


extension LspInformation: Equatable, Hashable {
    public static func ==(lhs: LspInformation, rhs: LspInformation) -> Bool {
        if lhs.`id` != rhs.`id` {
            return false
        }
        if lhs.`name` != rhs.`name` {
            return false
        }
        if lhs.`widgetUrl` != rhs.`widgetUrl` {
            return false
        }
        if lhs.`pubkey` != rhs.`pubkey` {
            return false
        }
        if lhs.`host` != rhs.`host` {
            return false
        }
        if lhs.`channelCapacity` != rhs.`channelCapacity` {
            return false
        }
        if lhs.`targetConf` != rhs.`targetConf` {
            return false
        }
        if lhs.`baseFeeMsat` != rhs.`baseFeeMsat` {
            return false
        }
        if lhs.`feeRate` != rhs.`feeRate` {
            return false
        }
        if lhs.`timeLockDelta` != rhs.`timeLockDelta` {
            return false
        }
        if lhs.`minHtlcMsat` != rhs.`minHtlcMsat` {
            return false
        }
        if lhs.`channelFeePermyriad` != rhs.`channelFeePermyriad` {
            return false
        }
        if lhs.`lspPubkey` != rhs.`lspPubkey` {
            return false
        }
        if lhs.`maxInactiveDuration` != rhs.`maxInactiveDuration` {
            return false
        }
        if lhs.`channelMinimumFeeMsat` != rhs.`channelMinimumFeeMsat` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`id`)
        hasher.combine(`name`)
        hasher.combine(`widgetUrl`)
        hasher.combine(`pubkey`)
        hasher.combine(`host`)
        hasher.combine(`channelCapacity`)
        hasher.combine(`targetConf`)
        hasher.combine(`baseFeeMsat`)
        hasher.combine(`feeRate`)
        hasher.combine(`timeLockDelta`)
        hasher.combine(`minHtlcMsat`)
        hasher.combine(`channelFeePermyriad`)
        hasher.combine(`lspPubkey`)
        hasher.combine(`maxInactiveDuration`)
        hasher.combine(`channelMinimumFeeMsat`)
    }
}


public struct FfiConverterTypeLspInformation: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LspInformation {
        return try LspInformation(
            `id`: FfiConverterString.read(from: &buf), 
            `name`: FfiConverterString.read(from: &buf), 
            `widgetUrl`: FfiConverterString.read(from: &buf), 
            `pubkey`: FfiConverterString.read(from: &buf), 
            `host`: FfiConverterString.read(from: &buf), 
            `channelCapacity`: FfiConverterInt64.read(from: &buf), 
            `targetConf`: FfiConverterInt32.read(from: &buf), 
            `baseFeeMsat`: FfiConverterInt64.read(from: &buf), 
            `feeRate`: FfiConverterDouble.read(from: &buf), 
            `timeLockDelta`: FfiConverterUInt32.read(from: &buf), 
            `minHtlcMsat`: FfiConverterInt64.read(from: &buf), 
            `channelFeePermyriad`: FfiConverterInt64.read(from: &buf), 
            `lspPubkey`: FfiConverterSequenceUInt8.read(from: &buf), 
            `maxInactiveDuration`: FfiConverterInt64.read(from: &buf), 
            `channelMinimumFeeMsat`: FfiConverterInt64.read(from: &buf)
        )
    }

    public static func write(_ value: LspInformation, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`id`, into: &buf)
        FfiConverterString.write(value.`name`, into: &buf)
        FfiConverterString.write(value.`widgetUrl`, into: &buf)
        FfiConverterString.write(value.`pubkey`, into: &buf)
        FfiConverterString.write(value.`host`, into: &buf)
        FfiConverterInt64.write(value.`channelCapacity`, into: &buf)
        FfiConverterInt32.write(value.`targetConf`, into: &buf)
        FfiConverterInt64.write(value.`baseFeeMsat`, into: &buf)
        FfiConverterDouble.write(value.`feeRate`, into: &buf)
        FfiConverterUInt32.write(value.`timeLockDelta`, into: &buf)
        FfiConverterInt64.write(value.`minHtlcMsat`, into: &buf)
        FfiConverterInt64.write(value.`channelFeePermyriad`, into: &buf)
        FfiConverterSequenceUInt8.write(value.`lspPubkey`, into: &buf)
        FfiConverterInt64.write(value.`maxInactiveDuration`, into: &buf)
        FfiConverterInt64.write(value.`channelMinimumFeeMsat`, into: &buf)
    }
}


public struct MessageSuccessActionData {
    public var `message`: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`message`: String) {
        self.`message` = `message`
    }
}


extension MessageSuccessActionData: Equatable, Hashable {
    public static func ==(lhs: MessageSuccessActionData, rhs: MessageSuccessActionData) -> Bool {
        if lhs.`message` != rhs.`message` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`message`)
    }
}


public struct FfiConverterTypeMessageSuccessActionData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MessageSuccessActionData {
        return try MessageSuccessActionData(
            `message`: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: MessageSuccessActionData, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`message`, into: &buf)
    }
}


public struct MetadataItem {
    public var `key`: String
    public var `value`: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`key`: String, `value`: String) {
        self.`key` = `key`
        self.`value` = `value`
    }
}


extension MetadataItem: Equatable, Hashable {
    public static func ==(lhs: MetadataItem, rhs: MetadataItem) -> Bool {
        if lhs.`key` != rhs.`key` {
            return false
        }
        if lhs.`value` != rhs.`value` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`key`)
        hasher.combine(`value`)
    }
}


public struct FfiConverterTypeMetadataItem: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MetadataItem {
        return try MetadataItem(
            `key`: FfiConverterString.read(from: &buf), 
            `value`: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: MetadataItem, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`key`, into: &buf)
        FfiConverterString.write(value.`value`, into: &buf)
    }
}


public struct NodeState {
    public var `id`: String
    public var `blockHeight`: UInt32
    public var `channelsBalanceMsat`: UInt64
    public var `onchainBalanceMsat`: UInt64
    public var `utxos`: [UnspentTransactionOutput]
    public var `maxPayableMsat`: UInt64
    public var `maxReceivableMsat`: UInt64
    public var `maxSinglePaymentAmountMsat`: UInt64
    public var `maxChanReserveMsats`: UInt64
    public var `connectedPeers`: [String]
    public var `inboundLiquidityMsats`: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`id`: String, `blockHeight`: UInt32, `channelsBalanceMsat`: UInt64, `onchainBalanceMsat`: UInt64, `utxos`: [UnspentTransactionOutput], `maxPayableMsat`: UInt64, `maxReceivableMsat`: UInt64, `maxSinglePaymentAmountMsat`: UInt64, `maxChanReserveMsats`: UInt64, `connectedPeers`: [String], `inboundLiquidityMsats`: UInt64) {
        self.`id` = `id`
        self.`blockHeight` = `blockHeight`
        self.`channelsBalanceMsat` = `channelsBalanceMsat`
        self.`onchainBalanceMsat` = `onchainBalanceMsat`
        self.`utxos` = `utxos`
        self.`maxPayableMsat` = `maxPayableMsat`
        self.`maxReceivableMsat` = `maxReceivableMsat`
        self.`maxSinglePaymentAmountMsat` = `maxSinglePaymentAmountMsat`
        self.`maxChanReserveMsats` = `maxChanReserveMsats`
        self.`connectedPeers` = `connectedPeers`
        self.`inboundLiquidityMsats` = `inboundLiquidityMsats`
    }
}


extension NodeState: Equatable, Hashable {
    public static func ==(lhs: NodeState, rhs: NodeState) -> Bool {
        if lhs.`id` != rhs.`id` {
            return false
        }
        if lhs.`blockHeight` != rhs.`blockHeight` {
            return false
        }
        if lhs.`channelsBalanceMsat` != rhs.`channelsBalanceMsat` {
            return false
        }
        if lhs.`onchainBalanceMsat` != rhs.`onchainBalanceMsat` {
            return false
        }
        if lhs.`utxos` != rhs.`utxos` {
            return false
        }
        if lhs.`maxPayableMsat` != rhs.`maxPayableMsat` {
            return false
        }
        if lhs.`maxReceivableMsat` != rhs.`maxReceivableMsat` {
            return false
        }
        if lhs.`maxSinglePaymentAmountMsat` != rhs.`maxSinglePaymentAmountMsat` {
            return false
        }
        if lhs.`maxChanReserveMsats` != rhs.`maxChanReserveMsats` {
            return false
        }
        if lhs.`connectedPeers` != rhs.`connectedPeers` {
            return false
        }
        if lhs.`inboundLiquidityMsats` != rhs.`inboundLiquidityMsats` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`id`)
        hasher.combine(`blockHeight`)
        hasher.combine(`channelsBalanceMsat`)
        hasher.combine(`onchainBalanceMsat`)
        hasher.combine(`utxos`)
        hasher.combine(`maxPayableMsat`)
        hasher.combine(`maxReceivableMsat`)
        hasher.combine(`maxSinglePaymentAmountMsat`)
        hasher.combine(`maxChanReserveMsats`)
        hasher.combine(`connectedPeers`)
        hasher.combine(`inboundLiquidityMsats`)
    }
}


public struct FfiConverterTypeNodeState: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NodeState {
        return try NodeState(
            `id`: FfiConverterString.read(from: &buf), 
            `blockHeight`: FfiConverterUInt32.read(from: &buf), 
            `channelsBalanceMsat`: FfiConverterUInt64.read(from: &buf), 
            `onchainBalanceMsat`: FfiConverterUInt64.read(from: &buf), 
            `utxos`: FfiConverterSequenceTypeUnspentTransactionOutput.read(from: &buf), 
            `maxPayableMsat`: FfiConverterUInt64.read(from: &buf), 
            `maxReceivableMsat`: FfiConverterUInt64.read(from: &buf), 
            `maxSinglePaymentAmountMsat`: FfiConverterUInt64.read(from: &buf), 
            `maxChanReserveMsats`: FfiConverterUInt64.read(from: &buf), 
            `connectedPeers`: FfiConverterSequenceString.read(from: &buf), 
            `inboundLiquidityMsats`: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: NodeState, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`id`, into: &buf)
        FfiConverterUInt32.write(value.`blockHeight`, into: &buf)
        FfiConverterUInt64.write(value.`channelsBalanceMsat`, into: &buf)
        FfiConverterUInt64.write(value.`onchainBalanceMsat`, into: &buf)
        FfiConverterSequenceTypeUnspentTransactionOutput.write(value.`utxos`, into: &buf)
        FfiConverterUInt64.write(value.`maxPayableMsat`, into: &buf)
        FfiConverterUInt64.write(value.`maxReceivableMsat`, into: &buf)
        FfiConverterUInt64.write(value.`maxSinglePaymentAmountMsat`, into: &buf)
        FfiConverterUInt64.write(value.`maxChanReserveMsats`, into: &buf)
        FfiConverterSequenceString.write(value.`connectedPeers`, into: &buf)
        FfiConverterUInt64.write(value.`inboundLiquidityMsats`, into: &buf)
    }
}


public struct Payment {
    public var `id`: String
    public var `paymentType`: PaymentType
    public var `paymentTime`: Int64
    public var `amountMsat`: UInt64
    public var `feeMsat`: UInt64
    public var `pending`: Bool
    public var `description`: String?
    public var `details`: PaymentDetails

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`id`: String, `paymentType`: PaymentType, `paymentTime`: Int64, `amountMsat`: UInt64, `feeMsat`: UInt64, `pending`: Bool, `description`: String?, `details`: PaymentDetails) {
        self.`id` = `id`
        self.`paymentType` = `paymentType`
        self.`paymentTime` = `paymentTime`
        self.`amountMsat` = `amountMsat`
        self.`feeMsat` = `feeMsat`
        self.`pending` = `pending`
        self.`description` = `description`
        self.`details` = `details`
    }
}


extension Payment: Equatable, Hashable {
    public static func ==(lhs: Payment, rhs: Payment) -> Bool {
        if lhs.`id` != rhs.`id` {
            return false
        }
        if lhs.`paymentType` != rhs.`paymentType` {
            return false
        }
        if lhs.`paymentTime` != rhs.`paymentTime` {
            return false
        }
        if lhs.`amountMsat` != rhs.`amountMsat` {
            return false
        }
        if lhs.`feeMsat` != rhs.`feeMsat` {
            return false
        }
        if lhs.`pending` != rhs.`pending` {
            return false
        }
        if lhs.`description` != rhs.`description` {
            return false
        }
        if lhs.`details` != rhs.`details` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`id`)
        hasher.combine(`paymentType`)
        hasher.combine(`paymentTime`)
        hasher.combine(`amountMsat`)
        hasher.combine(`feeMsat`)
        hasher.combine(`pending`)
        hasher.combine(`description`)
        hasher.combine(`details`)
    }
}


public struct FfiConverterTypePayment: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Payment {
        return try Payment(
            `id`: FfiConverterString.read(from: &buf), 
            `paymentType`: FfiConverterTypePaymentType.read(from: &buf), 
            `paymentTime`: FfiConverterInt64.read(from: &buf), 
            `amountMsat`: FfiConverterUInt64.read(from: &buf), 
            `feeMsat`: FfiConverterUInt64.read(from: &buf), 
            `pending`: FfiConverterBool.read(from: &buf), 
            `description`: FfiConverterOptionString.read(from: &buf), 
            `details`: FfiConverterTypePaymentDetails.read(from: &buf)
        )
    }

    public static func write(_ value: Payment, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`id`, into: &buf)
        FfiConverterTypePaymentType.write(value.`paymentType`, into: &buf)
        FfiConverterInt64.write(value.`paymentTime`, into: &buf)
        FfiConverterUInt64.write(value.`amountMsat`, into: &buf)
        FfiConverterUInt64.write(value.`feeMsat`, into: &buf)
        FfiConverterBool.write(value.`pending`, into: &buf)
        FfiConverterOptionString.write(value.`description`, into: &buf)
        FfiConverterTypePaymentDetails.write(value.`details`, into: &buf)
    }
}


public struct Rate {
    public var `coin`: String
    public var `value`: Double

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`coin`: String, `value`: Double) {
        self.`coin` = `coin`
        self.`value` = `value`
    }
}


extension Rate: Equatable, Hashable {
    public static func ==(lhs: Rate, rhs: Rate) -> Bool {
        if lhs.`coin` != rhs.`coin` {
            return false
        }
        if lhs.`value` != rhs.`value` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`coin`)
        hasher.combine(`value`)
    }
}


public struct FfiConverterTypeRate: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Rate {
        return try Rate(
            `coin`: FfiConverterString.read(from: &buf), 
            `value`: FfiConverterDouble.read(from: &buf)
        )
    }

    public static func write(_ value: Rate, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`coin`, into: &buf)
        FfiConverterDouble.write(value.`value`, into: &buf)
    }
}


public struct RecommendedFees {
    public var `fastestFee`: UInt32
    public var `halfHourFee`: UInt32
    public var `hourFee`: UInt32
    public var `economyFee`: UInt32
    public var `minimumFee`: UInt32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`fastestFee`: UInt32, `halfHourFee`: UInt32, `hourFee`: UInt32, `economyFee`: UInt32, `minimumFee`: UInt32) {
        self.`fastestFee` = `fastestFee`
        self.`halfHourFee` = `halfHourFee`
        self.`hourFee` = `hourFee`
        self.`economyFee` = `economyFee`
        self.`minimumFee` = `minimumFee`
    }
}


extension RecommendedFees: Equatable, Hashable {
    public static func ==(lhs: RecommendedFees, rhs: RecommendedFees) -> Bool {
        if lhs.`fastestFee` != rhs.`fastestFee` {
            return false
        }
        if lhs.`halfHourFee` != rhs.`halfHourFee` {
            return false
        }
        if lhs.`hourFee` != rhs.`hourFee` {
            return false
        }
        if lhs.`economyFee` != rhs.`economyFee` {
            return false
        }
        if lhs.`minimumFee` != rhs.`minimumFee` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`fastestFee`)
        hasher.combine(`halfHourFee`)
        hasher.combine(`hourFee`)
        hasher.combine(`economyFee`)
        hasher.combine(`minimumFee`)
    }
}


public struct FfiConverterTypeRecommendedFees: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RecommendedFees {
        return try RecommendedFees(
            `fastestFee`: FfiConverterUInt32.read(from: &buf), 
            `halfHourFee`: FfiConverterUInt32.read(from: &buf), 
            `hourFee`: FfiConverterUInt32.read(from: &buf), 
            `economyFee`: FfiConverterUInt32.read(from: &buf), 
            `minimumFee`: FfiConverterUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: RecommendedFees, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.`fastestFee`, into: &buf)
        FfiConverterUInt32.write(value.`halfHourFee`, into: &buf)
        FfiConverterUInt32.write(value.`hourFee`, into: &buf)
        FfiConverterUInt32.write(value.`economyFee`, into: &buf)
        FfiConverterUInt32.write(value.`minimumFee`, into: &buf)
    }
}


public struct RouteHint {
    public var `hops`: [RouteHintHop]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`hops`: [RouteHintHop]) {
        self.`hops` = `hops`
    }
}


extension RouteHint: Equatable, Hashable {
    public static func ==(lhs: RouteHint, rhs: RouteHint) -> Bool {
        if lhs.`hops` != rhs.`hops` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`hops`)
    }
}


public struct FfiConverterTypeRouteHint: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RouteHint {
        return try RouteHint(
            `hops`: FfiConverterSequenceTypeRouteHintHop.read(from: &buf)
        )
    }

    public static func write(_ value: RouteHint, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeRouteHintHop.write(value.`hops`, into: &buf)
    }
}


public struct RouteHintHop {
    public var `srcNodeId`: String
    public var `shortChannelId`: UInt64
    public var `feesBaseMsat`: UInt32
    public var `feesProportionalMillionths`: UInt32
    public var `cltvExpiryDelta`: UInt64
    public var `htlcMinimumMsat`: UInt64?
    public var `htlcMaximumMsat`: UInt64?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`srcNodeId`: String, `shortChannelId`: UInt64, `feesBaseMsat`: UInt32, `feesProportionalMillionths`: UInt32, `cltvExpiryDelta`: UInt64, `htlcMinimumMsat`: UInt64?, `htlcMaximumMsat`: UInt64?) {
        self.`srcNodeId` = `srcNodeId`
        self.`shortChannelId` = `shortChannelId`
        self.`feesBaseMsat` = `feesBaseMsat`
        self.`feesProportionalMillionths` = `feesProportionalMillionths`
        self.`cltvExpiryDelta` = `cltvExpiryDelta`
        self.`htlcMinimumMsat` = `htlcMinimumMsat`
        self.`htlcMaximumMsat` = `htlcMaximumMsat`
    }
}


extension RouteHintHop: Equatable, Hashable {
    public static func ==(lhs: RouteHintHop, rhs: RouteHintHop) -> Bool {
        if lhs.`srcNodeId` != rhs.`srcNodeId` {
            return false
        }
        if lhs.`shortChannelId` != rhs.`shortChannelId` {
            return false
        }
        if lhs.`feesBaseMsat` != rhs.`feesBaseMsat` {
            return false
        }
        if lhs.`feesProportionalMillionths` != rhs.`feesProportionalMillionths` {
            return false
        }
        if lhs.`cltvExpiryDelta` != rhs.`cltvExpiryDelta` {
            return false
        }
        if lhs.`htlcMinimumMsat` != rhs.`htlcMinimumMsat` {
            return false
        }
        if lhs.`htlcMaximumMsat` != rhs.`htlcMaximumMsat` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`srcNodeId`)
        hasher.combine(`shortChannelId`)
        hasher.combine(`feesBaseMsat`)
        hasher.combine(`feesProportionalMillionths`)
        hasher.combine(`cltvExpiryDelta`)
        hasher.combine(`htlcMinimumMsat`)
        hasher.combine(`htlcMaximumMsat`)
    }
}


public struct FfiConverterTypeRouteHintHop: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RouteHintHop {
        return try RouteHintHop(
            `srcNodeId`: FfiConverterString.read(from: &buf), 
            `shortChannelId`: FfiConverterUInt64.read(from: &buf), 
            `feesBaseMsat`: FfiConverterUInt32.read(from: &buf), 
            `feesProportionalMillionths`: FfiConverterUInt32.read(from: &buf), 
            `cltvExpiryDelta`: FfiConverterUInt64.read(from: &buf), 
            `htlcMinimumMsat`: FfiConverterOptionUInt64.read(from: &buf), 
            `htlcMaximumMsat`: FfiConverterOptionUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: RouteHintHop, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`srcNodeId`, into: &buf)
        FfiConverterUInt64.write(value.`shortChannelId`, into: &buf)
        FfiConverterUInt32.write(value.`feesBaseMsat`, into: &buf)
        FfiConverterUInt32.write(value.`feesProportionalMillionths`, into: &buf)
        FfiConverterUInt64.write(value.`cltvExpiryDelta`, into: &buf)
        FfiConverterOptionUInt64.write(value.`htlcMinimumMsat`, into: &buf)
        FfiConverterOptionUInt64.write(value.`htlcMaximumMsat`, into: &buf)
    }
}


public struct SwapInfo {
    public var `bitcoinAddress`: String
    public var `createdAt`: Int64
    public var `lockHeight`: Int64
    public var `paymentHash`: [UInt8]
    public var `preimage`: [UInt8]
    public var `privateKey`: [UInt8]
    public var `publicKey`: [UInt8]
    public var `swapperPublicKey`: [UInt8]
    public var `script`: [UInt8]
    public var `bolt11`: String?
    public var `paidSats`: UInt32
    public var `unconfirmedSats`: UInt32
    public var `confirmedSats`: UInt32
    public var `status`: SwapStatus
    public var `refundTxIds`: [String]
    public var `unconfirmedTxIds`: [String]
    public var `confirmedTxIds`: [String]
    public var `minAllowedDeposit`: Int64
    public var `maxAllowedDeposit`: Int64
    public var `lastRedeemError`: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`bitcoinAddress`: String, `createdAt`: Int64, `lockHeight`: Int64, `paymentHash`: [UInt8], `preimage`: [UInt8], `privateKey`: [UInt8], `publicKey`: [UInt8], `swapperPublicKey`: [UInt8], `script`: [UInt8], `bolt11`: String?, `paidSats`: UInt32, `unconfirmedSats`: UInt32, `confirmedSats`: UInt32, `status`: SwapStatus, `refundTxIds`: [String], `unconfirmedTxIds`: [String], `confirmedTxIds`: [String], `minAllowedDeposit`: Int64, `maxAllowedDeposit`: Int64, `lastRedeemError`: String?) {
        self.`bitcoinAddress` = `bitcoinAddress`
        self.`createdAt` = `createdAt`
        self.`lockHeight` = `lockHeight`
        self.`paymentHash` = `paymentHash`
        self.`preimage` = `preimage`
        self.`privateKey` = `privateKey`
        self.`publicKey` = `publicKey`
        self.`swapperPublicKey` = `swapperPublicKey`
        self.`script` = `script`
        self.`bolt11` = `bolt11`
        self.`paidSats` = `paidSats`
        self.`unconfirmedSats` = `unconfirmedSats`
        self.`confirmedSats` = `confirmedSats`
        self.`status` = `status`
        self.`refundTxIds` = `refundTxIds`
        self.`unconfirmedTxIds` = `unconfirmedTxIds`
        self.`confirmedTxIds` = `confirmedTxIds`
        self.`minAllowedDeposit` = `minAllowedDeposit`
        self.`maxAllowedDeposit` = `maxAllowedDeposit`
        self.`lastRedeemError` = `lastRedeemError`
    }
}


extension SwapInfo: Equatable, Hashable {
    public static func ==(lhs: SwapInfo, rhs: SwapInfo) -> Bool {
        if lhs.`bitcoinAddress` != rhs.`bitcoinAddress` {
            return false
        }
        if lhs.`createdAt` != rhs.`createdAt` {
            return false
        }
        if lhs.`lockHeight` != rhs.`lockHeight` {
            return false
        }
        if lhs.`paymentHash` != rhs.`paymentHash` {
            return false
        }
        if lhs.`preimage` != rhs.`preimage` {
            return false
        }
        if lhs.`privateKey` != rhs.`privateKey` {
            return false
        }
        if lhs.`publicKey` != rhs.`publicKey` {
            return false
        }
        if lhs.`swapperPublicKey` != rhs.`swapperPublicKey` {
            return false
        }
        if lhs.`script` != rhs.`script` {
            return false
        }
        if lhs.`bolt11` != rhs.`bolt11` {
            return false
        }
        if lhs.`paidSats` != rhs.`paidSats` {
            return false
        }
        if lhs.`unconfirmedSats` != rhs.`unconfirmedSats` {
            return false
        }
        if lhs.`confirmedSats` != rhs.`confirmedSats` {
            return false
        }
        if lhs.`status` != rhs.`status` {
            return false
        }
        if lhs.`refundTxIds` != rhs.`refundTxIds` {
            return false
        }
        if lhs.`unconfirmedTxIds` != rhs.`unconfirmedTxIds` {
            return false
        }
        if lhs.`confirmedTxIds` != rhs.`confirmedTxIds` {
            return false
        }
        if lhs.`minAllowedDeposit` != rhs.`minAllowedDeposit` {
            return false
        }
        if lhs.`maxAllowedDeposit` != rhs.`maxAllowedDeposit` {
            return false
        }
        if lhs.`lastRedeemError` != rhs.`lastRedeemError` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`bitcoinAddress`)
        hasher.combine(`createdAt`)
        hasher.combine(`lockHeight`)
        hasher.combine(`paymentHash`)
        hasher.combine(`preimage`)
        hasher.combine(`privateKey`)
        hasher.combine(`publicKey`)
        hasher.combine(`swapperPublicKey`)
        hasher.combine(`script`)
        hasher.combine(`bolt11`)
        hasher.combine(`paidSats`)
        hasher.combine(`unconfirmedSats`)
        hasher.combine(`confirmedSats`)
        hasher.combine(`status`)
        hasher.combine(`refundTxIds`)
        hasher.combine(`unconfirmedTxIds`)
        hasher.combine(`confirmedTxIds`)
        hasher.combine(`minAllowedDeposit`)
        hasher.combine(`maxAllowedDeposit`)
        hasher.combine(`lastRedeemError`)
    }
}


public struct FfiConverterTypeSwapInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwapInfo {
        return try SwapInfo(
            `bitcoinAddress`: FfiConverterString.read(from: &buf), 
            `createdAt`: FfiConverterInt64.read(from: &buf), 
            `lockHeight`: FfiConverterInt64.read(from: &buf), 
            `paymentHash`: FfiConverterSequenceUInt8.read(from: &buf), 
            `preimage`: FfiConverterSequenceUInt8.read(from: &buf), 
            `privateKey`: FfiConverterSequenceUInt8.read(from: &buf), 
            `publicKey`: FfiConverterSequenceUInt8.read(from: &buf), 
            `swapperPublicKey`: FfiConverterSequenceUInt8.read(from: &buf), 
            `script`: FfiConverterSequenceUInt8.read(from: &buf), 
            `bolt11`: FfiConverterOptionString.read(from: &buf), 
            `paidSats`: FfiConverterUInt32.read(from: &buf), 
            `unconfirmedSats`: FfiConverterUInt32.read(from: &buf), 
            `confirmedSats`: FfiConverterUInt32.read(from: &buf), 
            `status`: FfiConverterTypeSwapStatus.read(from: &buf), 
            `refundTxIds`: FfiConverterSequenceString.read(from: &buf), 
            `unconfirmedTxIds`: FfiConverterSequenceString.read(from: &buf), 
            `confirmedTxIds`: FfiConverterSequenceString.read(from: &buf), 
            `minAllowedDeposit`: FfiConverterInt64.read(from: &buf), 
            `maxAllowedDeposit`: FfiConverterInt64.read(from: &buf), 
            `lastRedeemError`: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: SwapInfo, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`bitcoinAddress`, into: &buf)
        FfiConverterInt64.write(value.`createdAt`, into: &buf)
        FfiConverterInt64.write(value.`lockHeight`, into: &buf)
        FfiConverterSequenceUInt8.write(value.`paymentHash`, into: &buf)
        FfiConverterSequenceUInt8.write(value.`preimage`, into: &buf)
        FfiConverterSequenceUInt8.write(value.`privateKey`, into: &buf)
        FfiConverterSequenceUInt8.write(value.`publicKey`, into: &buf)
        FfiConverterSequenceUInt8.write(value.`swapperPublicKey`, into: &buf)
        FfiConverterSequenceUInt8.write(value.`script`, into: &buf)
        FfiConverterOptionString.write(value.`bolt11`, into: &buf)
        FfiConverterUInt32.write(value.`paidSats`, into: &buf)
        FfiConverterUInt32.write(value.`unconfirmedSats`, into: &buf)
        FfiConverterUInt32.write(value.`confirmedSats`, into: &buf)
        FfiConverterTypeSwapStatus.write(value.`status`, into: &buf)
        FfiConverterSequenceString.write(value.`refundTxIds`, into: &buf)
        FfiConverterSequenceString.write(value.`unconfirmedTxIds`, into: &buf)
        FfiConverterSequenceString.write(value.`confirmedTxIds`, into: &buf)
        FfiConverterInt64.write(value.`minAllowedDeposit`, into: &buf)
        FfiConverterInt64.write(value.`maxAllowedDeposit`, into: &buf)
        FfiConverterOptionString.write(value.`lastRedeemError`, into: &buf)
    }
}


public struct Symbol {
    public var `grapheme`: String?
    public var `template`: String?
    public var `rtl`: Bool?
    public var `position`: UInt32?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`grapheme`: String?, `template`: String?, `rtl`: Bool?, `position`: UInt32?) {
        self.`grapheme` = `grapheme`
        self.`template` = `template`
        self.`rtl` = `rtl`
        self.`position` = `position`
    }
}


extension Symbol: Equatable, Hashable {
    public static func ==(lhs: Symbol, rhs: Symbol) -> Bool {
        if lhs.`grapheme` != rhs.`grapheme` {
            return false
        }
        if lhs.`template` != rhs.`template` {
            return false
        }
        if lhs.`rtl` != rhs.`rtl` {
            return false
        }
        if lhs.`position` != rhs.`position` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`grapheme`)
        hasher.combine(`template`)
        hasher.combine(`rtl`)
        hasher.combine(`position`)
    }
}


public struct FfiConverterTypeSymbol: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Symbol {
        return try Symbol(
            `grapheme`: FfiConverterOptionString.read(from: &buf), 
            `template`: FfiConverterOptionString.read(from: &buf), 
            `rtl`: FfiConverterOptionBool.read(from: &buf), 
            `position`: FfiConverterOptionUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: Symbol, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.`grapheme`, into: &buf)
        FfiConverterOptionString.write(value.`template`, into: &buf)
        FfiConverterOptionBool.write(value.`rtl`, into: &buf)
        FfiConverterOptionUInt32.write(value.`position`, into: &buf)
    }
}


public struct UnspentTransactionOutput {
    public var `txid`: [UInt8]
    public var `outnum`: UInt32
    public var `amountMillisatoshi`: UInt64
    public var `address`: String
    public var `reserved`: Bool
    public var `reservedToBlock`: UInt32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`txid`: [UInt8], `outnum`: UInt32, `amountMillisatoshi`: UInt64, `address`: String, `reserved`: Bool, `reservedToBlock`: UInt32) {
        self.`txid` = `txid`
        self.`outnum` = `outnum`
        self.`amountMillisatoshi` = `amountMillisatoshi`
        self.`address` = `address`
        self.`reserved` = `reserved`
        self.`reservedToBlock` = `reservedToBlock`
    }
}


extension UnspentTransactionOutput: Equatable, Hashable {
    public static func ==(lhs: UnspentTransactionOutput, rhs: UnspentTransactionOutput) -> Bool {
        if lhs.`txid` != rhs.`txid` {
            return false
        }
        if lhs.`outnum` != rhs.`outnum` {
            return false
        }
        if lhs.`amountMillisatoshi` != rhs.`amountMillisatoshi` {
            return false
        }
        if lhs.`address` != rhs.`address` {
            return false
        }
        if lhs.`reserved` != rhs.`reserved` {
            return false
        }
        if lhs.`reservedToBlock` != rhs.`reservedToBlock` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`txid`)
        hasher.combine(`outnum`)
        hasher.combine(`amountMillisatoshi`)
        hasher.combine(`address`)
        hasher.combine(`reserved`)
        hasher.combine(`reservedToBlock`)
    }
}


public struct FfiConverterTypeUnspentTransactionOutput: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UnspentTransactionOutput {
        return try UnspentTransactionOutput(
            `txid`: FfiConverterSequenceUInt8.read(from: &buf), 
            `outnum`: FfiConverterUInt32.read(from: &buf), 
            `amountMillisatoshi`: FfiConverterUInt64.read(from: &buf), 
            `address`: FfiConverterString.read(from: &buf), 
            `reserved`: FfiConverterBool.read(from: &buf), 
            `reservedToBlock`: FfiConverterUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: UnspentTransactionOutput, into buf: inout [UInt8]) {
        FfiConverterSequenceUInt8.write(value.`txid`, into: &buf)
        FfiConverterUInt32.write(value.`outnum`, into: &buf)
        FfiConverterUInt64.write(value.`amountMillisatoshi`, into: &buf)
        FfiConverterString.write(value.`address`, into: &buf)
        FfiConverterBool.write(value.`reserved`, into: &buf)
        FfiConverterUInt32.write(value.`reservedToBlock`, into: &buf)
    }
}


public struct UrlSuccessActionData {
    public var `description`: String
    public var `url`: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`description`: String, `url`: String) {
        self.`description` = `description`
        self.`url` = `url`
    }
}


extension UrlSuccessActionData: Equatable, Hashable {
    public static func ==(lhs: UrlSuccessActionData, rhs: UrlSuccessActionData) -> Bool {
        if lhs.`description` != rhs.`description` {
            return false
        }
        if lhs.`url` != rhs.`url` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`description`)
        hasher.combine(`url`)
    }
}


public struct FfiConverterTypeUrlSuccessActionData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UrlSuccessActionData {
        return try UrlSuccessActionData(
            `description`: FfiConverterString.read(from: &buf), 
            `url`: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: UrlSuccessActionData, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`description`, into: &buf)
        FfiConverterString.write(value.`url`, into: &buf)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum BreezEvent {
    
    case `newBlock`(`block`: UInt32)
    case `invoicePaid`(`details`: InvoicePaidDetails)
    case `synced`
    case `paymentSucceed`(`details`: Payment)
    case `paymentFailed`(`error`: String)
}

public struct FfiConverterTypeBreezEvent: FfiConverterRustBuffer {
    typealias SwiftType = BreezEvent

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BreezEvent {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`newBlock`(
            `block`: try FfiConverterUInt32.read(from: &buf)
        )
        
        case 2: return .`invoicePaid`(
            `details`: try FfiConverterTypeInvoicePaidDetails.read(from: &buf)
        )
        
        case 3: return .`synced`
        
        case 4: return .`paymentSucceed`(
            `details`: try FfiConverterTypePayment.read(from: &buf)
        )
        
        case 5: return .`paymentFailed`(
            `error`: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: BreezEvent, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .`newBlock`(`block`):
            writeInt(&buf, Int32(1))
            FfiConverterUInt32.write(`block`, into: &buf)
            
        
        case let .`invoicePaid`(`details`):
            writeInt(&buf, Int32(2))
            FfiConverterTypeInvoicePaidDetails.write(`details`, into: &buf)
            
        
        case .`synced`:
            writeInt(&buf, Int32(3))
        
        
        case let .`paymentSucceed`(`details`):
            writeInt(&buf, Int32(4))
            FfiConverterTypePayment.write(`details`, into: &buf)
            
        
        case let .`paymentFailed`(`error`):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(`error`, into: &buf)
            
        }
    }
}


extension BreezEvent: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum ChannelState {
    
    case `pendingOpen`
    case `opened`
    case `pendingClose`
    case `closed`
}

public struct FfiConverterTypeChannelState: FfiConverterRustBuffer {
    typealias SwiftType = ChannelState

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ChannelState {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`pendingOpen`
        
        case 2: return .`opened`
        
        case 3: return .`pendingClose`
        
        case 4: return .`closed`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ChannelState, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`pendingOpen`:
            writeInt(&buf, Int32(1))
        
        
        case .`opened`:
            writeInt(&buf, Int32(2))
        
        
        case .`pendingClose`:
            writeInt(&buf, Int32(3))
        
        
        case .`closed`:
            writeInt(&buf, Int32(4))
        
        }
    }
}


extension ChannelState: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum EnvironmentType {
    
    case `production`
    case `staging`
}

public struct FfiConverterTypeEnvironmentType: FfiConverterRustBuffer {
    typealias SwiftType = EnvironmentType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EnvironmentType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`production`
        
        case 2: return .`staging`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: EnvironmentType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`production`:
            writeInt(&buf, Int32(1))
        
        
        case .`staging`:
            writeInt(&buf, Int32(2))
        
        }
    }
}


extension EnvironmentType: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum FeeratePreset {
    
    case `regular`
    case `economy`
    case `priority`
}

public struct FfiConverterTypeFeeratePreset: FfiConverterRustBuffer {
    typealias SwiftType = FeeratePreset

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FeeratePreset {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`regular`
        
        case 2: return .`economy`
        
        case 3: return .`priority`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FeeratePreset, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`regular`:
            writeInt(&buf, Int32(1))
        
        
        case .`economy`:
            writeInt(&buf, Int32(2))
        
        
        case .`priority`:
            writeInt(&buf, Int32(3))
        
        }
    }
}


extension FeeratePreset: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum InputType {
    
    case `bitcoinAddress`(`address`: BitcoinAddressData)
    case `bolt11`(`invoice`: LnInvoice)
    case `nodeId`(`nodeId`: String)
    case `url`(`url`: String)
    case `lnUrlPay`(`data`: LnUrlPayRequestData)
    case `lnUrlWithdraw`(`data`: LnUrlWithdrawRequestData)
    case `lnUrlAuth`(`data`: LnUrlAuthRequestData)
    case `lnUrlError`(`data`: LnUrlErrorData)
}

public struct FfiConverterTypeInputType: FfiConverterRustBuffer {
    typealias SwiftType = InputType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> InputType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`bitcoinAddress`(
            `address`: try FfiConverterTypeBitcoinAddressData.read(from: &buf)
        )
        
        case 2: return .`bolt11`(
            `invoice`: try FfiConverterTypeLnInvoice.read(from: &buf)
        )
        
        case 3: return .`nodeId`(
            `nodeId`: try FfiConverterString.read(from: &buf)
        )
        
        case 4: return .`url`(
            `url`: try FfiConverterString.read(from: &buf)
        )
        
        case 5: return .`lnUrlPay`(
            `data`: try FfiConverterTypeLnUrlPayRequestData.read(from: &buf)
        )
        
        case 6: return .`lnUrlWithdraw`(
            `data`: try FfiConverterTypeLnUrlWithdrawRequestData.read(from: &buf)
        )
        
        case 7: return .`lnUrlAuth`(
            `data`: try FfiConverterTypeLnUrlAuthRequestData.read(from: &buf)
        )
        
        case 8: return .`lnUrlError`(
            `data`: try FfiConverterTypeLnUrlErrorData.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: InputType, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .`bitcoinAddress`(`address`):
            writeInt(&buf, Int32(1))
            FfiConverterTypeBitcoinAddressData.write(`address`, into: &buf)
            
        
        case let .`bolt11`(`invoice`):
            writeInt(&buf, Int32(2))
            FfiConverterTypeLnInvoice.write(`invoice`, into: &buf)
            
        
        case let .`nodeId`(`nodeId`):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(`nodeId`, into: &buf)
            
        
        case let .`url`(`url`):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(`url`, into: &buf)
            
        
        case let .`lnUrlPay`(`data`):
            writeInt(&buf, Int32(5))
            FfiConverterTypeLnUrlPayRequestData.write(`data`, into: &buf)
            
        
        case let .`lnUrlWithdraw`(`data`):
            writeInt(&buf, Int32(6))
            FfiConverterTypeLnUrlWithdrawRequestData.write(`data`, into: &buf)
            
        
        case let .`lnUrlAuth`(`data`):
            writeInt(&buf, Int32(7))
            FfiConverterTypeLnUrlAuthRequestData.write(`data`, into: &buf)
            
        
        case let .`lnUrlError`(`data`):
            writeInt(&buf, Int32(8))
            FfiConverterTypeLnUrlErrorData.write(`data`, into: &buf)
            
        }
    }
}


extension InputType: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum LnUrlWithdrawCallbackStatus {
    
    case `ok`
    case `errorStatus`(`data`: LnUrlErrorData)
}

public struct FfiConverterTypeLnUrlWithdrawCallbackStatus: FfiConverterRustBuffer {
    typealias SwiftType = LnUrlWithdrawCallbackStatus

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LnUrlWithdrawCallbackStatus {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`ok`
        
        case 2: return .`errorStatus`(
            `data`: try FfiConverterTypeLnUrlErrorData.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: LnUrlWithdrawCallbackStatus, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`ok`:
            writeInt(&buf, Int32(1))
        
        
        case let .`errorStatus`(`data`):
            writeInt(&buf, Int32(2))
            FfiConverterTypeLnUrlErrorData.write(`data`, into: &buf)
            
        }
    }
}


extension LnUrlWithdrawCallbackStatus: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum Network {
    
    case `bitcoin`
    case `testnet`
    case `signet`
    case `regtest`
}

public struct FfiConverterTypeNetwork: FfiConverterRustBuffer {
    typealias SwiftType = Network

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Network {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`bitcoin`
        
        case 2: return .`testnet`
        
        case 3: return .`signet`
        
        case 4: return .`regtest`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Network, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`bitcoin`:
            writeInt(&buf, Int32(1))
        
        
        case .`testnet`:
            writeInt(&buf, Int32(2))
        
        
        case .`signet`:
            writeInt(&buf, Int32(3))
        
        
        case .`regtest`:
            writeInt(&buf, Int32(4))
        
        }
    }
}


extension Network: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum PaymentDetails {
    
    case `ln`(`data`: LnPaymentDetails)
    case `closedChannel`(`data`: ClosedChannelPaymentDetails)
}

public struct FfiConverterTypePaymentDetails: FfiConverterRustBuffer {
    typealias SwiftType = PaymentDetails

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PaymentDetails {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`ln`(
            `data`: try FfiConverterTypeLnPaymentDetails.read(from: &buf)
        )
        
        case 2: return .`closedChannel`(
            `data`: try FfiConverterTypeClosedChannelPaymentDetails.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PaymentDetails, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .`ln`(`data`):
            writeInt(&buf, Int32(1))
            FfiConverterTypeLnPaymentDetails.write(`data`, into: &buf)
            
        
        case let .`closedChannel`(`data`):
            writeInt(&buf, Int32(2))
            FfiConverterTypeClosedChannelPaymentDetails.write(`data`, into: &buf)
            
        }
    }
}


extension PaymentDetails: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum PaymentType {
    
    case `sent`
    case `received`
    case `closedChannel`
}

public struct FfiConverterTypePaymentType: FfiConverterRustBuffer {
    typealias SwiftType = PaymentType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PaymentType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`sent`
        
        case 2: return .`received`
        
        case 3: return .`closedChannel`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PaymentType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`sent`:
            writeInt(&buf, Int32(1))
        
        
        case .`received`:
            writeInt(&buf, Int32(2))
        
        
        case .`closedChannel`:
            writeInt(&buf, Int32(3))
        
        }
    }
}


extension PaymentType: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum PaymentTypeFilter {
    
    case `sent`
    case `received`
    case `all`
}

public struct FfiConverterTypePaymentTypeFilter: FfiConverterRustBuffer {
    typealias SwiftType = PaymentTypeFilter

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PaymentTypeFilter {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`sent`
        
        case 2: return .`received`
        
        case 3: return .`all`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PaymentTypeFilter, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`sent`:
            writeInt(&buf, Int32(1))
        
        
        case .`received`:
            writeInt(&buf, Int32(2))
        
        
        case .`all`:
            writeInt(&buf, Int32(3))
        
        }
    }
}


extension PaymentTypeFilter: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum SuccessActionProcessed {
    
    case `aes`(`data`: AesSuccessActionDataDecrypted)
    case `message`(`data`: MessageSuccessActionData)
    case `url`(`data`: UrlSuccessActionData)
}

public struct FfiConverterTypeSuccessActionProcessed: FfiConverterRustBuffer {
    typealias SwiftType = SuccessActionProcessed

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SuccessActionProcessed {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`aes`(
            `data`: try FfiConverterTypeAesSuccessActionDataDecrypted.read(from: &buf)
        )
        
        case 2: return .`message`(
            `data`: try FfiConverterTypeMessageSuccessActionData.read(from: &buf)
        )
        
        case 3: return .`url`(
            `data`: try FfiConverterTypeUrlSuccessActionData.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SuccessActionProcessed, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .`aes`(`data`):
            writeInt(&buf, Int32(1))
            FfiConverterTypeAesSuccessActionDataDecrypted.write(`data`, into: &buf)
            
        
        case let .`message`(`data`):
            writeInt(&buf, Int32(2))
            FfiConverterTypeMessageSuccessActionData.write(`data`, into: &buf)
            
        
        case let .`url`(`data`):
            writeInt(&buf, Int32(3))
            FfiConverterTypeUrlSuccessActionData.write(`data`, into: &buf)
            
        }
    }
}


extension SuccessActionProcessed: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum SwapStatus {
    
    case `initial`
    case `expired`
}

public struct FfiConverterTypeSwapStatus: FfiConverterRustBuffer {
    typealias SwiftType = SwapStatus

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwapStatus {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`initial`
        
        case 2: return .`expired`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SwapStatus, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`initial`:
            writeInt(&buf, Int32(1))
        
        
        case .`expired`:
            writeInt(&buf, Int32(2))
        
        }
    }
}


extension SwapStatus: Equatable, Hashable {}



public enum SdkError {

    
    
    // Simple error enums only carry a message
    case Error(message: String)
    
}

public struct FfiConverterTypeSdkError: FfiConverterRustBuffer {
    typealias SwiftType = SdkError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SdkError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Error(
            message: try FfiConverterString.read(from: &buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SdkError, into buf: inout [UInt8]) {
        switch value {

        

        
        case let .Error(message):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(message, into: &buf)

        
        }
    }
}


extension SdkError: Equatable, Hashable {}

extension SdkError: Error { }

fileprivate extension NSLock {
    func withLock<T>(f: () throws -> T) rethrows -> T {
        self.lock()
        defer { self.unlock() }
        return try f()
    }
}

fileprivate typealias UniFFICallbackHandle = UInt64
fileprivate class UniFFICallbackHandleMap<T> {
    private var leftMap: [UniFFICallbackHandle: T] = [:]
    private var counter: [UniFFICallbackHandle: UInt64] = [:]
    private var rightMap: [ObjectIdentifier: UniFFICallbackHandle] = [:]

    private let lock = NSLock()
    private var currentHandle: UniFFICallbackHandle = 0
    private let stride: UniFFICallbackHandle = 1

    func insert(obj: T) -> UniFFICallbackHandle {
        lock.withLock {
            let id = ObjectIdentifier(obj as AnyObject)
            let handle = rightMap[id] ?? {
                currentHandle += stride
                let handle = currentHandle
                leftMap[handle] = obj
                rightMap[id] = handle
                return handle
            }()
            counter[handle] = (counter[handle] ?? 0) + 1
            return handle
        }
    }

    func get(handle: UniFFICallbackHandle) -> T? {
        lock.withLock {
            leftMap[handle]
        }
    }

    func delete(handle: UniFFICallbackHandle) {
        remove(handle: handle)
    }

    @discardableResult
    func remove(handle: UniFFICallbackHandle) -> T? {
        lock.withLock {
            defer { counter[handle] = (counter[handle] ?? 1) - 1 }
            guard counter[handle] == 1 else { return leftMap[handle] }
            let obj = leftMap.removeValue(forKey: handle)
            if let obj = obj {
                rightMap.removeValue(forKey: ObjectIdentifier(obj as AnyObject))
            }
            return obj
        }
    }
}

// Magic number for the Rust proxy to call using the same mechanism as every other method,
// to free the callback once it's dropped by Rust.
private let IDX_CALLBACK_FREE: Int32 = 0

// Declaration and FfiConverters for EventListener Callback Interface

public protocol EventListener : AnyObject {
    func `onEvent`(`e`: BreezEvent) 
    
}

// The ForeignCallback that is passed to Rust.
fileprivate let foreignCallbackCallbackInterfaceEventListener : ForeignCallback =
    { (handle: UniFFICallbackHandle, method: Int32, args: RustBuffer, out_buf: UnsafeMutablePointer<RustBuffer>) -> Int32 in
        func `invokeOnEvent`(_ swiftCallbackInterface: EventListener, _ args: RustBuffer) throws -> RustBuffer {
        defer { args.deallocate() }

            var reader = createReader(data: Data(rustBuffer: args))
            swiftCallbackInterface.`onEvent`(
                    `e`:  try FfiConverterTypeBreezEvent.read(from: &reader)
                    )
            return RustBuffer()
                // TODO catch errors and report them back to Rust.
                // https://github.com/mozilla/uniffi-rs/issues/351

        }
        

        let cb: EventListener
        do {
            cb = try FfiConverterCallbackInterfaceEventListener.lift(handle)
        } catch {
            out_buf.pointee = FfiConverterString.lower("EventListener: Invalid handle")
            return -1
        }

        switch method {
            case IDX_CALLBACK_FREE:
                FfiConverterCallbackInterfaceEventListener.drop(handle: handle)
                // No return value.
                // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
                return 0
            case 1:
                do {
                    out_buf.pointee = try `invokeOnEvent`(cb, args)
                    // Value written to out buffer.
                    // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
                    return 1
                } catch let error {
                    out_buf.pointee = FfiConverterString.lower(String(describing: error))
                    return -1
                }
            
            // This should never happen, because an out of bounds method index won't
            // ever be used. Once we can catch errors, we should return an InternalError.
            // https://github.com/mozilla/uniffi-rs/issues/351
            default:
                // An unexpected error happened.
                // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
                return -1
        }
    }

// FfiConverter protocol for callback interfaces
fileprivate struct FfiConverterCallbackInterfaceEventListener {
    // Initialize our callback method with the scaffolding code
    private static var callbackInitialized = false
    private static func initCallback() {
        try! rustCall { (err: UnsafeMutablePointer<RustCallStatus>) in
                ffi_breez_sdk_d64f_EventListener_init_callback(foreignCallbackCallbackInterfaceEventListener, err)
        }
    }
    private static func ensureCallbackinitialized() {
        if !callbackInitialized {
            initCallback()
            callbackInitialized = true
        }
    }

    static func drop(handle: UniFFICallbackHandle) {
        handleMap.remove(handle: handle)
    }

    private static var handleMap = UniFFICallbackHandleMap<EventListener>()
}

extension FfiConverterCallbackInterfaceEventListener : FfiConverter {
    typealias SwiftType = EventListener
    // We can use Handle as the FfiType because it's a typealias to UInt64
    typealias FfiType = UniFFICallbackHandle

    public static func lift(_ handle: UniFFICallbackHandle) throws -> SwiftType {
        ensureCallbackinitialized();
        guard let callback = handleMap.get(handle: handle) else {
            throw UniffiInternalError.unexpectedStaleHandle
        }
        return callback
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        ensureCallbackinitialized();
        let handle: UniFFICallbackHandle = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UniFFICallbackHandle {
        ensureCallbackinitialized();
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        ensureCallbackinitialized();
        writeInt(&buf, lower(v))
    }
}



// Declaration and FfiConverters for LogStream Callback Interface

public protocol LogStream : AnyObject {
    func `log`(`l`: LogEntry) 
    
}

// The ForeignCallback that is passed to Rust.
fileprivate let foreignCallbackCallbackInterfaceLogStream : ForeignCallback =
    { (handle: UniFFICallbackHandle, method: Int32, args: RustBuffer, out_buf: UnsafeMutablePointer<RustBuffer>) -> Int32 in
        func `invokeLog`(_ swiftCallbackInterface: LogStream, _ args: RustBuffer) throws -> RustBuffer {
        defer { args.deallocate() }

            var reader = createReader(data: Data(rustBuffer: args))
            swiftCallbackInterface.`log`(
                    `l`:  try FfiConverterTypeLogEntry.read(from: &reader)
                    )
            return RustBuffer()
                // TODO catch errors and report them back to Rust.
                // https://github.com/mozilla/uniffi-rs/issues/351

        }
        

        let cb: LogStream
        do {
            cb = try FfiConverterCallbackInterfaceLogStream.lift(handle)
        } catch {
            out_buf.pointee = FfiConverterString.lower("LogStream: Invalid handle")
            return -1
        }

        switch method {
            case IDX_CALLBACK_FREE:
                FfiConverterCallbackInterfaceLogStream.drop(handle: handle)
                // No return value.
                // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
                return 0
            case 1:
                do {
                    out_buf.pointee = try `invokeLog`(cb, args)
                    // Value written to out buffer.
                    // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
                    return 1
                } catch let error {
                    out_buf.pointee = FfiConverterString.lower(String(describing: error))
                    return -1
                }
            
            // This should never happen, because an out of bounds method index won't
            // ever be used. Once we can catch errors, we should return an InternalError.
            // https://github.com/mozilla/uniffi-rs/issues/351
            default:
                // An unexpected error happened.
                // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
                return -1
        }
    }

// FfiConverter protocol for callback interfaces
fileprivate struct FfiConverterCallbackInterfaceLogStream {
    // Initialize our callback method with the scaffolding code
    private static var callbackInitialized = false
    private static func initCallback() {
        try! rustCall { (err: UnsafeMutablePointer<RustCallStatus>) in
                ffi_breez_sdk_d64f_LogStream_init_callback(foreignCallbackCallbackInterfaceLogStream, err)
        }
    }
    private static func ensureCallbackinitialized() {
        if !callbackInitialized {
            initCallback()
            callbackInitialized = true
        }
    }

    static func drop(handle: UniFFICallbackHandle) {
        handleMap.remove(handle: handle)
    }

    private static var handleMap = UniFFICallbackHandleMap<LogStream>()
}

extension FfiConverterCallbackInterfaceLogStream : FfiConverter {
    typealias SwiftType = LogStream
    // We can use Handle as the FfiType because it's a typealias to UInt64
    typealias FfiType = UniFFICallbackHandle

    public static func lift(_ handle: UniFFICallbackHandle) throws -> SwiftType {
        ensureCallbackinitialized();
        guard let callback = handleMap.get(handle: handle) else {
            throw UniffiInternalError.unexpectedStaleHandle
        }
        return callback
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        ensureCallbackinitialized();
        let handle: UniFFICallbackHandle = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UniFFICallbackHandle {
        ensureCallbackinitialized();
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        ensureCallbackinitialized();
        writeInt(&buf, lower(v))
    }
}

fileprivate struct FfiConverterOptionUInt32: FfiConverterRustBuffer {
    typealias SwiftType = UInt32?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt32.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt32.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionUInt64: FfiConverterRustBuffer {
    typealias SwiftType = UInt64?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt64.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt64.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionInt64: FfiConverterRustBuffer {
    typealias SwiftType = Int64?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterInt64.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterInt64.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionBool: FfiConverterRustBuffer {
    typealias SwiftType = Bool?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterBool.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterBool.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionString: FfiConverterRustBuffer {
    typealias SwiftType = String?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeLspInformation: FfiConverterRustBuffer {
    typealias SwiftType = LspInformation?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeLspInformation.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeLspInformation.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeNodeState: FfiConverterRustBuffer {
    typealias SwiftType = NodeState?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeNodeState.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeNodeState.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeSwapInfo: FfiConverterRustBuffer {
    typealias SwiftType = SwapInfo?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeSwapInfo.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeSwapInfo.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeSymbol: FfiConverterRustBuffer {
    typealias SwiftType = Symbol?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeSymbol.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeSymbol.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeSuccessActionProcessed: FfiConverterRustBuffer {
    typealias SwiftType = SuccessActionProcessed?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeSuccessActionProcessed.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeSuccessActionProcessed.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionSequenceTypeLocaleOverrides: FfiConverterRustBuffer {
    typealias SwiftType = [LocaleOverrides]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypeLocaleOverrides.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypeLocaleOverrides.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionSequenceTypeLocalizedName: FfiConverterRustBuffer {
    typealias SwiftType = [LocalizedName]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypeLocalizedName.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypeLocalizedName.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterSequenceUInt8: FfiConverterRustBuffer {
    typealias SwiftType = [UInt8]

    public static func write(_ value: [UInt8], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterUInt8.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UInt8] {
        let len: Int32 = try readInt(&buf)
        var seq = [UInt8]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterUInt8.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]

    public static func write(_ value: [String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterString.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String] {
        let len: Int32 = try readInt(&buf)
        var seq = [String]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterString.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeFiatCurrency: FfiConverterRustBuffer {
    typealias SwiftType = [FiatCurrency]

    public static func write(_ value: [FiatCurrency], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeFiatCurrency.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [FiatCurrency] {
        let len: Int32 = try readInt(&buf)
        var seq = [FiatCurrency]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeFiatCurrency.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeLocaleOverrides: FfiConverterRustBuffer {
    typealias SwiftType = [LocaleOverrides]

    public static func write(_ value: [LocaleOverrides], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeLocaleOverrides.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [LocaleOverrides] {
        let len: Int32 = try readInt(&buf)
        var seq = [LocaleOverrides]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeLocaleOverrides.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeLocalizedName: FfiConverterRustBuffer {
    typealias SwiftType = [LocalizedName]

    public static func write(_ value: [LocalizedName], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeLocalizedName.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [LocalizedName] {
        let len: Int32 = try readInt(&buf)
        var seq = [LocalizedName]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeLocalizedName.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeLspInformation: FfiConverterRustBuffer {
    typealias SwiftType = [LspInformation]

    public static func write(_ value: [LspInformation], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeLspInformation.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [LspInformation] {
        let len: Int32 = try readInt(&buf)
        var seq = [LspInformation]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeLspInformation.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypePayment: FfiConverterRustBuffer {
    typealias SwiftType = [Payment]

    public static func write(_ value: [Payment], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePayment.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Payment] {
        let len: Int32 = try readInt(&buf)
        var seq = [Payment]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePayment.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeRate: FfiConverterRustBuffer {
    typealias SwiftType = [Rate]

    public static func write(_ value: [Rate], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeRate.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Rate] {
        let len: Int32 = try readInt(&buf)
        var seq = [Rate]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeRate.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeRouteHint: FfiConverterRustBuffer {
    typealias SwiftType = [RouteHint]

    public static func write(_ value: [RouteHint], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeRouteHint.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [RouteHint] {
        let len: Int32 = try readInt(&buf)
        var seq = [RouteHint]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeRouteHint.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeRouteHintHop: FfiConverterRustBuffer {
    typealias SwiftType = [RouteHintHop]

    public static func write(_ value: [RouteHintHop], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeRouteHintHop.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [RouteHintHop] {
        let len: Int32 = try readInt(&buf)
        var seq = [RouteHintHop]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeRouteHintHop.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeSwapInfo: FfiConverterRustBuffer {
    typealias SwiftType = [SwapInfo]

    public static func write(_ value: [SwapInfo], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeSwapInfo.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [SwapInfo] {
        let len: Int32 = try readInt(&buf)
        var seq = [SwapInfo]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeSwapInfo.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeUnspentTransactionOutput: FfiConverterRustBuffer {
    typealias SwiftType = [UnspentTransactionOutput]

    public static func write(_ value: [UnspentTransactionOutput], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeUnspentTransactionOutput.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UnspentTransactionOutput] {
        let len: Int32 = try readInt(&buf)
        var seq = [UnspentTransactionOutput]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeUnspentTransactionOutput.read(from: &buf))
        }
        return seq
    }
}

public func `registerNode`(`network`: Network, `seed`: [UInt8]) throws -> GreenlightCredentials {
    return try FfiConverterTypeGreenlightCredentials.lift(
        try
    
    rustCallWithError(FfiConverterTypeSdkError.self) {
    
    breez_sdk_d64f_register_node(
        FfiConverterTypeNetwork.lower(`network`), 
        FfiConverterSequenceUInt8.lower(`seed`), $0)
}
    )
}



public func `recoverNode`(`network`: Network, `seed`: [UInt8]) throws -> GreenlightCredentials {
    return try FfiConverterTypeGreenlightCredentials.lift(
        try
    
    rustCallWithError(FfiConverterTypeSdkError.self) {
    
    breez_sdk_d64f_recover_node(
        FfiConverterTypeNetwork.lower(`network`), 
        FfiConverterSequenceUInt8.lower(`seed`), $0)
}
    )
}



public func `initServices`(`config`: Config, `seed`: [UInt8], `creds`: GreenlightCredentials, `listener`: EventListener) throws -> BlockingBreezServices {
    return try FfiConverterTypeBlockingBreezServices.lift(
        try
    
    rustCallWithError(FfiConverterTypeSdkError.self) {
    
    breez_sdk_d64f_init_services(
        FfiConverterTypeConfig.lower(`config`), 
        FfiConverterSequenceUInt8.lower(`seed`), 
        FfiConverterTypeGreenlightCredentials.lower(`creds`), 
        FfiConverterCallbackInterfaceEventListener.lower(`listener`), $0)
}
    )
}



public func `setLogStream`(`logStream`: LogStream) throws {
    try
    
    rustCallWithError(FfiConverterTypeSdkError.self) {
    
    breez_sdk_d64f_set_log_stream(
        FfiConverterCallbackInterfaceLogStream.lower(`logStream`), $0)
}
}


public func `parseInvoice`(`invoice`: String) throws -> LnInvoice {
    return try FfiConverterTypeLnInvoice.lift(
        try
    
    rustCallWithError(FfiConverterTypeSdkError.self) {
    
    breez_sdk_d64f_parse_invoice(
        FfiConverterString.lower(`invoice`), $0)
}
    )
}



public func `parseInput`(`s`: String) throws -> InputType {
    return try FfiConverterTypeInputType.lift(
        try
    
    rustCallWithError(FfiConverterTypeSdkError.self) {
    
    breez_sdk_d64f_parse_input(
        FfiConverterString.lower(`s`), $0)
}
    )
}



public func `mnemonicToSeed`(`phrase`: String) throws -> [UInt8] {
    return try FfiConverterSequenceUInt8.lift(
        try
    
    rustCallWithError(FfiConverterTypeSdkError.self) {
    
    breez_sdk_d64f_mnemonic_to_seed(
        FfiConverterString.lower(`phrase`), $0)
}
    )
}



public func `defaultConfig`(`envType`: EnvironmentType)  -> Config {
    return try! FfiConverterTypeConfig.lift(
        try!
    
    rustCall() {
    
    breez_sdk_d64f_default_config(
        FfiConverterTypeEnvironmentType.lower(`envType`), $0)
}
    )
}



/**
 * Top level initializers and tear down methods.
 *
 * This is generated by uniffi.
 */
public enum BreezSdkLifecycle {
    /**
     * Initialize the FFI and Rust library. This should be only called once per application.
     */
    func initialize() {
    }
}