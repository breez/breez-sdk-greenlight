// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.9.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'binding.dart';
import 'frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
part 'models.freezed.dart';

class BackupStatus {
  final bool backedUp;

  /// Epoch time, in seconds
  final BigInt? lastBackupTime;

  const BackupStatus({required this.backedUp, this.lastBackupTime});

  @override
  int get hashCode => backedUp.hashCode ^ lastBackupTime.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is BackupStatus &&
          runtimeType == other.runtimeType &&
          backedUp == other.backedUp &&
          lastBackupTime == other.lastBackupTime;
}

/// Different providers will demand different behaviours when the user is trying to buy bitcoin.
enum BuyBitcoinProvider { Moonpay }

class BuyBitcoinRequest {
  final BuyBitcoinProvider provider;
  final OpeningFeeParams? openingFeeParams;

  /// The optional URL to redirect to after completing the buy.
  ///
  /// For Moonpay, see <https://dev.moonpay.com/docs/on-ramp-configure-user-journey-params>
  final String? redirectUrl;

  const BuyBitcoinRequest({required this.provider, this.openingFeeParams, this.redirectUrl});

  @override
  int get hashCode => provider.hashCode ^ openingFeeParams.hashCode ^ redirectUrl.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is BuyBitcoinRequest &&
          runtimeType == other.runtimeType &&
          provider == other.provider &&
          openingFeeParams == other.openingFeeParams &&
          redirectUrl == other.redirectUrl;
}

class BuyBitcoinResponse {
  final String url;
  final OpeningFeeParams? openingFeeParams;

  const BuyBitcoinResponse({required this.url, this.openingFeeParams});

  @override
  int get hashCode => url.hashCode ^ openingFeeParams.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is BuyBitcoinResponse &&
          runtimeType == other.runtimeType &&
          url == other.url &&
          openingFeeParams == other.openingFeeParams;
}

/// State of a Lightning channel
enum ChannelState { PendingOpen, Opened, PendingClose, Closed }

/// Represents the funds that were on the user side of the channel at the time it was closed.
class ClosedChannelPaymentDetails {
  final ChannelState state;
  final String fundingTxid;
  final String? shortChannelId;

  /// Can be empty for older closed channels.
  final String? closingTxid;

  const ClosedChannelPaymentDetails({
    required this.state,
    required this.fundingTxid,
    this.shortChannelId,
    this.closingTxid,
  });

  @override
  int get hashCode => state.hashCode ^ fundingTxid.hashCode ^ shortChannelId.hashCode ^ closingTxid.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ClosedChannelPaymentDetails &&
          runtimeType == other.runtimeType &&
          state == other.state &&
          fundingTxid == other.fundingTxid &&
          shortChannelId == other.shortChannelId &&
          closingTxid == other.closingTxid;
}

/// Configuration for the Breez Services
///
/// Use [Config::production] or [Config::staging] for default configs of the different supported
/// environments.
class Config {
  final String breezserver;
  final String chainnotifierUrl;

  /// If set, this is the mempool.space URL that will be used.
  ///
  /// If not set, a list of mempool.space URLs will be used to provide fault-tolerance. If calls
  /// to the first URL fail, then the call will be repeated to the next URL, and so on.
  ///
  /// Note that, if specified, the URL has to be in the format: `https://mempool.space/api`
  final String? mempoolspaceUrl;

  /// Directory in which all SDK files (DB, log) are stored. Defaults to ".", otherwise if it's customized,
  /// the folder should exist before starting the SDK.
  final String workingDir;
  final Network network;
  final int paymentTimeoutSec;
  final String? defaultLspId;
  final String? apiKey;

  /// Maps to the CLN `maxfeepercent` config when paying invoices (`lightning-pay`)
  final double maxfeePercent;

  /// Maps to the CLN `exemptfee` config when paying invoices (`lightning-pay`)
  final BigInt exemptfeeMsat;
  final NodeConfig nodeConfig;

  const Config({
    required this.breezserver,
    required this.chainnotifierUrl,
    this.mempoolspaceUrl,
    required this.workingDir,
    required this.network,
    required this.paymentTimeoutSec,
    this.defaultLspId,
    this.apiKey,
    required this.maxfeePercent,
    required this.exemptfeeMsat,
    required this.nodeConfig,
  });

  @override
  int get hashCode =>
      breezserver.hashCode ^
      chainnotifierUrl.hashCode ^
      mempoolspaceUrl.hashCode ^
      workingDir.hashCode ^
      network.hashCode ^
      paymentTimeoutSec.hashCode ^
      defaultLspId.hashCode ^
      apiKey.hashCode ^
      maxfeePercent.hashCode ^
      exemptfeeMsat.hashCode ^
      nodeConfig.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Config &&
          runtimeType == other.runtimeType &&
          breezserver == other.breezserver &&
          chainnotifierUrl == other.chainnotifierUrl &&
          mempoolspaceUrl == other.mempoolspaceUrl &&
          workingDir == other.workingDir &&
          network == other.network &&
          paymentTimeoutSec == other.paymentTimeoutSec &&
          defaultLspId == other.defaultLspId &&
          apiKey == other.apiKey &&
          maxfeePercent == other.maxfeePercent &&
          exemptfeeMsat == other.exemptfeeMsat &&
          nodeConfig == other.nodeConfig;
}

/// Represents a configure node request.
class ConfigureNodeRequest {
  final String? closeToAddress;

  const ConfigureNodeRequest({this.closeToAddress});

  @override
  int get hashCode => closeToAddress.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ConfigureNodeRequest &&
          runtimeType == other.runtimeType &&
          closeToAddress == other.closeToAddress;
}

/// Represents a connect request.
class ConnectRequest {
  final Config config;
  final Uint8List seed;

  /// If true, only restores an existing node and otherwise result in an error
  final bool? restoreOnly;

  const ConnectRequest({required this.config, required this.seed, this.restoreOnly});

  @override
  int get hashCode => config.hashCode ^ seed.hashCode ^ restoreOnly.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ConnectRequest &&
          runtimeType == other.runtimeType &&
          config == other.config &&
          seed == other.seed &&
          restoreOnly == other.restoreOnly;
}

/// Indicates the different kinds of supported environments for [crate::BreezServices].
enum EnvironmentType { Production, Staging, Regtest }

/// Client-specific credentials to connect to and manage a Greenlight node in the cloud
class GreenlightCredentials {
  final Uint8List developerKey;
  final Uint8List developerCert;

  const GreenlightCredentials({required this.developerKey, required this.developerCert});

  @override
  int get hashCode => developerKey.hashCode ^ developerCert.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is GreenlightCredentials &&
          runtimeType == other.runtimeType &&
          developerKey == other.developerKey &&
          developerCert == other.developerCert;
}

/// Device credentials used to authenticate to Greenlight with the current device.
class GreenlightDeviceCredentials {
  final Uint8List device;

  const GreenlightDeviceCredentials({required this.device});

  @override
  int get hashCode => device.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is GreenlightDeviceCredentials && runtimeType == other.runtimeType && device == other.device;
}

class GreenlightNodeConfig {
  final GreenlightCredentials? partnerCredentials;
  final String? inviteCode;

  const GreenlightNodeConfig({this.partnerCredentials, this.inviteCode});

  @override
  int get hashCode => partnerCredentials.hashCode ^ inviteCode.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is GreenlightNodeConfig &&
          runtimeType == other.runtimeType &&
          partnerCredentials == other.partnerCredentials &&
          inviteCode == other.inviteCode;
}

/// Indicates the different service health check statuses.
enum HealthCheckStatus { Operational, Maintenance, ServiceDisruption }

/// An enum representing the available verbosity level filters of the logger.
enum LevelFilter {
  ///
  /// A level lower than all log levels.
  Off,

  /// The "error" level.
  ///
  /// Designates very serious errors.
  Error,

  /// The "warn" level.
  ///
  /// Designates hazardous situations.
  Warn,

  /// The "info" level.
  ///
  /// Designates useful information.
  Info,

  /// The "debug" level.
  ///
  /// Designates lower priority information.
  Debug,

  /// The "trace" level.
  ///
  /// Designates very low priority, often extremely verbose, information.
  Trace,
}

/// Represents a list payments request.
class ListPaymentsRequest {
  final List<PaymentTypeFilter>? filters;
  final List<MetadataFilter>? metadataFilters;

  /// Epoch time, in seconds
  final PlatformInt64? fromTimestamp;

  /// Epoch time, in seconds
  final PlatformInt64? toTimestamp;
  final bool? includeFailures;
  final int? offset;
  final int? limit;

  const ListPaymentsRequest({
    this.filters,
    this.metadataFilters,
    this.fromTimestamp,
    this.toTimestamp,
    this.includeFailures,
    this.offset,
    this.limit,
  });

  @override
  int get hashCode =>
      filters.hashCode ^
      metadataFilters.hashCode ^
      fromTimestamp.hashCode ^
      toTimestamp.hashCode ^
      includeFailures.hashCode ^
      offset.hashCode ^
      limit.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ListPaymentsRequest &&
          runtimeType == other.runtimeType &&
          filters == other.filters &&
          metadataFilters == other.metadataFilters &&
          fromTimestamp == other.fromTimestamp &&
          toTimestamp == other.toTimestamp &&
          includeFailures == other.includeFailures &&
          offset == other.offset &&
          limit == other.limit;
}

class ListSwapsRequest {
  final List<SwapStatus>? status;

  /// Epoch time, in seconds. If set, acts as filter for minimum swap creation time, inclusive.
  final PlatformInt64? fromTimestamp;

  /// Epoch time, in seconds. If set, acts as filter for maximum swap creation time, exclusive.
  final PlatformInt64? toTimestamp;
  final int? offset;
  final int? limit;

  const ListSwapsRequest({this.status, this.fromTimestamp, this.toTimestamp, this.offset, this.limit});

  @override
  int get hashCode =>
      status.hashCode ^ fromTimestamp.hashCode ^ toTimestamp.hashCode ^ offset.hashCode ^ limit.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ListSwapsRequest &&
          runtimeType == other.runtimeType &&
          status == other.status &&
          fromTimestamp == other.fromTimestamp &&
          toTimestamp == other.toTimestamp &&
          offset == other.offset &&
          limit == other.limit;
}

/// Details of a LN payment, as included in a [Payment]
class LnPaymentDetails {
  final String paymentHash;
  final String label;
  final String destinationPubkey;
  final String paymentPreimage;
  final bool keysend;
  final String bolt11;

  /// Only set for [PaymentType::Received], payments which require to open a channel.
  /// Represents the actual invoice paid by the sender
  final String? openChannelBolt11;

  /// Only set for [PaymentType::Sent] payments that are part of a LNURL-pay workflow where
  /// the endpoint returns a success action
  final SuccessActionProcessed? lnurlSuccessAction;

  /// Only set for [PaymentType::Sent] payments if it is not a payment to a Lightning Address
  final String? lnurlPayDomain;

  /// Only set for [PaymentType::Sent] payments if the user sent the comment using LNURL-pay
  final String? lnurlPayComment;

  /// Only set for [PaymentType::Sent] payments that are sent to a Lightning Address
  final String? lnAddress;

  /// Only set for [PaymentType::Sent] payments where the receiver endpoint returned LNURL metadata
  final String? lnurlMetadata;

  /// Only set for [PaymentType::Received] payments that were received as part of LNURL-withdraw
  final String? lnurlWithdrawEndpoint;

  /// Only set for [PaymentType::Received] payments that were received in the context of a swap
  final SwapInfo? swapInfo;

  /// Only set for [PaymentType::Sent] payments that were sent in the context of a reverse swap
  final ReverseSwapInfo? reverseSwapInfo;

  /// Only set for [PaymentStatus::Pending] payments that are inflight.
  final int? pendingExpirationBlock;

  const LnPaymentDetails({
    required this.paymentHash,
    required this.label,
    required this.destinationPubkey,
    required this.paymentPreimage,
    required this.keysend,
    required this.bolt11,
    this.openChannelBolt11,
    this.lnurlSuccessAction,
    this.lnurlPayDomain,
    this.lnurlPayComment,
    this.lnAddress,
    this.lnurlMetadata,
    this.lnurlWithdrawEndpoint,
    this.swapInfo,
    this.reverseSwapInfo,
    this.pendingExpirationBlock,
  });

  @override
  int get hashCode =>
      paymentHash.hashCode ^
      label.hashCode ^
      destinationPubkey.hashCode ^
      paymentPreimage.hashCode ^
      keysend.hashCode ^
      bolt11.hashCode ^
      openChannelBolt11.hashCode ^
      lnurlSuccessAction.hashCode ^
      lnurlPayDomain.hashCode ^
      lnurlPayComment.hashCode ^
      lnAddress.hashCode ^
      lnurlMetadata.hashCode ^
      lnurlWithdrawEndpoint.hashCode ^
      swapInfo.hashCode ^
      reverseSwapInfo.hashCode ^
      pendingExpirationBlock.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is LnPaymentDetails &&
          runtimeType == other.runtimeType &&
          paymentHash == other.paymentHash &&
          label == other.label &&
          destinationPubkey == other.destinationPubkey &&
          paymentPreimage == other.paymentPreimage &&
          keysend == other.keysend &&
          bolt11 == other.bolt11 &&
          openChannelBolt11 == other.openChannelBolt11 &&
          lnurlSuccessAction == other.lnurlSuccessAction &&
          lnurlPayDomain == other.lnurlPayDomain &&
          lnurlPayComment == other.lnurlPayComment &&
          lnAddress == other.lnAddress &&
          lnurlMetadata == other.lnurlMetadata &&
          lnurlWithdrawEndpoint == other.lnurlWithdrawEndpoint &&
          swapInfo == other.swapInfo &&
          reverseSwapInfo == other.reverseSwapInfo &&
          pendingExpirationBlock == other.pendingExpirationBlock;
}

/// Internal SDK log entry
class LogEntry {
  final String line;
  final String level;

  const LogEntry({required this.line, required this.level});

  @override
  int get hashCode => line.hashCode ^ level.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is LogEntry && runtimeType == other.runtimeType && line == other.line && level == other.level;
}

/// A metadata filter which can be applied when retrieving the transaction list
class MetadataFilter {
  /// Specifies which field to apply the filter on, using the JSON path format
  final String jsonPath;

  /// Specifies which JSON value to filter for.
  /// As such, strings must be wrapped with quotes ("") in order to be properly filtered
  final String jsonValue;

  const MetadataFilter({required this.jsonPath, required this.jsonValue});

  @override
  int get hashCode => jsonPath.hashCode ^ jsonValue.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is MetadataFilter &&
          runtimeType == other.runtimeType &&
          jsonPath == other.jsonPath &&
          jsonValue == other.jsonValue;
}

@freezed
sealed class NodeConfig with _$NodeConfig {
  const NodeConfig._();

  const factory NodeConfig.greenlight({required GreenlightNodeConfig config}) = NodeConfig_Greenlight;
}

@freezed
sealed class NodeCredentials with _$NodeCredentials {
  const NodeCredentials._();

  const factory NodeCredentials.greenlight({required GreenlightDeviceCredentials credentials}) =
      NodeCredentials_Greenlight;
}

/// The node state of a Greenlight LN node running in the cloud.
///
/// Note: The implementation attempts to provide the most up-to-date values,
/// which may result in some short-lived inconsistencies
/// (e.g., `channels_balance_msat` may be updated before `inbound_liquidity_msats`).
class NodeState {
  final String id;
  final int blockHeight;
  final BigInt channelsBalanceMsat;
  final BigInt onchainBalanceMsat;
  final BigInt pendingOnchainBalanceMsat;
  final List<UnspentTransactionOutput> utxos;
  final BigInt maxPayableMsat;
  final BigInt maxReceivableMsat;
  final BigInt maxSinglePaymentAmountMsat;
  final BigInt maxChanReserveMsats;
  final List<String> connectedPeers;

  /// Maximum receivable in a single payment without requiring a new channel open.
  final BigInt maxReceivableSinglePaymentAmountMsat;

  /// Total receivable on all available channels
  final BigInt totalInboundLiquidityMsats;

  const NodeState({
    required this.id,
    required this.blockHeight,
    required this.channelsBalanceMsat,
    required this.onchainBalanceMsat,
    required this.pendingOnchainBalanceMsat,
    required this.utxos,
    required this.maxPayableMsat,
    required this.maxReceivableMsat,
    required this.maxSinglePaymentAmountMsat,
    required this.maxChanReserveMsats,
    required this.connectedPeers,
    required this.maxReceivableSinglePaymentAmountMsat,
    required this.totalInboundLiquidityMsats,
  });

  @override
  int get hashCode =>
      id.hashCode ^
      blockHeight.hashCode ^
      channelsBalanceMsat.hashCode ^
      onchainBalanceMsat.hashCode ^
      pendingOnchainBalanceMsat.hashCode ^
      utxos.hashCode ^
      maxPayableMsat.hashCode ^
      maxReceivableMsat.hashCode ^
      maxSinglePaymentAmountMsat.hashCode ^
      maxChanReserveMsats.hashCode ^
      connectedPeers.hashCode ^
      maxReceivableSinglePaymentAmountMsat.hashCode ^
      totalInboundLiquidityMsats.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is NodeState &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          blockHeight == other.blockHeight &&
          channelsBalanceMsat == other.channelsBalanceMsat &&
          onchainBalanceMsat == other.onchainBalanceMsat &&
          pendingOnchainBalanceMsat == other.pendingOnchainBalanceMsat &&
          utxos == other.utxos &&
          maxPayableMsat == other.maxPayableMsat &&
          maxReceivableMsat == other.maxReceivableMsat &&
          maxSinglePaymentAmountMsat == other.maxSinglePaymentAmountMsat &&
          maxChanReserveMsats == other.maxChanReserveMsats &&
          connectedPeers == other.connectedPeers &&
          maxReceivableSinglePaymentAmountMsat == other.maxReceivableSinglePaymentAmountMsat &&
          totalInboundLiquidityMsats == other.totalInboundLiquidityMsats;
}

class OnchainPaymentLimitsResponse {
  /// Minimum amount the reverse swap service accepts as a send amount
  final BigInt minSat;

  /// Maximum amount the reverse swap service accepts as a send amount
  final BigInt maxSat;

  /// Maximum amount this node can send with the current channels and the current local balance
  final BigInt maxPayableSat;

  const OnchainPaymentLimitsResponse({
    required this.minSat,
    required this.maxSat,
    required this.maxPayableSat,
  });

  @override
  int get hashCode => minSat.hashCode ^ maxSat.hashCode ^ maxPayableSat.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is OnchainPaymentLimitsResponse &&
          runtimeType == other.runtimeType &&
          minSat == other.minSat &&
          maxSat == other.maxSat &&
          maxPayableSat == other.maxPayableSat;
}

class OpenChannelFeeRequest {
  final BigInt? amountMsat;
  final int? expiry;

  const OpenChannelFeeRequest({this.amountMsat, this.expiry});

  @override
  int get hashCode => amountMsat.hashCode ^ expiry.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is OpenChannelFeeRequest &&
          runtimeType == other.runtimeType &&
          amountMsat == other.amountMsat &&
          expiry == other.expiry;
}

class OpenChannelFeeResponse {
  /// Opening fee for receiving the amount set in the [OpenChannelFeeRequest], in case it was set.
  /// It may be zero if no new channel needs to be opened.
  final BigInt? feeMsat;

  /// The fee params for receiving more than the current inbound liquidity.
  final OpeningFeeParams feeParams;

  const OpenChannelFeeResponse({this.feeMsat, required this.feeParams});

  @override
  int get hashCode => feeMsat.hashCode ^ feeParams.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is OpenChannelFeeResponse &&
          runtimeType == other.runtimeType &&
          feeMsat == other.feeMsat &&
          feeParams == other.feeParams;
}

/// Dynamic fee parameters offered by the LSP for opening a new channel.
///
/// After they are received, the client shouldn't change them when calling LSP methods,
/// otherwise the LSP may reject the call.
class OpeningFeeParams {
  /// The minimum value in millisatoshi we will require for incoming HTLCs on the channel
  final BigInt minMsat;

  /// The fee in ppm charged over liquidity when buying a channel
  final int proportional;

  /// The date and time this opening fee params promise expires, in RFC 3339 / ISO 8601 format
  final String validUntil;

  /// The channel can be closed if not used within this duration in blocks
  final int maxIdleTime;
  final int maxClientToSelfDelay;
  final String promise;

  const OpeningFeeParams({
    required this.minMsat,
    required this.proportional,
    required this.validUntil,
    required this.maxIdleTime,
    required this.maxClientToSelfDelay,
    required this.promise,
  });

  @override
  int get hashCode =>
      minMsat.hashCode ^
      proportional.hashCode ^
      validUntil.hashCode ^
      maxIdleTime.hashCode ^
      maxClientToSelfDelay.hashCode ^
      promise.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is OpeningFeeParams &&
          runtimeType == other.runtimeType &&
          minMsat == other.minMsat &&
          proportional == other.proportional &&
          validUntil == other.validUntil &&
          maxIdleTime == other.maxIdleTime &&
          maxClientToSelfDelay == other.maxClientToSelfDelay &&
          promise == other.promise;
}

/// See [OpeningFeeParamsMenu::try_from]
class OpeningFeeParamsMenu {
  final List<OpeningFeeParams> values;

  const OpeningFeeParamsMenu({required this.values});

  @override
  int get hashCode => values.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is OpeningFeeParamsMenu && runtimeType == other.runtimeType && values == other.values;
}

class PayOnchainRequest {
  final String recipientAddress;
  final PrepareOnchainPaymentResponse prepareRes;

  const PayOnchainRequest({required this.recipientAddress, required this.prepareRes});

  @override
  int get hashCode => recipientAddress.hashCode ^ prepareRes.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PayOnchainRequest &&
          runtimeType == other.runtimeType &&
          recipientAddress == other.recipientAddress &&
          prepareRes == other.prepareRes;
}

class PayOnchainResponse {
  final ReverseSwapInfo reverseSwapInfo;

  const PayOnchainResponse({required this.reverseSwapInfo});

  @override
  int get hashCode => reverseSwapInfo.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PayOnchainResponse &&
          runtimeType == other.runtimeType &&
          reverseSwapInfo == other.reverseSwapInfo;
}

/// Represents a payment, including its [PaymentType] and [PaymentDetails]
class Payment {
  final String id;
  final PaymentType paymentType;

  /// Epoch time, in seconds
  final PlatformInt64 paymentTime;
  final BigInt amountMsat;
  final BigInt feeMsat;
  final PaymentStatus status;
  final String? error;
  final String? description;
  final PaymentDetails details;
  final String? metadata;

  const Payment({
    required this.id,
    required this.paymentType,
    required this.paymentTime,
    required this.amountMsat,
    required this.feeMsat,
    required this.status,
    this.error,
    this.description,
    required this.details,
    this.metadata,
  });

  @override
  int get hashCode =>
      id.hashCode ^
      paymentType.hashCode ^
      paymentTime.hashCode ^
      amountMsat.hashCode ^
      feeMsat.hashCode ^
      status.hashCode ^
      error.hashCode ^
      description.hashCode ^
      details.hashCode ^
      metadata.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Payment &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          paymentType == other.paymentType &&
          paymentTime == other.paymentTime &&
          amountMsat == other.amountMsat &&
          feeMsat == other.feeMsat &&
          status == other.status &&
          error == other.error &&
          description == other.description &&
          details == other.details &&
          metadata == other.metadata;
}

@freezed
sealed class PaymentDetails with _$PaymentDetails {
  const PaymentDetails._();

  const factory PaymentDetails.ln({required LnPaymentDetails data}) = PaymentDetails_Ln;
  const factory PaymentDetails.closedChannel({required ClosedChannelPaymentDetails data}) =
      PaymentDetails_ClosedChannel;
}

/// The status of a payment
enum PaymentStatus { Pending, Complete, Failed }

/// Different types of supported payments
enum PaymentType { Sent, Received, ClosedChannel }

/// Different types of supported filters which can be applied when retrieving the transaction list
enum PaymentTypeFilter { Sent, Received, ClosedChannel }

/// See [ReverseSwapFeesRequest]
class PrepareOnchainPaymentRequest {
  /// Depending on `amount_type`, this may be the desired send amount or the desired receive amount.
  final BigInt amountSat;
  final SwapAmountType amountType;

  /// Feerate (sat / vByte) for the claim transaction
  final int claimTxFeerate;

  const PrepareOnchainPaymentRequest({
    required this.amountSat,
    required this.amountType,
    required this.claimTxFeerate,
  });

  @override
  int get hashCode => amountSat.hashCode ^ amountType.hashCode ^ claimTxFeerate.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PrepareOnchainPaymentRequest &&
          runtimeType == other.runtimeType &&
          amountSat == other.amountSat &&
          amountType == other.amountType &&
          claimTxFeerate == other.claimTxFeerate;
}

/// Contains fields describing the reverse swap parameters (see [ReverseSwapPairInfo]), as well as
/// the resulting send and receive amounts.
class PrepareOnchainPaymentResponse {
  final String feesHash;
  final double feesPercentage;
  final BigInt feesLockup;
  final BigInt feesClaim;
  final BigInt senderAmountSat;
  final BigInt recipientAmountSat;
  final BigInt totalFees;

  const PrepareOnchainPaymentResponse({
    required this.feesHash,
    required this.feesPercentage,
    required this.feesLockup,
    required this.feesClaim,
    required this.senderAmountSat,
    required this.recipientAmountSat,
    required this.totalFees,
  });

  @override
  int get hashCode =>
      feesHash.hashCode ^
      feesPercentage.hashCode ^
      feesLockup.hashCode ^
      feesClaim.hashCode ^
      senderAmountSat.hashCode ^
      recipientAmountSat.hashCode ^
      totalFees.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PrepareOnchainPaymentResponse &&
          runtimeType == other.runtimeType &&
          feesHash == other.feesHash &&
          feesPercentage == other.feesPercentage &&
          feesLockup == other.feesLockup &&
          feesClaim == other.feesClaim &&
          senderAmountSat == other.senderAmountSat &&
          recipientAmountSat == other.recipientAmountSat &&
          totalFees == other.totalFees;
}

/// We need to prepare a redeem_onchain_funds transaction to know what fee will be charged in satoshis.
/// This model holds the request data which consists of the address to redeem on-chain funds to and the fee rate in.
/// satoshis per vbyte which will be converted to absolute satoshis.
class PrepareRedeemOnchainFundsRequest {
  final String toAddress;
  final int satPerVbyte;

  const PrepareRedeemOnchainFundsRequest({required this.toAddress, required this.satPerVbyte});

  @override
  int get hashCode => toAddress.hashCode ^ satPerVbyte.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PrepareRedeemOnchainFundsRequest &&
          runtimeType == other.runtimeType &&
          toAddress == other.toAddress &&
          satPerVbyte == other.satPerVbyte;
}

/// We need to prepare a redeem_onchain_funds transaction to know what a fee it will be charged in satoshis
/// this model holds the response data, which consists of the weight and the absolute fee in sats
class PrepareRedeemOnchainFundsResponse {
  final BigInt txWeight;
  final BigInt txFeeSat;

  const PrepareRedeemOnchainFundsResponse({required this.txWeight, required this.txFeeSat});

  @override
  int get hashCode => txWeight.hashCode ^ txFeeSat.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PrepareRedeemOnchainFundsResponse &&
          runtimeType == other.runtimeType &&
          txWeight == other.txWeight &&
          txFeeSat == other.txFeeSat;
}

class PrepareRefundRequest {
  final String swapAddress;
  final String toAddress;
  final int satPerVbyte;
  final bool? unilateral;

  const PrepareRefundRequest({
    required this.swapAddress,
    required this.toAddress,
    required this.satPerVbyte,
    this.unilateral,
  });

  @override
  int get hashCode => swapAddress.hashCode ^ toAddress.hashCode ^ satPerVbyte.hashCode ^ unilateral.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PrepareRefundRequest &&
          runtimeType == other.runtimeType &&
          swapAddress == other.swapAddress &&
          toAddress == other.toAddress &&
          satPerVbyte == other.satPerVbyte &&
          unilateral == other.unilateral;
}

class PrepareRefundResponse {
  final int refundTxWeight;
  final BigInt refundTxFeeSat;

  const PrepareRefundResponse({required this.refundTxWeight, required this.refundTxFeeSat});

  @override
  int get hashCode => refundTxWeight.hashCode ^ refundTxFeeSat.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PrepareRefundResponse &&
          runtimeType == other.runtimeType &&
          refundTxWeight == other.refundTxWeight &&
          refundTxFeeSat == other.refundTxFeeSat;
}

class ReceiveOnchainRequest {
  final OpeningFeeParams? openingFeeParams;

  const ReceiveOnchainRequest({this.openingFeeParams});

  @override
  int get hashCode => openingFeeParams.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ReceiveOnchainRequest &&
          runtimeType == other.runtimeType &&
          openingFeeParams == other.openingFeeParams;
}

/// Represents a receive payment request.
class ReceivePaymentRequest {
  /// The amount in satoshis for this payment request
  final BigInt amountMsat;

  /// The description for this payment request.
  final String description;

  /// Optional preimage for this payment request.
  /// If specified, it will be used instead of generating a new one.
  final Uint8List? preimage;

  /// If set and valid, these fess options are used when a new channels is needed.
  /// Otherwise the default fee options will be used.
  final OpeningFeeParams? openingFeeParams;

  /// If set to true, then the bolt11 invoice returned includes the description hash.
  final bool? useDescriptionHash;

  /// if specified, set the time the invoice is valid for, in seconds.
  final int? expiry;

  /// if specified, sets the min_final_cltv_expiry for the invoice
  final int? cltv;

  const ReceivePaymentRequest({
    required this.amountMsat,
    required this.description,
    this.preimage,
    this.openingFeeParams,
    this.useDescriptionHash,
    this.expiry,
    this.cltv,
  });

  @override
  int get hashCode =>
      amountMsat.hashCode ^
      description.hashCode ^
      preimage.hashCode ^
      openingFeeParams.hashCode ^
      useDescriptionHash.hashCode ^
      expiry.hashCode ^
      cltv.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ReceivePaymentRequest &&
          runtimeType == other.runtimeType &&
          amountMsat == other.amountMsat &&
          description == other.description &&
          preimage == other.preimage &&
          openingFeeParams == other.openingFeeParams &&
          useDescriptionHash == other.useDescriptionHash &&
          expiry == other.expiry &&
          cltv == other.cltv;
}

/// Represents a receive payment response.
///
/// Breez SDK may have to open a new channel to receive this payment. In that case, the channel will
/// be opened automatically when the invoice is paid, and the fees will be described in the
/// `opening_fee_params` and `opening_fee_msat` fields.
class ReceivePaymentResponse {
  /// The generated invoice, including any necessary routing hints
  final LNInvoice lnInvoice;

  /// If set, these are the [OpeningFeeParams] used to calculate the channel opening fees.
  final OpeningFeeParams? openingFeeParams;

  /// If set, this is the channel opening fee that will be deduced from the invoice amount.
  final BigInt? openingFeeMsat;

  const ReceivePaymentResponse({required this.lnInvoice, this.openingFeeParams, this.openingFeeMsat});

  @override
  int get hashCode => lnInvoice.hashCode ^ openingFeeParams.hashCode ^ openingFeeMsat.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ReceivePaymentResponse &&
          runtimeType == other.runtimeType &&
          lnInvoice == other.lnInvoice &&
          openingFeeParams == other.openingFeeParams &&
          openingFeeMsat == other.openingFeeMsat;
}

class RedeemOnchainFundsRequest {
  final String toAddress;
  final int satPerVbyte;

  const RedeemOnchainFundsRequest({required this.toAddress, required this.satPerVbyte});

  @override
  int get hashCode => toAddress.hashCode ^ satPerVbyte.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is RedeemOnchainFundsRequest &&
          runtimeType == other.runtimeType &&
          toAddress == other.toAddress &&
          satPerVbyte == other.satPerVbyte;
}

class RedeemOnchainFundsResponse {
  final Uint8List txid;

  const RedeemOnchainFundsResponse({required this.txid});

  @override
  int get hashCode => txid.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is RedeemOnchainFundsResponse && runtimeType == other.runtimeType && txid == other.txid;
}

class RefundRequest {
  final String swapAddress;
  final String toAddress;
  final int satPerVbyte;
  final bool? unilateral;

  const RefundRequest({
    required this.swapAddress,
    required this.toAddress,
    required this.satPerVbyte,
    this.unilateral,
  });

  @override
  int get hashCode => swapAddress.hashCode ^ toAddress.hashCode ^ satPerVbyte.hashCode ^ unilateral.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is RefundRequest &&
          runtimeType == other.runtimeType &&
          swapAddress == other.swapAddress &&
          toAddress == other.toAddress &&
          satPerVbyte == other.satPerVbyte &&
          unilateral == other.unilateral;
}

class RefundResponse {
  final String refundTxId;

  const RefundResponse({required this.refundTxId});

  @override
  int get hashCode => refundTxId.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is RefundResponse && runtimeType == other.runtimeType && refundTxId == other.refundTxId;
}

@freezed
sealed class ReportIssueRequest with _$ReportIssueRequest {
  const ReportIssueRequest._();

  const factory ReportIssueRequest.paymentFailure({required ReportPaymentFailureDetails data}) =
      ReportIssueRequest_PaymentFailure;
}

class ReportPaymentFailureDetails {
  /// The payment hash of the payment failure
  final String paymentHash;

  /// The comment or error text
  final String? comment;

  const ReportPaymentFailureDetails({required this.paymentHash, this.comment});

  @override
  int get hashCode => paymentHash.hashCode ^ comment.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ReportPaymentFailureDetails &&
          runtimeType == other.runtimeType &&
          paymentHash == other.paymentHash &&
          comment == other.comment;
}

class ReverseSwapFeesRequest {
  /// Amount to be sent
  final BigInt? sendAmountSat;

  /// Feerate (sat / vByte) for the claim transaction
  final int? claimTxFeerate;

  const ReverseSwapFeesRequest({this.sendAmountSat, this.claimTxFeerate});

  @override
  int get hashCode => sendAmountSat.hashCode ^ claimTxFeerate.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ReverseSwapFeesRequest &&
          runtimeType == other.runtimeType &&
          sendAmountSat == other.sendAmountSat &&
          claimTxFeerate == other.claimTxFeerate;
}

/// Simplified version of [FullReverseSwapInfo], containing only the user-relevant fields
class ReverseSwapInfo {
  final String id;
  final String claimPubkey;

  /// The lockup tx id, available from the moment the lockup tx is seen in the mempool by the SDK
  final String? lockupTxid;

  /// The claim tx id, available from the moment the claim tx is broadcast by the SDK
  final String? claimTxid;
  final BigInt onchainAmountSat;
  final ReverseSwapStatus status;

  const ReverseSwapInfo({
    required this.id,
    required this.claimPubkey,
    this.lockupTxid,
    this.claimTxid,
    required this.onchainAmountSat,
    required this.status,
  });

  @override
  int get hashCode =>
      id.hashCode ^
      claimPubkey.hashCode ^
      lockupTxid.hashCode ^
      claimTxid.hashCode ^
      onchainAmountSat.hashCode ^
      status.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ReverseSwapInfo &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          claimPubkey == other.claimPubkey &&
          lockupTxid == other.lockupTxid &&
          claimTxid == other.claimTxid &&
          onchainAmountSat == other.onchainAmountSat &&
          status == other.status;
}

/// Details about the reverse swap fees and parameters, at this point in time
class ReverseSwapPairInfo {
  /// Minimum amount of sats a reverse swap is allowed to have given the current feerate conditions
  final BigInt min;

  /// Maximum amount of sats a reverse swap is allowed to have given the current feerate conditions
  final BigInt max;

  /// Hash of the pair info JSON
  final String feesHash;

  /// Percentage fee for the reverse swap service
  final double feesPercentage;

  /// Miner fees in sats for locking up funds
  final BigInt feesLockup;

  /// Miner fees in sats for claiming funds. Estimate or exact value, depending on the request args.
  final BigInt feesClaim;

  /// Total fees for the reverse swap, in sats, based on the given send amount.
  ///
  /// The field is set only when the [ReverseSwapFeesRequest] `send_amount_sat` is known.
  ///
  /// If the [ReverseSwapFeesRequest] has the `claim_tx_feerate` empty, this is an estimate. If
  /// the `claim_tx_feerate` is set, this is the exact value of the total reverse swap fees.
  final BigInt? totalFees;

  const ReverseSwapPairInfo({
    required this.min,
    required this.max,
    required this.feesHash,
    required this.feesPercentage,
    required this.feesLockup,
    required this.feesClaim,
    this.totalFees,
  });

  @override
  int get hashCode =>
      min.hashCode ^
      max.hashCode ^
      feesHash.hashCode ^
      feesPercentage.hashCode ^
      feesLockup.hashCode ^
      feesClaim.hashCode ^
      totalFees.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ReverseSwapPairInfo &&
          runtimeType == other.runtimeType &&
          min == other.min &&
          max == other.max &&
          feesHash == other.feesHash &&
          feesPercentage == other.feesPercentage &&
          feesLockup == other.feesLockup &&
          feesClaim == other.feesClaim &&
          totalFees == other.totalFees;
}

/// The possible statuses of a reverse swap, from the Breez SDK perspective.
///
/// See [BoltzApiReverseSwapStatus] for the reverse swap status from the Breez endpoint point of view.
enum ReverseSwapStatus {
  /// HODL invoice payment is not completed yet
  ///
  /// This is also the temporary status of a reverse swap when restoring a node, until `sync` finishes.
  Initial,

  /// HODL invoice payment was successfully triggered and confirmed by Boltz, but the reverse swap
  /// is not yet complete
  InProgress,

  /// An explicit error occurs (validation error, failure reported by Boltz, expiration, etc) and
  /// the initial invoice funds are returned to the sender (invoice is cancelled or payment failed)
  Cancelled,

  /// Successfully completed (claim tx has been seen in the mempool)
  CompletedSeen,

  /// Successfully completed (claim tx has at least one confirmation)
  CompletedConfirmed,
}

/// Represents a send payment request.
class SendPaymentRequest {
  /// The bolt11 invoice
  final String bolt11;

  /// Trampoline payments outsource pathfinding to the LSP. Trampoline payments can improve
  /// payment performance, but are generally more expensive in terms of fees and they
  /// compromise on privacy.
  final bool useTrampoline;

  /// The amount to pay in millisatoshis. Should only be set when `bolt11` is a zero-amount invoice.
  final BigInt? amountMsat;

  /// The external label or identifier of the [Payment]
  final String? label;

  const SendPaymentRequest({required this.bolt11, required this.useTrampoline, this.amountMsat, this.label});

  @override
  int get hashCode => bolt11.hashCode ^ useTrampoline.hashCode ^ amountMsat.hashCode ^ label.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SendPaymentRequest &&
          runtimeType == other.runtimeType &&
          bolt11 == other.bolt11 &&
          useTrampoline == other.useTrampoline &&
          amountMsat == other.amountMsat &&
          label == other.label;
}

/// Represents a send payment response.
class SendPaymentResponse {
  final Payment payment;

  const SendPaymentResponse({required this.payment});

  @override
  int get hashCode => payment.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SendPaymentResponse && runtimeType == other.runtimeType && payment == other.payment;
}

/// Represents a send spontaneous payment request.
class SendSpontaneousPaymentRequest {
  /// The node id to send this payment is
  final String nodeId;

  /// The amount in millisatoshis for this payment
  final BigInt amountMsat;
  final List<TlvEntry>? extraTlvs;

  /// The external label or identifier of the [Payment]
  final String? label;

  const SendSpontaneousPaymentRequest({
    required this.nodeId,
    required this.amountMsat,
    this.extraTlvs,
    this.label,
  });

  @override
  int get hashCode => nodeId.hashCode ^ amountMsat.hashCode ^ extraTlvs.hashCode ^ label.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SendSpontaneousPaymentRequest &&
          runtimeType == other.runtimeType &&
          nodeId == other.nodeId &&
          amountMsat == other.amountMsat &&
          extraTlvs == other.extraTlvs &&
          label == other.label;
}

/// Represents a service health check response.
class ServiceHealthCheckResponse {
  final HealthCheckStatus status;

  const ServiceHealthCheckResponse({required this.status});

  @override
  int get hashCode => status.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ServiceHealthCheckResponse && runtimeType == other.runtimeType && status == other.status;
}

class StaticBackupRequest {
  final String workingDir;

  const StaticBackupRequest({required this.workingDir});

  @override
  int get hashCode => workingDir.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is StaticBackupRequest && runtimeType == other.runtimeType && workingDir == other.workingDir;
}

class StaticBackupResponse {
  final List<String>? backup;

  const StaticBackupResponse({this.backup});

  @override
  int get hashCode => backup.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is StaticBackupResponse && runtimeType == other.runtimeType && backup == other.backup;
}

enum SwapAmountType { Send, Receive }

/// Represents the details of an on-going swap.
///
/// Once this SwapInfo is created it will be monitored on-chain and its state is
/// saved to the persistent storage.
///
/// The SwapInfo has a status which changes accordingly, documented in [SwapStatus].
///
class SwapInfo {
  /// Bitcoin address for this swap. Sats sent to this address will be swapped.
  final String bitcoinAddress;

  /// Relative time lock start, received from [SwapperAPI::create_swap].
  final PlatformInt64 createdAt;

  /// Relative time lock for the timeout for the script to be redeemed before swap fails.
  final PlatformInt64 lockHeight;

  /// sha256 hash of preimage to used in the claim sript.
  final Uint8List paymentHash;

  /// Secret to claim the swap.
  final Uint8List preimage;

  /// Secret claim key for the bitcoin address.
  final Uint8List privateKey;

  /// Public key in binary format of the private claim private key.
  final Uint8List publicKey;

  /// The public key in binary format from the swapping service. Received from [SwapperAPI::create_swap].
  final Uint8List swapperPublicKey;

  /// The locking script for the generated bitcoin address. Received from [SwapperAPI::create_swap].
  final Uint8List script;

  /// bolt11 invoice to claim the sent funds.
  final String? bolt11;

  /// Amount of millisatoshis claimed from sent funds and paid for via bolt11 invoice.
  final BigInt paidMsat;

  /// Total count of transactions sent to the swap address.
  final BigInt totalIncomingTxs;

  /// Confirmed onchain sats to be claim with an bolt11 invoice or refunded if swap fails.
  final BigInt confirmedSats;

  /// Unconfirmed sats waiting to be confirmed onchain.
  final BigInt unconfirmedSats;

  /// Shows the current status of the swap, either `Initial` or `Expired`.
  final SwapStatus status;

  /// Transaction IDs for failed swap attempts.
  final List<String> refundTxIds;

  /// Refund transaction IDs for ongoing swap awaiting confirmation.
  final List<String> unconfirmedTxIds;

  /// Transaction IDs that have been confirmed on-chain.
  final List<String> confirmedTxIds;

  /// The minimum amount of sats one can send in order for the swap to succeed. Received from [SwapperAPI::create_swap].
  final PlatformInt64 minAllowedDeposit;

  /// The maximum amount of sats one can send in order for the swap to succeed. This is determined based on `max_swapper_payable` and the node's local balance.
  final PlatformInt64 maxAllowedDeposit;

  /// The absolute maximum value payable by the swapper. Received from [SwapperAPI::create_swap].
  final PlatformInt64 maxSwapperPayable;

  /// Error reason for when swap fails.
  final String? lastRedeemError;

  /// The dynamic fees which is set if a channel opening is needed.
  ///
  /// This is an optional field for backward compatibility with swaps created before dynamic fees.
  ///
  /// Swaps created after dynamic fees were introduced always have this field set.
  final OpeningFeeParams? channelOpeningFees;

  /// The block height when the swap was confirmed.
  final int? confirmedAt;

  const SwapInfo({
    required this.bitcoinAddress,
    required this.createdAt,
    required this.lockHeight,
    required this.paymentHash,
    required this.preimage,
    required this.privateKey,
    required this.publicKey,
    required this.swapperPublicKey,
    required this.script,
    this.bolt11,
    required this.paidMsat,
    required this.totalIncomingTxs,
    required this.confirmedSats,
    required this.unconfirmedSats,
    required this.status,
    required this.refundTxIds,
    required this.unconfirmedTxIds,
    required this.confirmedTxIds,
    required this.minAllowedDeposit,
    required this.maxAllowedDeposit,
    required this.maxSwapperPayable,
    this.lastRedeemError,
    this.channelOpeningFees,
    this.confirmedAt,
  });

  @override
  int get hashCode =>
      bitcoinAddress.hashCode ^
      createdAt.hashCode ^
      lockHeight.hashCode ^
      paymentHash.hashCode ^
      preimage.hashCode ^
      privateKey.hashCode ^
      publicKey.hashCode ^
      swapperPublicKey.hashCode ^
      script.hashCode ^
      bolt11.hashCode ^
      paidMsat.hashCode ^
      totalIncomingTxs.hashCode ^
      confirmedSats.hashCode ^
      unconfirmedSats.hashCode ^
      status.hashCode ^
      refundTxIds.hashCode ^
      unconfirmedTxIds.hashCode ^
      confirmedTxIds.hashCode ^
      minAllowedDeposit.hashCode ^
      maxAllowedDeposit.hashCode ^
      maxSwapperPayable.hashCode ^
      lastRedeemError.hashCode ^
      channelOpeningFees.hashCode ^
      confirmedAt.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SwapInfo &&
          runtimeType == other.runtimeType &&
          bitcoinAddress == other.bitcoinAddress &&
          createdAt == other.createdAt &&
          lockHeight == other.lockHeight &&
          paymentHash == other.paymentHash &&
          preimage == other.preimage &&
          privateKey == other.privateKey &&
          publicKey == other.publicKey &&
          swapperPublicKey == other.swapperPublicKey &&
          script == other.script &&
          bolt11 == other.bolt11 &&
          paidMsat == other.paidMsat &&
          totalIncomingTxs == other.totalIncomingTxs &&
          confirmedSats == other.confirmedSats &&
          unconfirmedSats == other.unconfirmedSats &&
          status == other.status &&
          refundTxIds == other.refundTxIds &&
          unconfirmedTxIds == other.unconfirmedTxIds &&
          confirmedTxIds == other.confirmedTxIds &&
          minAllowedDeposit == other.minAllowedDeposit &&
          maxAllowedDeposit == other.maxAllowedDeposit &&
          maxSwapperPayable == other.maxSwapperPayable &&
          lastRedeemError == other.lastRedeemError &&
          channelOpeningFees == other.channelOpeningFees &&
          confirmedAt == other.confirmedAt;
}

/// The status of a swap
enum SwapStatus {
  /// The swap address has been created and either there aren't any confirmed transactions associated with it
  /// or there are confirmed transactions that are bellow the lock timeout which means the funds are still
  /// eligible to be redeemed normally.
  Initial,
  WaitingConfirmation,
  Redeemable,
  Redeemed,

  /// The swap address has confirmed transactions associated with it and the lock timeout has passed since
  /// the earliest confirmed transaction. This means the only way to spend the funds from this address is by
  /// broadcasting a refund transaction.
  Refundable,
  Completed,
}

/// Represents a TLV entry for a keysend payment.
class TlvEntry {
  /// The type field for the TLV
  final BigInt fieldNumber;

  /// The value bytes for the TLV
  final Uint8List value;

  const TlvEntry({required this.fieldNumber, required this.value});

  @override
  int get hashCode => fieldNumber.hashCode ^ value.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is TlvEntry &&
          runtimeType == other.runtimeType &&
          fieldNumber == other.fieldNumber &&
          value == other.value;
}

/// UTXO known to the LN node
class UnspentTransactionOutput {
  final Uint8List txid;
  final int outnum;
  final BigInt amountMillisatoshi;
  final String address;
  final bool reserved;

  const UnspentTransactionOutput({
    required this.txid,
    required this.outnum,
    required this.amountMillisatoshi,
    required this.address,
    required this.reserved,
  });

  @override
  int get hashCode =>
      txid.hashCode ^ outnum.hashCode ^ amountMillisatoshi.hashCode ^ address.hashCode ^ reserved.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is UnspentTransactionOutput &&
          runtimeType == other.runtimeType &&
          txid == other.txid &&
          outnum == other.outnum &&
          amountMillisatoshi == other.amountMillisatoshi &&
          address == other.address &&
          reserved == other.reserved;
}
