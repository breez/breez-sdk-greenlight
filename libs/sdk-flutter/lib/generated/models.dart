// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.0.0-dev.32.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'frb_generated.dart';
import 'input_parser.dart';
import 'invoice.dart';
import 'lnurl/pay/model.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
part 'models.freezed.dart';

class BackupStatus {
  final bool backedUp;

  /// Epoch time, in seconds
  final int? lastBackupTime;

  const BackupStatus({
    required this.backedUp,
    this.lastBackupTime,
  });

  @override
  int get hashCode => backedUp.hashCode ^ lastBackupTime.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is BackupStatus &&
          runtimeType == other.runtimeType &&
          backedUp == other.backedUp &&
          lastBackupTime == other.lastBackupTime;
}

/// Different providers will demand different behaviours when the user is trying to buy bitcoin.
enum BuyBitcoinProvider {
  Moonpay,
  ;
}

class BuyBitcoinRequest {
  final BuyBitcoinProvider provider;
  final OpeningFeeParams? openingFeeParams;

  const BuyBitcoinRequest({
    required this.provider,
    this.openingFeeParams,
  });

  @override
  int get hashCode => provider.hashCode ^ openingFeeParams.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is BuyBitcoinRequest &&
          runtimeType == other.runtimeType &&
          provider == other.provider &&
          openingFeeParams == other.openingFeeParams;
}

class BuyBitcoinResponse {
  final String url;
  final OpeningFeeParams? openingFeeParams;

  const BuyBitcoinResponse({
    required this.url,
    this.openingFeeParams,
  });

  @override
  int get hashCode => url.hashCode ^ openingFeeParams.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is BuyBitcoinResponse &&
          runtimeType == other.runtimeType &&
          url == other.url &&
          openingFeeParams == other.openingFeeParams;
}

/// State of a Lightning channel
enum ChannelState {
  PendingOpen,
  Opened,
  PendingClose,
  Closed,
  ;
}

/// Represents the funds that were on the user side of the channel at the time it was closed.
class ClosedChannelPaymentDetails {
  final ChannelState state;
  final String fundingTxid;
  final String? shortChannelId;

  /// Can be empty for older closed channels.
  final String? closingTxid;

  const ClosedChannelPaymentDetails({
    required this.state,
    required this.fundingTxid,
    this.shortChannelId,
    this.closingTxid,
  });

  @override
  int get hashCode => state.hashCode ^ fundingTxid.hashCode ^ shortChannelId.hashCode ^ closingTxid.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ClosedChannelPaymentDetails &&
          runtimeType == other.runtimeType &&
          state == other.state &&
          fundingTxid == other.fundingTxid &&
          shortChannelId == other.shortChannelId &&
          closingTxid == other.closingTxid;
}

/// Configuration for the Breez Services
///
/// Use [Config::production] or [Config::staging] for default configs of the different supported
/// environments.
class Config {
  final String breezserver;
  final String chainnotifierUrl;

  /// If set, this is the mempool.space URL that will be used.
  ///
  /// If not set, a list of mempool.space URLs will be used to provide fault-tolerance. If calls
  /// to the first URL fail, then the call will be repeated to the next URL, and so on.
  ///
  /// Note that, if specified, the URL has to be in the format: `https://mempool.space/api`
  final String? mempoolspaceUrl;

  /// Directory in which all SDK files (DB, log) are stored. Defaults to ".", otherwise if it's customized,
  /// the folder should exist before starting the SDK.
  final String workingDir;
  final Network network;
  final int paymentTimeoutSec;
  final String? defaultLspId;
  final String? apiKey;

  /// Maps to the CLN `maxfeepercent` config when paying invoices (`lightning-pay`)
  final double maxfeePercent;

  /// Maps to the CLN `exemptfee` config when paying invoices (`lightning-pay`)
  final int exemptfeeMsat;
  final NodeConfig nodeConfig;

  const Config({
    required this.breezserver,
    required this.chainnotifierUrl,
    this.mempoolspaceUrl,
    required this.workingDir,
    required this.network,
    required this.paymentTimeoutSec,
    this.defaultLspId,
    this.apiKey,
    required this.maxfeePercent,
    required this.exemptfeeMsat,
    required this.nodeConfig,
  });

  @override
  int get hashCode =>
      breezserver.hashCode ^
      chainnotifierUrl.hashCode ^
      mempoolspaceUrl.hashCode ^
      workingDir.hashCode ^
      network.hashCode ^
      paymentTimeoutSec.hashCode ^
      defaultLspId.hashCode ^
      apiKey.hashCode ^
      maxfeePercent.hashCode ^
      exemptfeeMsat.hashCode ^
      nodeConfig.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Config &&
          runtimeType == other.runtimeType &&
          breezserver == other.breezserver &&
          chainnotifierUrl == other.chainnotifierUrl &&
          mempoolspaceUrl == other.mempoolspaceUrl &&
          workingDir == other.workingDir &&
          network == other.network &&
          paymentTimeoutSec == other.paymentTimeoutSec &&
          defaultLspId == other.defaultLspId &&
          apiKey == other.apiKey &&
          maxfeePercent == other.maxfeePercent &&
          exemptfeeMsat == other.exemptfeeMsat &&
          nodeConfig == other.nodeConfig;
}

/// Represents a configure node request.
class ConfigureNodeRequest {
  final String? closeToAddress;

  const ConfigureNodeRequest({
    this.closeToAddress,
  });

  @override
  int get hashCode => closeToAddress.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ConfigureNodeRequest &&
          runtimeType == other.runtimeType &&
          closeToAddress == other.closeToAddress;
}

/// Represents a connect request.
class ConnectRequest {
  final Config config;
  final Uint8List seed;

  /// If true, only restores an existing node and otherwise result in an error
  final bool? restoreOnly;

  const ConnectRequest({
    required this.config,
    required this.seed,
    this.restoreOnly,
  });

  @override
  int get hashCode => config.hashCode ^ seed.hashCode ^ restoreOnly.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ConnectRequest &&
          runtimeType == other.runtimeType &&
          config == other.config &&
          seed == other.seed &&
          restoreOnly == other.restoreOnly;
}

/// Indicates the different kinds of supported environments for [crate::BreezServices].
enum EnvironmentType {
  Production,
  Staging,
  ;
}

/// Client-specific credentials to connect to and manage a Greenlight node in the cloud
class GreenlightCredentials {
  final Uint8List deviceKey;
  final Uint8List deviceCert;

  const GreenlightCredentials({
    required this.deviceKey,
    required this.deviceCert,
  });

  @override
  int get hashCode => deviceKey.hashCode ^ deviceCert.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is GreenlightCredentials &&
          runtimeType == other.runtimeType &&
          deviceKey == other.deviceKey &&
          deviceCert == other.deviceCert;
}

class GreenlightNodeConfig {
  final GreenlightCredentials? partnerCredentials;
  final String? inviteCode;

  const GreenlightNodeConfig({
    this.partnerCredentials,
    this.inviteCode,
  });

  @override
  int get hashCode => partnerCredentials.hashCode ^ inviteCode.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is GreenlightNodeConfig &&
          runtimeType == other.runtimeType &&
          partnerCredentials == other.partnerCredentials &&
          inviteCode == other.inviteCode;
}

/// Indicates the different service health check statuses.
enum HealthCheckStatus {
  Operational,
  Maintenance,
  ServiceDisruption,
  ;
}

/// Represents a list payments request.
class ListPaymentsRequest {
  final List<PaymentTypeFilter>? filters;
  final List<MetadataFilter>? metadataFilters;

  /// Epoch time, in seconds
  final int? fromTimestamp;

  /// Epoch time, in seconds
  final int? toTimestamp;
  final bool? includeFailures;
  final int? offset;
  final int? limit;

  const ListPaymentsRequest({
    this.filters,
    this.metadataFilters,
    this.fromTimestamp,
    this.toTimestamp,
    this.includeFailures,
    this.offset,
    this.limit,
  });

  @override
  int get hashCode =>
      filters.hashCode ^
      metadataFilters.hashCode ^
      fromTimestamp.hashCode ^
      toTimestamp.hashCode ^
      includeFailures.hashCode ^
      offset.hashCode ^
      limit.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ListPaymentsRequest &&
          runtimeType == other.runtimeType &&
          filters == other.filters &&
          metadataFilters == other.metadataFilters &&
          fromTimestamp == other.fromTimestamp &&
          toTimestamp == other.toTimestamp &&
          includeFailures == other.includeFailures &&
          offset == other.offset &&
          limit == other.limit;
}

/// Details of a LN payment, as included in a [Payment]
class LnPaymentDetails {
  final String paymentHash;
  final String label;
  final String destinationPubkey;
  final String paymentPreimage;
  final bool keysend;
  final String bolt11;

  /// Only set for [PaymentType::Received], payments which require to open a channel.
  /// Represents the actual invoice paid by the sender
  final String? openChannelBolt11;

  /// Only set for [PaymentType::Sent] payments that are part of a LNURL-pay workflow where
  /// the endpoint returns a success action
  final SuccessActionProcessed? lnurlSuccessAction;

  /// Only set for [PaymentType::Sent] payments if it is not a payment to a Lightning Address
  final String? lnurlPayDomain;

  /// Only set for [PaymentType::Sent] payments that are sent to a Lightning Address
  final String? lnAddress;

  /// Only set for [PaymentType::Sent] payments where the receiver endpoint returned LNURL metadata
  final String? lnurlMetadata;

  /// Only set for [PaymentType::Received] payments that were received as part of LNURL-withdraw
  final String? lnurlWithdrawEndpoint;

  /// Only set for [PaymentType::Received] payments that were received in the context of a swap
  final SwapInfo? swapInfo;

  /// Only set for [PaymentType::Sent] payments that were sent in the context of a reverse swap
  final ReverseSwapInfo? reverseSwapInfo;

  /// Only set for [PaymentStatus::Pending] payments that are inflight.
  final int? pendingExpirationBlock;

  const LnPaymentDetails({
    required this.paymentHash,
    required this.label,
    required this.destinationPubkey,
    required this.paymentPreimage,
    required this.keysend,
    required this.bolt11,
    this.openChannelBolt11,
    this.lnurlSuccessAction,
    this.lnurlPayDomain,
    this.lnAddress,
    this.lnurlMetadata,
    this.lnurlWithdrawEndpoint,
    this.swapInfo,
    this.reverseSwapInfo,
    this.pendingExpirationBlock,
  });

  @override
  int get hashCode =>
      paymentHash.hashCode ^
      label.hashCode ^
      destinationPubkey.hashCode ^
      paymentPreimage.hashCode ^
      keysend.hashCode ^
      bolt11.hashCode ^
      openChannelBolt11.hashCode ^
      lnurlSuccessAction.hashCode ^
      lnurlPayDomain.hashCode ^
      lnAddress.hashCode ^
      lnurlMetadata.hashCode ^
      lnurlWithdrawEndpoint.hashCode ^
      swapInfo.hashCode ^
      reverseSwapInfo.hashCode ^
      pendingExpirationBlock.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is LnPaymentDetails &&
          runtimeType == other.runtimeType &&
          paymentHash == other.paymentHash &&
          label == other.label &&
          destinationPubkey == other.destinationPubkey &&
          paymentPreimage == other.paymentPreimage &&
          keysend == other.keysend &&
          bolt11 == other.bolt11 &&
          openChannelBolt11 == other.openChannelBolt11 &&
          lnurlSuccessAction == other.lnurlSuccessAction &&
          lnurlPayDomain == other.lnurlPayDomain &&
          lnAddress == other.lnAddress &&
          lnurlMetadata == other.lnurlMetadata &&
          lnurlWithdrawEndpoint == other.lnurlWithdrawEndpoint &&
          swapInfo == other.swapInfo &&
          reverseSwapInfo == other.reverseSwapInfo &&
          pendingExpirationBlock == other.pendingExpirationBlock;
}

@freezed
sealed class LnUrlCallbackStatus with _$LnUrlCallbackStatus {
  const LnUrlCallbackStatus._();

  /// On-wire format is: `{"status": "OK"}`
  const factory LnUrlCallbackStatus.ok() = LnUrlCallbackStatus_Ok;

  /// On-wire format is: `{"status": "ERROR", "reason": "error details..."}`
  const factory LnUrlCallbackStatus.errorStatus({
    required LnUrlErrorData data,
  }) = LnUrlCallbackStatus_ErrorStatus;
}

/// Represents a LNURL-pay request.
class LnUrlPayRequest {
  /// The [LnUrlPayRequestData] returned by [crate::input_parser::parse]
  final LnUrlPayRequestData data;

  /// The amount in millisatoshis for this payment
  final int amountMsat;

  /// An optional comment for this payment
  final String? comment;

  /// The external label or identifier of the [Payment]
  final String? paymentLabel;

  const LnUrlPayRequest({
    required this.data,
    required this.amountMsat,
    this.comment,
    this.paymentLabel,
  });

  @override
  int get hashCode => data.hashCode ^ amountMsat.hashCode ^ comment.hashCode ^ paymentLabel.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is LnUrlPayRequest &&
          runtimeType == other.runtimeType &&
          data == other.data &&
          amountMsat == other.amountMsat &&
          comment == other.comment &&
          paymentLabel == other.paymentLabel;
}

class LnUrlWithdrawRequest {
  /// Request data containing information on how to call the lnurl withdraw
  /// endpoint. Typically retrieved by calling `parse()` on a lnurl withdraw
  /// input.
  final LnUrlWithdrawRequestData data;

  /// The amount to withdraw from the lnurl withdraw endpoint. Must be between
  /// `min_withdrawable` and `max_withdrawable`.
  final int amountMsat;

  /// Optional description that will be put in the payment request for the
  /// lnurl withdraw endpoint.
  final String? description;

  const LnUrlWithdrawRequest({
    required this.data,
    required this.amountMsat,
    this.description,
  });

  @override
  int get hashCode => data.hashCode ^ amountMsat.hashCode ^ description.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is LnUrlWithdrawRequest &&
          runtimeType == other.runtimeType &&
          data == other.data &&
          amountMsat == other.amountMsat &&
          description == other.description;
}

@freezed
sealed class LnUrlWithdrawResult with _$LnUrlWithdrawResult {
  const LnUrlWithdrawResult._();

  const factory LnUrlWithdrawResult.ok({
    required LnUrlWithdrawSuccessData data,
  }) = LnUrlWithdrawResult_Ok;
  const factory LnUrlWithdrawResult.errorStatus({
    required LnUrlErrorData data,
  }) = LnUrlWithdrawResult_ErrorStatus;
}

class LnUrlWithdrawSuccessData {
  final LNInvoice invoice;

  const LnUrlWithdrawSuccessData({
    required this.invoice,
  });

  @override
  int get hashCode => invoice.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is LnUrlWithdrawSuccessData && runtimeType == other.runtimeType && invoice == other.invoice;
}

/// Internal SDK log entry
class LogEntry {
  final String line;
  final String level;

  const LogEntry({
    required this.line,
    required this.level,
  });

  @override
  int get hashCode => line.hashCode ^ level.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is LogEntry && runtimeType == other.runtimeType && line == other.line && level == other.level;
}

class MaxReverseSwapAmountResponse {
  /// The total sats that can be sent onchain.
  final int totalSat;

  const MaxReverseSwapAmountResponse({
    required this.totalSat,
  });

  @override
  int get hashCode => totalSat.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is MaxReverseSwapAmountResponse && runtimeType == other.runtimeType && totalSat == other.totalSat;
}

/// A metadata filter which can be applied when retrieving the transaction list
class MetadataFilter {
  /// Specifies which field to apply the filter on, using the JSON path format
  final String jsonPath;

  /// Specifies which JSON value to filter for.
  /// As such, strings must be wrapped with quotes ("") in order to be properly filtered
  final String jsonValue;

  const MetadataFilter({
    required this.jsonPath,
    required this.jsonValue,
  });

  @override
  int get hashCode => jsonPath.hashCode ^ jsonValue.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is MetadataFilter &&
          runtimeType == other.runtimeType &&
          jsonPath == other.jsonPath &&
          jsonValue == other.jsonValue;
}

/// The different supported bitcoin networks
enum Network {
  /// Mainnet
  Bitcoin,
  Testnet,
  Signet,
  Regtest,
  ;
}

@freezed
sealed class NodeConfig with _$NodeConfig {
  const NodeConfig._();

  const factory NodeConfig.greenlight({
    required GreenlightNodeConfig config,
  }) = NodeConfig_Greenlight;
}

@freezed
sealed class NodeCredentials with _$NodeCredentials {
  const NodeCredentials._();

  const factory NodeCredentials.greenlight({
    required GreenlightCredentials credentials,
  }) = NodeCredentials_Greenlight;
}

/// The node state of a Greenlight LN node running in the cloud.
///
/// Note: The implementation attempts to provide the most up-to-date values,
/// which may result in some short-lived inconsistencies
/// (e.g., `channels_balance_msat` may be updated before `inbound_liquidity_msats`).
class NodeState {
  final String id;
  final int blockHeight;
  final int channelsBalanceMsat;
  final int onchainBalanceMsat;
  final int pendingOnchainBalanceMsat;
  final List<UnspentTransactionOutput> utxos;
  final int maxPayableMsat;
  final int maxReceivableMsat;
  final int maxSinglePaymentAmountMsat;
  final int maxChanReserveMsats;
  final List<String> connectedPeers;
  final int inboundLiquidityMsats;

  const NodeState({
    required this.id,
    required this.blockHeight,
    required this.channelsBalanceMsat,
    required this.onchainBalanceMsat,
    required this.pendingOnchainBalanceMsat,
    required this.utxos,
    required this.maxPayableMsat,
    required this.maxReceivableMsat,
    required this.maxSinglePaymentAmountMsat,
    required this.maxChanReserveMsats,
    required this.connectedPeers,
    required this.inboundLiquidityMsats,
  });

  @override
  int get hashCode =>
      id.hashCode ^
      blockHeight.hashCode ^
      channelsBalanceMsat.hashCode ^
      onchainBalanceMsat.hashCode ^
      pendingOnchainBalanceMsat.hashCode ^
      utxos.hashCode ^
      maxPayableMsat.hashCode ^
      maxReceivableMsat.hashCode ^
      maxSinglePaymentAmountMsat.hashCode ^
      maxChanReserveMsats.hashCode ^
      connectedPeers.hashCode ^
      inboundLiquidityMsats.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is NodeState &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          blockHeight == other.blockHeight &&
          channelsBalanceMsat == other.channelsBalanceMsat &&
          onchainBalanceMsat == other.onchainBalanceMsat &&
          pendingOnchainBalanceMsat == other.pendingOnchainBalanceMsat &&
          utxos == other.utxos &&
          maxPayableMsat == other.maxPayableMsat &&
          maxReceivableMsat == other.maxReceivableMsat &&
          maxSinglePaymentAmountMsat == other.maxSinglePaymentAmountMsat &&
          maxChanReserveMsats == other.maxChanReserveMsats &&
          connectedPeers == other.connectedPeers &&
          inboundLiquidityMsats == other.inboundLiquidityMsats;
}

class OnchainPaymentLimitsResponse {
  /// Minimum amount that can be sent. This value is influenced by
  /// - what can be sent given the available channels and balance
  /// - the lower limit of what the reverse swap service accepts as a send amount
  final int minSat;

  /// Maximum amount that can be sent. This value is influenced by
  /// - what can be sent given the available channels and balance
  /// - the upper limit of what the reverse swap service accepts as a send amount
  final int maxSat;

  const OnchainPaymentLimitsResponse({
    required this.minSat,
    required this.maxSat,
  });

  @override
  int get hashCode => minSat.hashCode ^ maxSat.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is OnchainPaymentLimitsResponse &&
          runtimeType == other.runtimeType &&
          minSat == other.minSat &&
          maxSat == other.maxSat;
}

class OpenChannelFeeRequest {
  final int? amountMsat;
  final int? expiry;

  const OpenChannelFeeRequest({
    this.amountMsat,
    this.expiry,
  });

  @override
  int get hashCode => amountMsat.hashCode ^ expiry.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is OpenChannelFeeRequest &&
          runtimeType == other.runtimeType &&
          amountMsat == other.amountMsat &&
          expiry == other.expiry;
}

class OpenChannelFeeResponse {
  /// Opening fee for receiving the amount set in the [OpenChannelFeeRequest], in case it was set.
  /// It may be zero if no new channel needs to be opened.
  final int? feeMsat;

  /// The fee params for receiving more than the current inbound liquidity.
  final OpeningFeeParams feeParams;

  const OpenChannelFeeResponse({
    this.feeMsat,
    required this.feeParams,
  });

  @override
  int get hashCode => feeMsat.hashCode ^ feeParams.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is OpenChannelFeeResponse &&
          runtimeType == other.runtimeType &&
          feeMsat == other.feeMsat &&
          feeParams == other.feeParams;
}

/// Dynamic fee parameters offered by the LSP for opening a new channel.
///
/// After they are received, the client shouldn't change them when calling LSP methods,
/// otherwise the LSP may reject the call.
class OpeningFeeParams {
  /// The minimum value in millisatoshi we will require for incoming HTLCs on the channel
  final int minMsat;

  /// The fee in ppm charged over liquidity when buying a channel
  final int proportional;

  /// The date and time this opening fee params promise expires, in RFC 3339 / ISO 8601 format
  final String validUntil;

  /// The channel can be closed if not used within this duration in blocks
  final int maxIdleTime;
  final int maxClientToSelfDelay;
  final String promise;

  const OpeningFeeParams({
    required this.minMsat,
    required this.proportional,
    required this.validUntil,
    required this.maxIdleTime,
    required this.maxClientToSelfDelay,
    required this.promise,
  });

  @override
  int get hashCode =>
      minMsat.hashCode ^
      proportional.hashCode ^
      validUntil.hashCode ^
      maxIdleTime.hashCode ^
      maxClientToSelfDelay.hashCode ^
      promise.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is OpeningFeeParams &&
          runtimeType == other.runtimeType &&
          minMsat == other.minMsat &&
          proportional == other.proportional &&
          validUntil == other.validUntil &&
          maxIdleTime == other.maxIdleTime &&
          maxClientToSelfDelay == other.maxClientToSelfDelay &&
          promise == other.promise;
}

/// See [OpeningFeeParamsMenu::try_from]
class OpeningFeeParamsMenu {
  final List<OpeningFeeParams> values;

  const OpeningFeeParamsMenu({
    required this.values,
  });

  @override
  int get hashCode => values.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is OpeningFeeParamsMenu && runtimeType == other.runtimeType && values == other.values;
}

class PayOnchainRequest {
  final String recipientAddress;
  final PrepareOnchainPaymentResponse prepareRes;

  const PayOnchainRequest({
    required this.recipientAddress,
    required this.prepareRes,
  });

  @override
  int get hashCode => recipientAddress.hashCode ^ prepareRes.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PayOnchainRequest &&
          runtimeType == other.runtimeType &&
          recipientAddress == other.recipientAddress &&
          prepareRes == other.prepareRes;
}

class PayOnchainResponse {
  final ReverseSwapInfo reverseSwapInfo;

  const PayOnchainResponse({
    required this.reverseSwapInfo,
  });

  @override
  int get hashCode => reverseSwapInfo.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PayOnchainResponse &&
          runtimeType == other.runtimeType &&
          reverseSwapInfo == other.reverseSwapInfo;
}

/// Represents a payment, including its [PaymentType] and [PaymentDetails]
class Payment {
  final String id;
  final PaymentType paymentType;

  /// Epoch time, in seconds
  final int paymentTime;
  final int amountMsat;
  final int feeMsat;
  final PaymentStatus status;
  final String? error;
  final String? description;
  final PaymentDetails details;
  final String? metadata;

  const Payment({
    required this.id,
    required this.paymentType,
    required this.paymentTime,
    required this.amountMsat,
    required this.feeMsat,
    required this.status,
    this.error,
    this.description,
    required this.details,
    this.metadata,
  });

  @override
  int get hashCode =>
      id.hashCode ^
      paymentType.hashCode ^
      paymentTime.hashCode ^
      amountMsat.hashCode ^
      feeMsat.hashCode ^
      status.hashCode ^
      error.hashCode ^
      description.hashCode ^
      details.hashCode ^
      metadata.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Payment &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          paymentType == other.paymentType &&
          paymentTime == other.paymentTime &&
          amountMsat == other.amountMsat &&
          feeMsat == other.feeMsat &&
          status == other.status &&
          error == other.error &&
          description == other.description &&
          details == other.details &&
          metadata == other.metadata;
}

@freezed
sealed class PaymentDetails with _$PaymentDetails {
  const PaymentDetails._();

  const factory PaymentDetails.ln({
    required LnPaymentDetails data,
  }) = PaymentDetails_Ln;
  const factory PaymentDetails.closedChannel({
    required ClosedChannelPaymentDetails data,
  }) = PaymentDetails_ClosedChannel;
}

/// The status of a payment
enum PaymentStatus {
  Pending,
  Complete,
  Failed,
  ;
}

/// Different types of supported payments
enum PaymentType {
  Sent,
  Received,
  ClosedChannel,
  ;
}

/// Different types of supported filters which can be applied when retrieving the transaction list
enum PaymentTypeFilter {
  Sent,
  Received,
  ClosedChannel,
  ;
}

/// See [ReverseSwapFeesRequest]
class PrepareOnchainPaymentRequest {
  /// Depending on `amount_type`, this may be the desired send amount or the desired receive amount.
  final int amountSat;
  final SwapAmountType amountType;

  /// Feerate (sat / vByte) for the claim transaction
  final int claimTxFeerate;

  const PrepareOnchainPaymentRequest({
    required this.amountSat,
    required this.amountType,
    required this.claimTxFeerate,
  });

  @override
  int get hashCode => amountSat.hashCode ^ amountType.hashCode ^ claimTxFeerate.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PrepareOnchainPaymentRequest &&
          runtimeType == other.runtimeType &&
          amountSat == other.amountSat &&
          amountType == other.amountType &&
          claimTxFeerate == other.claimTxFeerate;
}

/// Contains fields describing the reverse swap parameters (see [ReverseSwapPairInfo]), as well as
/// the resulting send and receive amounts.
class PrepareOnchainPaymentResponse {
  final String feesHash;
  final double feesPercentage;
  final int feesLockup;
  final int feesClaim;
  final int senderAmountSat;
  final int recipientAmountSat;
  final int totalFees;

  const PrepareOnchainPaymentResponse({
    required this.feesHash,
    required this.feesPercentage,
    required this.feesLockup,
    required this.feesClaim,
    required this.senderAmountSat,
    required this.recipientAmountSat,
    required this.totalFees,
  });

  @override
  int get hashCode =>
      feesHash.hashCode ^
      feesPercentage.hashCode ^
      feesLockup.hashCode ^
      feesClaim.hashCode ^
      senderAmountSat.hashCode ^
      recipientAmountSat.hashCode ^
      totalFees.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PrepareOnchainPaymentResponse &&
          runtimeType == other.runtimeType &&
          feesHash == other.feesHash &&
          feesPercentage == other.feesPercentage &&
          feesLockup == other.feesLockup &&
          feesClaim == other.feesClaim &&
          senderAmountSat == other.senderAmountSat &&
          recipientAmountSat == other.recipientAmountSat &&
          totalFees == other.totalFees;
}

/// We need to prepare a redeem_onchain_funds transaction to know what fee will be charged in satoshis.
/// This model holds the request data which consists of the address to redeem on-chain funds to and the fee rate in.
/// satoshis per vbyte which will be converted to absolute satoshis.
class PrepareRedeemOnchainFundsRequest {
  final String toAddress;
  final int satPerVbyte;

  const PrepareRedeemOnchainFundsRequest({
    required this.toAddress,
    required this.satPerVbyte,
  });

  @override
  int get hashCode => toAddress.hashCode ^ satPerVbyte.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PrepareRedeemOnchainFundsRequest &&
          runtimeType == other.runtimeType &&
          toAddress == other.toAddress &&
          satPerVbyte == other.satPerVbyte;
}

/// We need to prepare a redeem_onchain_funds transaction to know what a fee it will be charged in satoshis
/// this model holds the response data, which consists of the weight and the absolute fee in sats
class PrepareRedeemOnchainFundsResponse {
  final int txWeight;
  final int txFeeSat;

  const PrepareRedeemOnchainFundsResponse({
    required this.txWeight,
    required this.txFeeSat,
  });

  @override
  int get hashCode => txWeight.hashCode ^ txFeeSat.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PrepareRedeemOnchainFundsResponse &&
          runtimeType == other.runtimeType &&
          txWeight == other.txWeight &&
          txFeeSat == other.txFeeSat;
}

class PrepareRefundRequest {
  final String swapAddress;
  final String toAddress;
  final int satPerVbyte;

  const PrepareRefundRequest({
    required this.swapAddress,
    required this.toAddress,
    required this.satPerVbyte,
  });

  @override
  int get hashCode => swapAddress.hashCode ^ toAddress.hashCode ^ satPerVbyte.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PrepareRefundRequest &&
          runtimeType == other.runtimeType &&
          swapAddress == other.swapAddress &&
          toAddress == other.toAddress &&
          satPerVbyte == other.satPerVbyte;
}

class PrepareRefundResponse {
  final int refundTxWeight;
  final int refundTxFeeSat;

  const PrepareRefundResponse({
    required this.refundTxWeight,
    required this.refundTxFeeSat,
  });

  @override
  int get hashCode => refundTxWeight.hashCode ^ refundTxFeeSat.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PrepareRefundResponse &&
          runtimeType == other.runtimeType &&
          refundTxWeight == other.refundTxWeight &&
          refundTxFeeSat == other.refundTxFeeSat;
}

class ReceiveOnchainRequest {
  final OpeningFeeParams? openingFeeParams;

  const ReceiveOnchainRequest({
    this.openingFeeParams,
  });

  @override
  int get hashCode => openingFeeParams.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ReceiveOnchainRequest &&
          runtimeType == other.runtimeType &&
          openingFeeParams == other.openingFeeParams;
}

/// Represents a receive payment request.
class ReceivePaymentRequest {
  /// The amount in satoshis for this payment request
  final int amountMsat;

  /// The description for this payment request.
  final String description;

  /// Optional preimage for this payment request.
  /// If specified, it will be used instead of generating a new one.
  final Uint8List? preimage;

  /// If set and valid, these fess options are used when a new channels is needed.
  /// Otherwise the default fee options will be used.
  final OpeningFeeParams? openingFeeParams;

  /// If set to true, then the bolt11 invoice returned includes the description hash.
  final bool? useDescriptionHash;

  /// if specified, set the time the invoice is valid for, in seconds.
  final int? expiry;

  /// if specified, sets the min_final_cltv_expiry for the invoice
  final int? cltv;

  const ReceivePaymentRequest({
    required this.amountMsat,
    required this.description,
    this.preimage,
    this.openingFeeParams,
    this.useDescriptionHash,
    this.expiry,
    this.cltv,
  });

  @override
  int get hashCode =>
      amountMsat.hashCode ^
      description.hashCode ^
      preimage.hashCode ^
      openingFeeParams.hashCode ^
      useDescriptionHash.hashCode ^
      expiry.hashCode ^
      cltv.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ReceivePaymentRequest &&
          runtimeType == other.runtimeType &&
          amountMsat == other.amountMsat &&
          description == other.description &&
          preimage == other.preimage &&
          openingFeeParams == other.openingFeeParams &&
          useDescriptionHash == other.useDescriptionHash &&
          expiry == other.expiry &&
          cltv == other.cltv;
}

/// Represents a receive payment response.
///
/// Breez SDK may have to open a new channel to receive this payment. In that case, the channel will
/// be opened automatically when the invoice is paid, and the fees will be described in the
/// `opening_fee_params` and `opening_fee_msat` fields.
class ReceivePaymentResponse {
  /// The generated invoice, including any necessary routing hints
  final LNInvoice lnInvoice;

  /// If set, these are the [OpeningFeeParams] used to calculate the channel opening fees.
  final OpeningFeeParams? openingFeeParams;

  /// If set, this is the channel opening fee that will be deduced from the invoice amount.
  final int? openingFeeMsat;

  const ReceivePaymentResponse({
    required this.lnInvoice,
    this.openingFeeParams,
    this.openingFeeMsat,
  });

  @override
  int get hashCode => lnInvoice.hashCode ^ openingFeeParams.hashCode ^ openingFeeMsat.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ReceivePaymentResponse &&
          runtimeType == other.runtimeType &&
          lnInvoice == other.lnInvoice &&
          openingFeeParams == other.openingFeeParams &&
          openingFeeMsat == other.openingFeeMsat;
}

class RedeemOnchainFundsRequest {
  final String toAddress;
  final int satPerVbyte;

  const RedeemOnchainFundsRequest({
    required this.toAddress,
    required this.satPerVbyte,
  });

  @override
  int get hashCode => toAddress.hashCode ^ satPerVbyte.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is RedeemOnchainFundsRequest &&
          runtimeType == other.runtimeType &&
          toAddress == other.toAddress &&
          satPerVbyte == other.satPerVbyte;
}

class RedeemOnchainFundsResponse {
  final Uint8List txid;

  const RedeemOnchainFundsResponse({
    required this.txid,
  });

  @override
  int get hashCode => txid.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is RedeemOnchainFundsResponse && runtimeType == other.runtimeType && txid == other.txid;
}

class RefundRequest {
  final String swapAddress;
  final String toAddress;
  final int satPerVbyte;

  const RefundRequest({
    required this.swapAddress,
    required this.toAddress,
    required this.satPerVbyte,
  });

  @override
  int get hashCode => swapAddress.hashCode ^ toAddress.hashCode ^ satPerVbyte.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is RefundRequest &&
          runtimeType == other.runtimeType &&
          swapAddress == other.swapAddress &&
          toAddress == other.toAddress &&
          satPerVbyte == other.satPerVbyte;
}

class RefundResponse {
  final String refundTxId;

  const RefundResponse({
    required this.refundTxId,
  });

  @override
  int get hashCode => refundTxId.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is RefundResponse && runtimeType == other.runtimeType && refundTxId == other.refundTxId;
}

@freezed
sealed class ReportIssueRequest with _$ReportIssueRequest {
  const ReportIssueRequest._();

  const factory ReportIssueRequest.paymentFailure({
    required ReportPaymentFailureDetails data,
  }) = ReportIssueRequest_PaymentFailure;
}

class ReportPaymentFailureDetails {
  /// The payment hash of the payment failure
  final String paymentHash;

  /// The comment or error text
  final String? comment;

  const ReportPaymentFailureDetails({
    required this.paymentHash,
    this.comment,
  });

  @override
  int get hashCode => paymentHash.hashCode ^ comment.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ReportPaymentFailureDetails &&
          runtimeType == other.runtimeType &&
          paymentHash == other.paymentHash &&
          comment == other.comment;
}

class ReverseSwapFeesRequest {
  /// Amount to be sent
  final int? sendAmountSat;

  /// Feerate (sat / vByte) for the claim transaction
  final int? claimTxFeerate;

  const ReverseSwapFeesRequest({
    this.sendAmountSat,
    this.claimTxFeerate,
  });

  @override
  int get hashCode => sendAmountSat.hashCode ^ claimTxFeerate.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ReverseSwapFeesRequest &&
          runtimeType == other.runtimeType &&
          sendAmountSat == other.sendAmountSat &&
          claimTxFeerate == other.claimTxFeerate;
}

/// Simplified version of [FullReverseSwapInfo], containing only the user-relevant fields
class ReverseSwapInfo {
  final String id;
  final String claimPubkey;

  /// The lockup tx id, available from the moment the lockup tx is seen in the mempool by the SDK
  final String? lockupTxid;

  /// The claim tx id, available from the moment the claim tx is broadcast by the SDK
  final String? claimTxid;
  final int onchainAmountSat;
  final ReverseSwapStatus status;

  const ReverseSwapInfo({
    required this.id,
    required this.claimPubkey,
    this.lockupTxid,
    this.claimTxid,
    required this.onchainAmountSat,
    required this.status,
  });

  @override
  int get hashCode =>
      id.hashCode ^
      claimPubkey.hashCode ^
      lockupTxid.hashCode ^
      claimTxid.hashCode ^
      onchainAmountSat.hashCode ^
      status.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ReverseSwapInfo &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          claimPubkey == other.claimPubkey &&
          lockupTxid == other.lockupTxid &&
          claimTxid == other.claimTxid &&
          onchainAmountSat == other.onchainAmountSat &&
          status == other.status;
}

/// Details about the reverse swap fees and parameters, at this point in time
class ReverseSwapPairInfo {
  /// Minimum amount of sats a reverse swap is allowed to have given the current feerate conditions
  final int min;

  /// Maximum amount of sats a reverse swap is allowed to have given the current feerate conditions
  final int max;

  /// Hash of the pair info JSON
  final String feesHash;

  /// Percentage fee for the reverse swap service
  final double feesPercentage;

  /// Miner fees in sats for locking up funds
  final int feesLockup;

  /// Miner fees in sats for claiming funds. Estimate or exact value, depending on the request args.
  final int feesClaim;

  /// Total fees for the reverse swap, in sats, based on the given send amount.
  ///
  /// The field is set only when the [ReverseSwapFeesRequest] `send_amount_sat` is known.
  ///
  /// If the [ReverseSwapFeesRequest] has the `claim_tx_feerate` empty, this is an estimate. If
  /// the `claim_tx_feerate` is set, this is the exact value of the total reverse swap fees.
  final int? totalFees;

  const ReverseSwapPairInfo({
    required this.min,
    required this.max,
    required this.feesHash,
    required this.feesPercentage,
    required this.feesLockup,
    required this.feesClaim,
    this.totalFees,
  });

  @override
  int get hashCode =>
      min.hashCode ^
      max.hashCode ^
      feesHash.hashCode ^
      feesPercentage.hashCode ^
      feesLockup.hashCode ^
      feesClaim.hashCode ^
      totalFees.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ReverseSwapPairInfo &&
          runtimeType == other.runtimeType &&
          min == other.min &&
          max == other.max &&
          feesHash == other.feesHash &&
          feesPercentage == other.feesPercentage &&
          feesLockup == other.feesLockup &&
          feesClaim == other.feesClaim &&
          totalFees == other.totalFees;
}

/// The possible statuses of a reverse swap, from the Breez SDK perspective.
///
/// See [BoltzApiReverseSwapStatus] for the reverse swap status from the Breez endpoint point of view.
enum ReverseSwapStatus {
  /// HODL invoice payment is not completed yet
  ///
  /// This is also the temporary status of a reverse swap when restoring a node, until `sync` finishes.
  Initial,

  /// HODL invoice payment was successfully triggered and confirmed by Boltz, but the reverse swap
  /// is not yet complete
  InProgress,

  /// An explicit error occurs (validation error, failure reported by Boltz, expiration, etc) and
  /// the initial invoice funds are returned to the sender (invoice is cancelled or payment failed)
  Cancelled,

  /// Successfully completed (claim tx has been seen in the mempool)
  CompletedSeen,

  /// Successfully completed (claim tx has at least one confirmation)
  CompletedConfirmed,
  ;
}

class SendOnchainRequest {
  final int amountSat;
  final String onchainRecipientAddress;
  final String pairHash;
  final int satPerVbyte;

  const SendOnchainRequest({
    required this.amountSat,
    required this.onchainRecipientAddress,
    required this.pairHash,
    required this.satPerVbyte,
  });

  @override
  int get hashCode =>
      amountSat.hashCode ^ onchainRecipientAddress.hashCode ^ pairHash.hashCode ^ satPerVbyte.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SendOnchainRequest &&
          runtimeType == other.runtimeType &&
          amountSat == other.amountSat &&
          onchainRecipientAddress == other.onchainRecipientAddress &&
          pairHash == other.pairHash &&
          satPerVbyte == other.satPerVbyte;
}

class SendOnchainResponse {
  final ReverseSwapInfo reverseSwapInfo;

  const SendOnchainResponse({
    required this.reverseSwapInfo,
  });

  @override
  int get hashCode => reverseSwapInfo.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SendOnchainResponse &&
          runtimeType == other.runtimeType &&
          reverseSwapInfo == other.reverseSwapInfo;
}

/// Represents a send payment request.
class SendPaymentRequest {
  /// The bolt11 invoice
  final String bolt11;

  /// The amount to pay in millisatoshis. Should only be set when `bolt11` is a zero-amount invoice.
  final int? amountMsat;

  /// The external label or identifier of the [Payment]
  final String? label;

  const SendPaymentRequest({
    required this.bolt11,
    this.amountMsat,
    this.label,
  });

  @override
  int get hashCode => bolt11.hashCode ^ amountMsat.hashCode ^ label.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SendPaymentRequest &&
          runtimeType == other.runtimeType &&
          bolt11 == other.bolt11 &&
          amountMsat == other.amountMsat &&
          label == other.label;
}

/// Represents a send payment response.
class SendPaymentResponse {
  final Payment payment;

  const SendPaymentResponse({
    required this.payment,
  });

  @override
  int get hashCode => payment.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SendPaymentResponse && runtimeType == other.runtimeType && payment == other.payment;
}

/// Represents a send spontaneous payment request.
class SendSpontaneousPaymentRequest {
  /// The node id to send this payment is
  final String nodeId;

  /// The amount in millisatoshis for this payment
  final int amountMsat;
  final List<TlvEntry>? extraTlvs;

  /// The external label or identifier of the [Payment]
  final String? label;

  const SendSpontaneousPaymentRequest({
    required this.nodeId,
    required this.amountMsat,
    this.extraTlvs,
    this.label,
  });

  @override
  int get hashCode => nodeId.hashCode ^ amountMsat.hashCode ^ extraTlvs.hashCode ^ label.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SendSpontaneousPaymentRequest &&
          runtimeType == other.runtimeType &&
          nodeId == other.nodeId &&
          amountMsat == other.amountMsat &&
          extraTlvs == other.extraTlvs &&
          label == other.label;
}

/// Represents a service health check response.
class ServiceHealthCheckResponse {
  final HealthCheckStatus status;

  const ServiceHealthCheckResponse({
    required this.status,
  });

  @override
  int get hashCode => status.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ServiceHealthCheckResponse && runtimeType == other.runtimeType && status == other.status;
}

class StaticBackupRequest {
  final String workingDir;

  const StaticBackupRequest({
    required this.workingDir,
  });

  @override
  int get hashCode => workingDir.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is StaticBackupRequest && runtimeType == other.runtimeType && workingDir == other.workingDir;
}

class StaticBackupResponse {
  final List<String>? backup;

  const StaticBackupResponse({
    this.backup,
  });

  @override
  int get hashCode => backup.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is StaticBackupResponse && runtimeType == other.runtimeType && backup == other.backup;
}

enum SwapAmountType {
  Send,
  Receive,
  ;
}

/// Represents the details of an on-going swap.
///
/// Once this SwapInfo is created it will be monitored on-chain and its state is
/// saved to the persistent storage.
///
/// The SwapInfo has a status which changes accordingly, documented in [SwapStatus].
///
class SwapInfo {
  /// Bitcoin address for this swap. Sats sent to this address will be swapped.
  final String bitcoinAddress;

  /// Relative time lock start, received from [SwapperAPI::create_swap].
  final int createdAt;

  /// Relative time lock for the timeout for the script to be redeemed before swap fails.
  final int lockHeight;

  /// sha256 hash of preimage to used in the claim sript.
  final Uint8List paymentHash;

  /// Secret to claim the swap.
  final Uint8List preimage;

  /// Secret claim key for the bitcoin address.
  final Uint8List privateKey;

  /// Public key in binary format of the private claim private key.
  final Uint8List publicKey;

  /// The public key in binary format from the swapping service. Received from [SwapperAPI::create_swap].
  final Uint8List swapperPublicKey;

  /// The locking script for the generated bitcoin address. Received from [SwapperAPI::create_swap].
  final Uint8List script;

  /// bolt11 invoice to claim the sent funds.
  final String? bolt11;

  /// Amount of millisatoshis claimed from sent funds and paid for via bolt11 invoice.
  final int paidMsat;

  /// Total amount of transactions sent to the swap address.
  final int totalIncomingTxs;

  /// Confirmed onchain sats to be claim with an bolt11 invoice or refunded if swap fails.
  final int confirmedSats;

  /// Unconfirmed sats waiting to be confirmed onchain.
  final int unconfirmedSats;

  /// Shows the current status of the swap, either `Initial` or `Expired`.
  final SwapStatus status;

  /// Transaction IDs for failed swap attempts.
  final List<String> refundTxIds;

  /// Refund transaction IDs for ongoing swap awaiting confirmation.
  final List<String> unconfirmedTxIds;

  /// Transaction IDs that have been confirmed on-chain.
  final List<String> confirmedTxIds;

  /// The minimum amount of sats one can send in order for the swap to succeed. Received from [SwapperAPI::create_swap].
  final int minAllowedDeposit;

  /// The maximum amount of sats one can send in order for the swap to succeed. This is determined based on `max_swapper_payable` and the node's local balance.
  final int maxAllowedDeposit;

  /// The absolute maximum value payable by the swapper. Received from [SwapperAPI::create_swap].
  final int maxSwapperPayable;

  /// Error reason for when swap fails.
  final String? lastRedeemError;

  /// The dynamic fees which is set if a channel opening is needed.
  ///
  /// This is an optional field for backward compatibility with swaps created before dynamic fees.
  ///
  /// Swaps created after dynamic fees were introduced always have this field set.
  final OpeningFeeParams? channelOpeningFees;

  /// The block height when the swap was confirmed.
  final int? confirmedAt;

  const SwapInfo({
    required this.bitcoinAddress,
    required this.createdAt,
    required this.lockHeight,
    required this.paymentHash,
    required this.preimage,
    required this.privateKey,
    required this.publicKey,
    required this.swapperPublicKey,
    required this.script,
    this.bolt11,
    required this.paidMsat,
    required this.totalIncomingTxs,
    required this.confirmedSats,
    required this.unconfirmedSats,
    required this.status,
    required this.refundTxIds,
    required this.unconfirmedTxIds,
    required this.confirmedTxIds,
    required this.minAllowedDeposit,
    required this.maxAllowedDeposit,
    required this.maxSwapperPayable,
    this.lastRedeemError,
    this.channelOpeningFees,
    this.confirmedAt,
  });

  @override
  int get hashCode =>
      bitcoinAddress.hashCode ^
      createdAt.hashCode ^
      lockHeight.hashCode ^
      paymentHash.hashCode ^
      preimage.hashCode ^
      privateKey.hashCode ^
      publicKey.hashCode ^
      swapperPublicKey.hashCode ^
      script.hashCode ^
      bolt11.hashCode ^
      paidMsat.hashCode ^
      totalIncomingTxs.hashCode ^
      confirmedSats.hashCode ^
      unconfirmedSats.hashCode ^
      status.hashCode ^
      refundTxIds.hashCode ^
      unconfirmedTxIds.hashCode ^
      confirmedTxIds.hashCode ^
      minAllowedDeposit.hashCode ^
      maxAllowedDeposit.hashCode ^
      maxSwapperPayable.hashCode ^
      lastRedeemError.hashCode ^
      channelOpeningFees.hashCode ^
      confirmedAt.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SwapInfo &&
          runtimeType == other.runtimeType &&
          bitcoinAddress == other.bitcoinAddress &&
          createdAt == other.createdAt &&
          lockHeight == other.lockHeight &&
          paymentHash == other.paymentHash &&
          preimage == other.preimage &&
          privateKey == other.privateKey &&
          publicKey == other.publicKey &&
          swapperPublicKey == other.swapperPublicKey &&
          script == other.script &&
          bolt11 == other.bolt11 &&
          paidMsat == other.paidMsat &&
          totalIncomingTxs == other.totalIncomingTxs &&
          confirmedSats == other.confirmedSats &&
          unconfirmedSats == other.unconfirmedSats &&
          status == other.status &&
          refundTxIds == other.refundTxIds &&
          unconfirmedTxIds == other.unconfirmedTxIds &&
          confirmedTxIds == other.confirmedTxIds &&
          minAllowedDeposit == other.minAllowedDeposit &&
          maxAllowedDeposit == other.maxAllowedDeposit &&
          maxSwapperPayable == other.maxSwapperPayable &&
          lastRedeemError == other.lastRedeemError &&
          channelOpeningFees == other.channelOpeningFees &&
          confirmedAt == other.confirmedAt;
}

/// The status of a swap
enum SwapStatus {
  /// The swap address has been created and either there aren't any confirmed transactions associated with it
  /// or there are confirmed transactions that are bellow the lock timeout which means the funds are still
  /// eligible to be redeemed normally.
  Initial,
  WaitingConfirmation,
  Redeemable,
  Redeemed,

  /// The swap address has confirmed transactions associated with it and the lock timeout has passed since
  /// the earliest confirmed transaction. This means the only way to spend the funds from this address is by
  /// broadcasting a refund transaction.
  Refundable,
  Completed,
  ;
}

/// Represents a TLV entry for a keysend payment.
class TlvEntry {
  /// The type field for the TLV
  final int fieldNumber;

  /// The value bytes for the TLV
  final Uint8List value;

  const TlvEntry({
    required this.fieldNumber,
    required this.value,
  });

  @override
  int get hashCode => fieldNumber.hashCode ^ value.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is TlvEntry &&
          runtimeType == other.runtimeType &&
          fieldNumber == other.fieldNumber &&
          value == other.value;
}

/// UTXO known to the LN node
class UnspentTransactionOutput {
  final Uint8List txid;
  final int outnum;
  final int amountMillisatoshi;
  final String address;
  final bool reserved;

  const UnspentTransactionOutput({
    required this.txid,
    required this.outnum,
    required this.amountMillisatoshi,
    required this.address,
    required this.reserved,
  });

  @override
  int get hashCode =>
      txid.hashCode ^ outnum.hashCode ^ amountMillisatoshi.hashCode ^ address.hashCode ^ reserved.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is UnspentTransactionOutput &&
          runtimeType == other.runtimeType &&
          txid == other.txid &&
          outnum == other.outnum &&
          amountMillisatoshi == other.amountMillisatoshi &&
          address == other.address &&
          reserved == other.reserved;
}
