// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.9.0.

// ignore_for_file: unused_import, unused_element, unnecessary_import, duplicate_ignore, invalid_use_of_internal_member, annotate_overrides, non_constant_identifier_names, curly_braces_in_flow_control_structures, prefer_const_literals_to_create_immutables, unused_field

import 'binding.dart';
import 'breez_services.dart';
import 'chain.dart';
import 'dart:async';
import 'dart:convert';
import 'frb_generated.dart';
import 'frb_generated.io.dart' if (dart.library.js_interop) 'frb_generated.web.dart';
import 'lnurl/pay.dart';
import 'lsp.dart';
import 'models.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

/// Main entrypoint of the Rust API
class BreezSdkBindings
    extends BaseEntrypoint<BreezSdkBindingsApi, BreezSdkBindingsApiImpl, BreezSdkBindingsWire> {
  @internal
  static final instance = BreezSdkBindings._();

  BreezSdkBindings._();

  /// Initialize flutter_rust_bridge
  static Future<void> init({
    BreezSdkBindingsApi? api,
    BaseHandler? handler,
    ExternalLibrary? externalLibrary,
  }) async {
    await instance.initImpl(api: api, handler: handler, externalLibrary: externalLibrary);
  }

  /// Initialize flutter_rust_bridge in mock mode.
  /// No libraries for FFI are loaded.
  static void initMock({required BreezSdkBindingsApi api}) {
    instance.initMockImpl(api: api);
  }

  /// Dispose flutter_rust_bridge
  ///
  /// The call to this function is optional, since flutter_rust_bridge (and everything else)
  /// is automatically disposed when the app stops.
  static void dispose() => instance.disposeImpl();

  @override
  ApiImplConstructor<BreezSdkBindingsApiImpl, BreezSdkBindingsWire> get apiImplConstructor =>
      BreezSdkBindingsApiImpl.new;

  @override
  WireConstructor<BreezSdkBindingsWire> get wireConstructor => BreezSdkBindingsWire.fromExternalLibrary;

  @override
  Future<void> executeRustInitializers() async {}

  @override
  ExternalLibraryLoaderConfig get defaultExternalLibraryLoaderConfig => kDefaultExternalLibraryLoaderConfig;

  @override
  String get codegenVersion => '2.9.0';

  @override
  int get rustContentHash => -1202170102;

  static const kDefaultExternalLibraryLoaderConfig = ExternalLibraryLoaderConfig(
    stem: 'breez_sdk_core',
    ioDirectory: '../sdk-core/target/release/',
    webPrefix: 'pkg/',
  );
}

abstract class BreezSdkBindingsApi extends BaseApi {
  Future<void> crateBindingBackup();

  Future<BackupStatus> crateBindingBackupStatus();

  Future<void> crateBindingBindingEventListenerOnEvent({
    required BindingEventListener that,
    required BreezEvent e,
  });

  Stream<BreezEvent> crateBindingBreezEventsStream();

  Stream<LogEntry> crateBindingBreezLogStream({LevelFilter? filterLevel});

  Future<BuyBitcoinResponse> crateBindingBuyBitcoin({required BuyBitcoinRequest req});

  Future<CheckMessageResponse> crateBindingCheckMessage({required CheckMessageRequest req});

  Future<void> crateBindingClaimReverseSwap({required String lockupAddress});

  Future<void> crateBindingCloseLspChannels();

  Future<void> crateBindingConfigureNode({required ConfigureNodeRequest req});

  Future<void> crateBindingConnect({required ConnectRequest req});

  Future<void> crateBindingConnectLsp({required String lspId});

  Future<Config> crateBindingDefaultConfig({
    required EnvironmentType envType,
    required String apiKey,
    required NodeConfig nodeConfig,
  });

  Future<void> crateBindingDisconnect();

  Future<String> crateBindingExecuteCommand({required String command});

  Future<List<Rate>> crateBindingFetchFiatRates();

  Future<LspInformation?> crateBindingFetchLspInfo({required String id});

  Future<ReverseSwapPairInfo> crateBindingFetchReverseSwapFees({required ReverseSwapFeesRequest req});

  Future<String> crateBindingGenerateDiagnosticData();

  Future<List<ReverseSwapInfo>> crateBindingInProgressOnchainPayments();

  Future<SwapInfo?> crateBindingInProgressSwap();

  Future<bool> crateBindingIsInitialized();

  Future<List<FiatCurrency>> crateBindingListFiatCurrencies();

  Future<List<LspInformation>> crateBindingListLsps();

  Future<List<Payment>> crateBindingListPayments({required ListPaymentsRequest req});

  Future<List<SwapInfo>> crateBindingListRefundables();

  Future<List<SwapInfo>> crateBindingListSwaps({required ListSwapsRequest req});

  Future<LnUrlCallbackStatus> crateBindingLnurlAuth({required LnUrlAuthRequestData reqData});

  Future<LnUrlPayResult> crateBindingLnurlPay({required LnUrlPayRequest req});

  Future<LnUrlWithdrawResult> crateBindingLnurlWithdraw({required LnUrlWithdrawRequest req});

  Future<String?> crateBindingLspId();

  Future<LspInformation> crateBindingLspInfo();

  Future<Uint8List> crateBindingMnemonicToSeed({required String phrase});

  Future<NodeCredentials?> crateBindingNodeCredentials();

  Future<NodeState> crateBindingNodeInfo();

  Future<OnchainPaymentLimitsResponse> crateBindingOnchainPaymentLimits();

  Future<OpenChannelFeeResponse> crateBindingOpenChannelFee({required OpenChannelFeeRequest req});

  Future<InputType> crateBindingParseInput({required String input});

  Future<LNInvoice> crateBindingParseInvoice({required String invoice});

  Future<PayOnchainResponse> crateBindingPayOnchain({required PayOnchainRequest req});

  Future<Payment?> crateBindingPaymentByHash({required String hash});

  Future<PrepareOnchainPaymentResponse> crateBindingPrepareOnchainPayment({
    required PrepareOnchainPaymentRequest req,
  });

  Future<PrepareRedeemOnchainFundsResponse> crateBindingPrepareRedeemOnchainFunds({
    required PrepareRedeemOnchainFundsRequest req,
  });

  Future<PrepareRefundResponse> crateBindingPrepareRefund({required PrepareRefundRequest req});

  Future<SwapInfo> crateBindingReceiveOnchain({required ReceiveOnchainRequest req});

  Future<ReceivePaymentResponse> crateBindingReceivePayment({required ReceivePaymentRequest req});

  Future<RecommendedFees> crateBindingRecommendedFees();

  Future<RedeemOnchainFundsResponse> crateBindingRedeemOnchainFunds({required RedeemOnchainFundsRequest req});

  Future<void> crateBindingRedeemSwap({required String swapAddress});

  Future<RefundResponse> crateBindingRefund({required RefundRequest req});

  Future<void> crateBindingRegisterWebhook({required String webhookUrl});

  Future<void> crateBindingReportIssue({required ReportIssueRequest req});

  Future<void> crateBindingRescanSwaps();

  Future<SendPaymentResponse> crateBindingSendPayment({required SendPaymentRequest req});

  Future<SendPaymentResponse> crateBindingSendSpontaneousPayment({
    required SendSpontaneousPaymentRequest req,
  });

  Future<ServiceHealthCheckResponse> crateBindingServiceHealthCheck({required String apiKey});

  Future<void> crateBindingSetPaymentMetadata({required String hash, required String metadata});

  Future<SignMessageResponse> crateBindingSignMessage({required SignMessageRequest req});

  Future<StaticBackupResponse> crateBindingStaticBackup({required StaticBackupRequest req});

  Future<void> crateBindingSync();

  Future<void> crateBindingUnregisterWebhook({required String webhookUrl});
}

class BreezSdkBindingsApiImpl extends BreezSdkBindingsApiImplPlatform implements BreezSdkBindingsApi {
  BreezSdkBindingsApiImpl({
    required super.handler,
    required super.wire,
    required super.generalizedFrbRustBinding,
    required super.portManager,
  });

  @override
  Future<void> crateBindingBackup() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          return wire.wire__crate__binding__backup(port_);
        },
        codec: DcoCodec(decodeSuccessData: dco_decode_unit, decodeErrorData: dco_decode_AnyhowException),
        constMeta: kCrateBindingBackupConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateBindingBackupConstMeta => const TaskConstMeta(debugName: "backup", argNames: []);

  @override
  Future<BackupStatus> crateBindingBackupStatus() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          return wire.wire__crate__binding__backup_status(port_);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_backup_status,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateBindingBackupStatusConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateBindingBackupStatusConstMeta =>
      const TaskConstMeta(debugName: "backup_status", argNames: []);

  @override
  Future<void> crateBindingBindingEventListenerOnEvent({
    required BindingEventListener that,
    required BreezEvent e,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 = cst_encode_box_autoadd_binding_event_listener(that);
          var arg1 = cst_encode_box_autoadd_breez_event(e);
          return wire.wire__crate__binding__binding_event_listener_on_event(port_, arg0, arg1);
        },
        codec: DcoCodec(decodeSuccessData: dco_decode_unit, decodeErrorData: null),
        constMeta: kCrateBindingBindingEventListenerOnEventConstMeta,
        argValues: [that, e],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateBindingBindingEventListenerOnEventConstMeta =>
      const TaskConstMeta(debugName: "binding_event_listener_on_event", argNames: ["that", "e"]);

  @override
  Stream<BreezEvent> crateBindingBreezEventsStream() {
    final s = RustStreamSink<BreezEvent>();
    unawaited(
      handler.executeNormal(
        NormalTask(
          callFfi: (port_) {
            var arg0 = cst_encode_StreamSink_breez_event_Dco(s);
            return wire.wire__crate__binding__breez_events_stream(port_, arg0);
          },
          codec: DcoCodec(decodeSuccessData: dco_decode_unit, decodeErrorData: dco_decode_AnyhowException),
          constMeta: kCrateBindingBreezEventsStreamConstMeta,
          argValues: [s],
          apiImpl: this,
        ),
      ),
    );
    return s.stream;
  }

  TaskConstMeta get kCrateBindingBreezEventsStreamConstMeta =>
      const TaskConstMeta(debugName: "breez_events_stream", argNames: ["s"]);

  @override
  Stream<LogEntry> crateBindingBreezLogStream({LevelFilter? filterLevel}) {
    final s = RustStreamSink<LogEntry>();
    unawaited(
      handler.executeNormal(
        NormalTask(
          callFfi: (port_) {
            var arg0 = cst_encode_StreamSink_log_entry_Dco(s);
            var arg1 = cst_encode_opt_box_autoadd_level_filter(filterLevel);
            return wire.wire__crate__binding__breez_log_stream(port_, arg0, arg1);
          },
          codec: DcoCodec(decodeSuccessData: dco_decode_unit, decodeErrorData: dco_decode_AnyhowException),
          constMeta: kCrateBindingBreezLogStreamConstMeta,
          argValues: [s, filterLevel],
          apiImpl: this,
        ),
      ),
    );
    return s.stream;
  }

  TaskConstMeta get kCrateBindingBreezLogStreamConstMeta =>
      const TaskConstMeta(debugName: "breez_log_stream", argNames: ["s", "filterLevel"]);

  @override
  Future<BuyBitcoinResponse> crateBindingBuyBitcoin({required BuyBitcoinRequest req}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 = cst_encode_box_autoadd_buy_bitcoin_request(req);
          return wire.wire__crate__binding__buy_bitcoin(port_, arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_buy_bitcoin_response,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateBindingBuyBitcoinConstMeta,
        argValues: [req],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateBindingBuyBitcoinConstMeta =>
      const TaskConstMeta(debugName: "buy_bitcoin", argNames: ["req"]);

  @override
  Future<CheckMessageResponse> crateBindingCheckMessage({required CheckMessageRequest req}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 = cst_encode_box_autoadd_check_message_request(req);
          return wire.wire__crate__binding__check_message(port_, arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_check_message_response,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateBindingCheckMessageConstMeta,
        argValues: [req],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateBindingCheckMessageConstMeta =>
      const TaskConstMeta(debugName: "check_message", argNames: ["req"]);

  @override
  Future<void> crateBindingClaimReverseSwap({required String lockupAddress}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 = cst_encode_String(lockupAddress);
          return wire.wire__crate__binding__claim_reverse_swap(port_, arg0);
        },
        codec: DcoCodec(decodeSuccessData: dco_decode_unit, decodeErrorData: dco_decode_AnyhowException),
        constMeta: kCrateBindingClaimReverseSwapConstMeta,
        argValues: [lockupAddress],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateBindingClaimReverseSwapConstMeta =>
      const TaskConstMeta(debugName: "claim_reverse_swap", argNames: ["lockupAddress"]);

  @override
  Future<void> crateBindingCloseLspChannels() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          return wire.wire__crate__binding__close_lsp_channels(port_);
        },
        codec: DcoCodec(decodeSuccessData: dco_decode_unit, decodeErrorData: dco_decode_AnyhowException),
        constMeta: kCrateBindingCloseLspChannelsConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateBindingCloseLspChannelsConstMeta =>
      const TaskConstMeta(debugName: "close_lsp_channels", argNames: []);

  @override
  Future<void> crateBindingConfigureNode({required ConfigureNodeRequest req}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 = cst_encode_box_autoadd_configure_node_request(req);
          return wire.wire__crate__binding__configure_node(port_, arg0);
        },
        codec: DcoCodec(decodeSuccessData: dco_decode_unit, decodeErrorData: dco_decode_AnyhowException),
        constMeta: kCrateBindingConfigureNodeConstMeta,
        argValues: [req],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateBindingConfigureNodeConstMeta =>
      const TaskConstMeta(debugName: "configure_node", argNames: ["req"]);

  @override
  Future<void> crateBindingConnect({required ConnectRequest req}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 = cst_encode_box_autoadd_connect_request(req);
          return wire.wire__crate__binding__connect(port_, arg0);
        },
        codec: DcoCodec(decodeSuccessData: dco_decode_unit, decodeErrorData: dco_decode_AnyhowException),
        constMeta: kCrateBindingConnectConstMeta,
        argValues: [req],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateBindingConnectConstMeta =>
      const TaskConstMeta(debugName: "connect", argNames: ["req"]);

  @override
  Future<void> crateBindingConnectLsp({required String lspId}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 = cst_encode_String(lspId);
          return wire.wire__crate__binding__connect_lsp(port_, arg0);
        },
        codec: DcoCodec(decodeSuccessData: dco_decode_unit, decodeErrorData: dco_decode_AnyhowException),
        constMeta: kCrateBindingConnectLspConstMeta,
        argValues: [lspId],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateBindingConnectLspConstMeta =>
      const TaskConstMeta(debugName: "connect_lsp", argNames: ["lspId"]);

  @override
  Future<Config> crateBindingDefaultConfig({
    required EnvironmentType envType,
    required String apiKey,
    required NodeConfig nodeConfig,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 = cst_encode_environment_type(envType);
          var arg1 = cst_encode_String(apiKey);
          var arg2 = cst_encode_box_autoadd_node_config(nodeConfig);
          return wire.wire__crate__binding__default_config(port_, arg0, arg1, arg2);
        },
        codec: DcoCodec(decodeSuccessData: dco_decode_config, decodeErrorData: null),
        constMeta: kCrateBindingDefaultConfigConstMeta,
        argValues: [envType, apiKey, nodeConfig],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateBindingDefaultConfigConstMeta =>
      const TaskConstMeta(debugName: "default_config", argNames: ["envType", "apiKey", "nodeConfig"]);

  @override
  Future<void> crateBindingDisconnect() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          return wire.wire__crate__binding__disconnect(port_);
        },
        codec: DcoCodec(decodeSuccessData: dco_decode_unit, decodeErrorData: dco_decode_AnyhowException),
        constMeta: kCrateBindingDisconnectConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateBindingDisconnectConstMeta =>
      const TaskConstMeta(debugName: "disconnect", argNames: []);

  @override
  Future<String> crateBindingExecuteCommand({required String command}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 = cst_encode_String(command);
          return wire.wire__crate__binding__execute_command(port_, arg0);
        },
        codec: DcoCodec(decodeSuccessData: dco_decode_String, decodeErrorData: dco_decode_AnyhowException),
        constMeta: kCrateBindingExecuteCommandConstMeta,
        argValues: [command],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateBindingExecuteCommandConstMeta =>
      const TaskConstMeta(debugName: "execute_command", argNames: ["command"]);

  @override
  Future<List<Rate>> crateBindingFetchFiatRates() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          return wire.wire__crate__binding__fetch_fiat_rates(port_);
        },
        codec: DcoCodec(decodeSuccessData: dco_decode_list_rate, decodeErrorData: dco_decode_AnyhowException),
        constMeta: kCrateBindingFetchFiatRatesConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateBindingFetchFiatRatesConstMeta =>
      const TaskConstMeta(debugName: "fetch_fiat_rates", argNames: []);

  @override
  Future<LspInformation?> crateBindingFetchLspInfo({required String id}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 = cst_encode_String(id);
          return wire.wire__crate__binding__fetch_lsp_info(port_, arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_opt_box_autoadd_lsp_information,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateBindingFetchLspInfoConstMeta,
        argValues: [id],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateBindingFetchLspInfoConstMeta =>
      const TaskConstMeta(debugName: "fetch_lsp_info", argNames: ["id"]);

  @override
  Future<ReverseSwapPairInfo> crateBindingFetchReverseSwapFees({required ReverseSwapFeesRequest req}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 = cst_encode_box_autoadd_reverse_swap_fees_request(req);
          return wire.wire__crate__binding__fetch_reverse_swap_fees(port_, arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_reverse_swap_pair_info,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateBindingFetchReverseSwapFeesConstMeta,
        argValues: [req],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateBindingFetchReverseSwapFeesConstMeta =>
      const TaskConstMeta(debugName: "fetch_reverse_swap_fees", argNames: ["req"]);

  @override
  Future<String> crateBindingGenerateDiagnosticData() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          return wire.wire__crate__binding__generate_diagnostic_data(port_);
        },
        codec: DcoCodec(decodeSuccessData: dco_decode_String, decodeErrorData: dco_decode_AnyhowException),
        constMeta: kCrateBindingGenerateDiagnosticDataConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateBindingGenerateDiagnosticDataConstMeta =>
      const TaskConstMeta(debugName: "generate_diagnostic_data", argNames: []);

  @override
  Future<List<ReverseSwapInfo>> crateBindingInProgressOnchainPayments() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          return wire.wire__crate__binding__in_progress_onchain_payments(port_);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_list_reverse_swap_info,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateBindingInProgressOnchainPaymentsConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateBindingInProgressOnchainPaymentsConstMeta =>
      const TaskConstMeta(debugName: "in_progress_onchain_payments", argNames: []);

  @override
  Future<SwapInfo?> crateBindingInProgressSwap() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          return wire.wire__crate__binding__in_progress_swap(port_);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_opt_box_autoadd_swap_info,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateBindingInProgressSwapConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateBindingInProgressSwapConstMeta =>
      const TaskConstMeta(debugName: "in_progress_swap", argNames: []);

  @override
  Future<bool> crateBindingIsInitialized() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          return wire.wire__crate__binding__is_initialized(port_);
        },
        codec: DcoCodec(decodeSuccessData: dco_decode_bool, decodeErrorData: null),
        constMeta: kCrateBindingIsInitializedConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateBindingIsInitializedConstMeta =>
      const TaskConstMeta(debugName: "is_initialized", argNames: []);

  @override
  Future<List<FiatCurrency>> crateBindingListFiatCurrencies() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          return wire.wire__crate__binding__list_fiat_currencies(port_);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_list_fiat_currency,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateBindingListFiatCurrenciesConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateBindingListFiatCurrenciesConstMeta =>
      const TaskConstMeta(debugName: "list_fiat_currencies", argNames: []);

  @override
  Future<List<LspInformation>> crateBindingListLsps() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          return wire.wire__crate__binding__list_lsps(port_);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_list_lsp_information,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateBindingListLspsConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateBindingListLspsConstMeta =>
      const TaskConstMeta(debugName: "list_lsps", argNames: []);

  @override
  Future<List<Payment>> crateBindingListPayments({required ListPaymentsRequest req}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 = cst_encode_box_autoadd_list_payments_request(req);
          return wire.wire__crate__binding__list_payments(port_, arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_list_payment,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateBindingListPaymentsConstMeta,
        argValues: [req],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateBindingListPaymentsConstMeta =>
      const TaskConstMeta(debugName: "list_payments", argNames: ["req"]);

  @override
  Future<List<SwapInfo>> crateBindingListRefundables() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          return wire.wire__crate__binding__list_refundables(port_);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_list_swap_info,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateBindingListRefundablesConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateBindingListRefundablesConstMeta =>
      const TaskConstMeta(debugName: "list_refundables", argNames: []);

  @override
  Future<List<SwapInfo>> crateBindingListSwaps({required ListSwapsRequest req}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 = cst_encode_box_autoadd_list_swaps_request(req);
          return wire.wire__crate__binding__list_swaps(port_, arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_list_swap_info,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateBindingListSwapsConstMeta,
        argValues: [req],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateBindingListSwapsConstMeta =>
      const TaskConstMeta(debugName: "list_swaps", argNames: ["req"]);

  @override
  Future<LnUrlCallbackStatus> crateBindingLnurlAuth({required LnUrlAuthRequestData reqData}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 = cst_encode_box_autoadd_ln_url_auth_request_data(reqData);
          return wire.wire__crate__binding__lnurl_auth(port_, arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_ln_url_callback_status,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateBindingLnurlAuthConstMeta,
        argValues: [reqData],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateBindingLnurlAuthConstMeta =>
      const TaskConstMeta(debugName: "lnurl_auth", argNames: ["reqData"]);

  @override
  Future<LnUrlPayResult> crateBindingLnurlPay({required LnUrlPayRequest req}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 = cst_encode_box_autoadd_ln_url_pay_request(req);
          return wire.wire__crate__binding__lnurl_pay(port_, arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_ln_url_pay_result,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateBindingLnurlPayConstMeta,
        argValues: [req],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateBindingLnurlPayConstMeta =>
      const TaskConstMeta(debugName: "lnurl_pay", argNames: ["req"]);

  @override
  Future<LnUrlWithdrawResult> crateBindingLnurlWithdraw({required LnUrlWithdrawRequest req}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 = cst_encode_box_autoadd_ln_url_withdraw_request(req);
          return wire.wire__crate__binding__lnurl_withdraw(port_, arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_ln_url_withdraw_result,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateBindingLnurlWithdrawConstMeta,
        argValues: [req],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateBindingLnurlWithdrawConstMeta =>
      const TaskConstMeta(debugName: "lnurl_withdraw", argNames: ["req"]);

  @override
  Future<String?> crateBindingLspId() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          return wire.wire__crate__binding__lsp_id(port_);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_opt_String,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateBindingLspIdConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateBindingLspIdConstMeta => const TaskConstMeta(debugName: "lsp_id", argNames: []);

  @override
  Future<LspInformation> crateBindingLspInfo() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          return wire.wire__crate__binding__lsp_info(port_);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_lsp_information,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateBindingLspInfoConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateBindingLspInfoConstMeta => const TaskConstMeta(debugName: "lsp_info", argNames: []);

  @override
  Future<Uint8List> crateBindingMnemonicToSeed({required String phrase}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 = cst_encode_String(phrase);
          return wire.wire__crate__binding__mnemonic_to_seed(port_, arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_list_prim_u_8_strict,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateBindingMnemonicToSeedConstMeta,
        argValues: [phrase],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateBindingMnemonicToSeedConstMeta =>
      const TaskConstMeta(debugName: "mnemonic_to_seed", argNames: ["phrase"]);

  @override
  Future<NodeCredentials?> crateBindingNodeCredentials() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          return wire.wire__crate__binding__node_credentials(port_);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_opt_box_autoadd_node_credentials,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateBindingNodeCredentialsConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateBindingNodeCredentialsConstMeta =>
      const TaskConstMeta(debugName: "node_credentials", argNames: []);

  @override
  Future<NodeState> crateBindingNodeInfo() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          return wire.wire__crate__binding__node_info(port_);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_node_state,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateBindingNodeInfoConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateBindingNodeInfoConstMeta =>
      const TaskConstMeta(debugName: "node_info", argNames: []);

  @override
  Future<OnchainPaymentLimitsResponse> crateBindingOnchainPaymentLimits() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          return wire.wire__crate__binding__onchain_payment_limits(port_);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_onchain_payment_limits_response,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateBindingOnchainPaymentLimitsConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateBindingOnchainPaymentLimitsConstMeta =>
      const TaskConstMeta(debugName: "onchain_payment_limits", argNames: []);

  @override
  Future<OpenChannelFeeResponse> crateBindingOpenChannelFee({required OpenChannelFeeRequest req}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 = cst_encode_box_autoadd_open_channel_fee_request(req);
          return wire.wire__crate__binding__open_channel_fee(port_, arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_open_channel_fee_response,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateBindingOpenChannelFeeConstMeta,
        argValues: [req],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateBindingOpenChannelFeeConstMeta =>
      const TaskConstMeta(debugName: "open_channel_fee", argNames: ["req"]);

  @override
  Future<InputType> crateBindingParseInput({required String input}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 = cst_encode_String(input);
          return wire.wire__crate__binding__parse_input(port_, arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_input_type,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateBindingParseInputConstMeta,
        argValues: [input],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateBindingParseInputConstMeta =>
      const TaskConstMeta(debugName: "parse_input", argNames: ["input"]);

  @override
  Future<LNInvoice> crateBindingParseInvoice({required String invoice}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 = cst_encode_String(invoice);
          return wire.wire__crate__binding__parse_invoice(port_, arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_ln_invoice,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateBindingParseInvoiceConstMeta,
        argValues: [invoice],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateBindingParseInvoiceConstMeta =>
      const TaskConstMeta(debugName: "parse_invoice", argNames: ["invoice"]);

  @override
  Future<PayOnchainResponse> crateBindingPayOnchain({required PayOnchainRequest req}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 = cst_encode_box_autoadd_pay_onchain_request(req);
          return wire.wire__crate__binding__pay_onchain(port_, arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_pay_onchain_response,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateBindingPayOnchainConstMeta,
        argValues: [req],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateBindingPayOnchainConstMeta =>
      const TaskConstMeta(debugName: "pay_onchain", argNames: ["req"]);

  @override
  Future<Payment?> crateBindingPaymentByHash({required String hash}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 = cst_encode_String(hash);
          return wire.wire__crate__binding__payment_by_hash(port_, arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_opt_box_autoadd_payment,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateBindingPaymentByHashConstMeta,
        argValues: [hash],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateBindingPaymentByHashConstMeta =>
      const TaskConstMeta(debugName: "payment_by_hash", argNames: ["hash"]);

  @override
  Future<PrepareOnchainPaymentResponse> crateBindingPrepareOnchainPayment({
    required PrepareOnchainPaymentRequest req,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 = cst_encode_box_autoadd_prepare_onchain_payment_request(req);
          return wire.wire__crate__binding__prepare_onchain_payment(port_, arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_prepare_onchain_payment_response,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateBindingPrepareOnchainPaymentConstMeta,
        argValues: [req],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateBindingPrepareOnchainPaymentConstMeta =>
      const TaskConstMeta(debugName: "prepare_onchain_payment", argNames: ["req"]);

  @override
  Future<PrepareRedeemOnchainFundsResponse> crateBindingPrepareRedeemOnchainFunds({
    required PrepareRedeemOnchainFundsRequest req,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 = cst_encode_box_autoadd_prepare_redeem_onchain_funds_request(req);
          return wire.wire__crate__binding__prepare_redeem_onchain_funds(port_, arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_prepare_redeem_onchain_funds_response,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateBindingPrepareRedeemOnchainFundsConstMeta,
        argValues: [req],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateBindingPrepareRedeemOnchainFundsConstMeta =>
      const TaskConstMeta(debugName: "prepare_redeem_onchain_funds", argNames: ["req"]);

  @override
  Future<PrepareRefundResponse> crateBindingPrepareRefund({required PrepareRefundRequest req}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 = cst_encode_box_autoadd_prepare_refund_request(req);
          return wire.wire__crate__binding__prepare_refund(port_, arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_prepare_refund_response,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateBindingPrepareRefundConstMeta,
        argValues: [req],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateBindingPrepareRefundConstMeta =>
      const TaskConstMeta(debugName: "prepare_refund", argNames: ["req"]);

  @override
  Future<SwapInfo> crateBindingReceiveOnchain({required ReceiveOnchainRequest req}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 = cst_encode_box_autoadd_receive_onchain_request(req);
          return wire.wire__crate__binding__receive_onchain(port_, arg0);
        },
        codec: DcoCodec(decodeSuccessData: dco_decode_swap_info, decodeErrorData: dco_decode_AnyhowException),
        constMeta: kCrateBindingReceiveOnchainConstMeta,
        argValues: [req],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateBindingReceiveOnchainConstMeta =>
      const TaskConstMeta(debugName: "receive_onchain", argNames: ["req"]);

  @override
  Future<ReceivePaymentResponse> crateBindingReceivePayment({required ReceivePaymentRequest req}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 = cst_encode_box_autoadd_receive_payment_request(req);
          return wire.wire__crate__binding__receive_payment(port_, arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_receive_payment_response,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateBindingReceivePaymentConstMeta,
        argValues: [req],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateBindingReceivePaymentConstMeta =>
      const TaskConstMeta(debugName: "receive_payment", argNames: ["req"]);

  @override
  Future<RecommendedFees> crateBindingRecommendedFees() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          return wire.wire__crate__binding__recommended_fees(port_);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_recommended_fees,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateBindingRecommendedFeesConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateBindingRecommendedFeesConstMeta =>
      const TaskConstMeta(debugName: "recommended_fees", argNames: []);

  @override
  Future<RedeemOnchainFundsResponse> crateBindingRedeemOnchainFunds({
    required RedeemOnchainFundsRequest req,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 = cst_encode_box_autoadd_redeem_onchain_funds_request(req);
          return wire.wire__crate__binding__redeem_onchain_funds(port_, arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_redeem_onchain_funds_response,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateBindingRedeemOnchainFundsConstMeta,
        argValues: [req],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateBindingRedeemOnchainFundsConstMeta =>
      const TaskConstMeta(debugName: "redeem_onchain_funds", argNames: ["req"]);

  @override
  Future<void> crateBindingRedeemSwap({required String swapAddress}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 = cst_encode_String(swapAddress);
          return wire.wire__crate__binding__redeem_swap(port_, arg0);
        },
        codec: DcoCodec(decodeSuccessData: dco_decode_unit, decodeErrorData: dco_decode_AnyhowException),
        constMeta: kCrateBindingRedeemSwapConstMeta,
        argValues: [swapAddress],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateBindingRedeemSwapConstMeta =>
      const TaskConstMeta(debugName: "redeem_swap", argNames: ["swapAddress"]);

  @override
  Future<RefundResponse> crateBindingRefund({required RefundRequest req}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 = cst_encode_box_autoadd_refund_request(req);
          return wire.wire__crate__binding__refund(port_, arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_refund_response,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateBindingRefundConstMeta,
        argValues: [req],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateBindingRefundConstMeta =>
      const TaskConstMeta(debugName: "refund", argNames: ["req"]);

  @override
  Future<void> crateBindingRegisterWebhook({required String webhookUrl}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 = cst_encode_String(webhookUrl);
          return wire.wire__crate__binding__register_webhook(port_, arg0);
        },
        codec: DcoCodec(decodeSuccessData: dco_decode_unit, decodeErrorData: dco_decode_AnyhowException),
        constMeta: kCrateBindingRegisterWebhookConstMeta,
        argValues: [webhookUrl],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateBindingRegisterWebhookConstMeta =>
      const TaskConstMeta(debugName: "register_webhook", argNames: ["webhookUrl"]);

  @override
  Future<void> crateBindingReportIssue({required ReportIssueRequest req}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 = cst_encode_box_autoadd_report_issue_request(req);
          return wire.wire__crate__binding__report_issue(port_, arg0);
        },
        codec: DcoCodec(decodeSuccessData: dco_decode_unit, decodeErrorData: dco_decode_AnyhowException),
        constMeta: kCrateBindingReportIssueConstMeta,
        argValues: [req],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateBindingReportIssueConstMeta =>
      const TaskConstMeta(debugName: "report_issue", argNames: ["req"]);

  @override
  Future<void> crateBindingRescanSwaps() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          return wire.wire__crate__binding__rescan_swaps(port_);
        },
        codec: DcoCodec(decodeSuccessData: dco_decode_unit, decodeErrorData: dco_decode_AnyhowException),
        constMeta: kCrateBindingRescanSwapsConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateBindingRescanSwapsConstMeta =>
      const TaskConstMeta(debugName: "rescan_swaps", argNames: []);

  @override
  Future<SendPaymentResponse> crateBindingSendPayment({required SendPaymentRequest req}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 = cst_encode_box_autoadd_send_payment_request(req);
          return wire.wire__crate__binding__send_payment(port_, arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_send_payment_response,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateBindingSendPaymentConstMeta,
        argValues: [req],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateBindingSendPaymentConstMeta =>
      const TaskConstMeta(debugName: "send_payment", argNames: ["req"]);

  @override
  Future<SendPaymentResponse> crateBindingSendSpontaneousPayment({
    required SendSpontaneousPaymentRequest req,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 = cst_encode_box_autoadd_send_spontaneous_payment_request(req);
          return wire.wire__crate__binding__send_spontaneous_payment(port_, arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_send_payment_response,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateBindingSendSpontaneousPaymentConstMeta,
        argValues: [req],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateBindingSendSpontaneousPaymentConstMeta =>
      const TaskConstMeta(debugName: "send_spontaneous_payment", argNames: ["req"]);

  @override
  Future<ServiceHealthCheckResponse> crateBindingServiceHealthCheck({required String apiKey}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 = cst_encode_String(apiKey);
          return wire.wire__crate__binding__service_health_check(port_, arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_service_health_check_response,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateBindingServiceHealthCheckConstMeta,
        argValues: [apiKey],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateBindingServiceHealthCheckConstMeta =>
      const TaskConstMeta(debugName: "service_health_check", argNames: ["apiKey"]);

  @override
  Future<void> crateBindingSetPaymentMetadata({required String hash, required String metadata}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 = cst_encode_String(hash);
          var arg1 = cst_encode_String(metadata);
          return wire.wire__crate__binding__set_payment_metadata(port_, arg0, arg1);
        },
        codec: DcoCodec(decodeSuccessData: dco_decode_unit, decodeErrorData: dco_decode_AnyhowException),
        constMeta: kCrateBindingSetPaymentMetadataConstMeta,
        argValues: [hash, metadata],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateBindingSetPaymentMetadataConstMeta =>
      const TaskConstMeta(debugName: "set_payment_metadata", argNames: ["hash", "metadata"]);

  @override
  Future<SignMessageResponse> crateBindingSignMessage({required SignMessageRequest req}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 = cst_encode_box_autoadd_sign_message_request(req);
          return wire.wire__crate__binding__sign_message(port_, arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_sign_message_response,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateBindingSignMessageConstMeta,
        argValues: [req],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateBindingSignMessageConstMeta =>
      const TaskConstMeta(debugName: "sign_message", argNames: ["req"]);

  @override
  Future<StaticBackupResponse> crateBindingStaticBackup({required StaticBackupRequest req}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 = cst_encode_box_autoadd_static_backup_request(req);
          return wire.wire__crate__binding__static_backup(port_, arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_static_backup_response,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateBindingStaticBackupConstMeta,
        argValues: [req],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateBindingStaticBackupConstMeta =>
      const TaskConstMeta(debugName: "static_backup", argNames: ["req"]);

  @override
  Future<void> crateBindingSync() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          return wire.wire__crate__binding__sync(port_);
        },
        codec: DcoCodec(decodeSuccessData: dco_decode_unit, decodeErrorData: dco_decode_AnyhowException),
        constMeta: kCrateBindingSyncConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateBindingSyncConstMeta =>
      const TaskConstMeta(debugName: "sync(dart_style=sync)", argNames: []);

  @override
  Future<void> crateBindingUnregisterWebhook({required String webhookUrl}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 = cst_encode_String(webhookUrl);
          return wire.wire__crate__binding__unregister_webhook(port_, arg0);
        },
        codec: DcoCodec(decodeSuccessData: dco_decode_unit, decodeErrorData: dco_decode_AnyhowException),
        constMeta: kCrateBindingUnregisterWebhookConstMeta,
        argValues: [webhookUrl],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateBindingUnregisterWebhookConstMeta =>
      const TaskConstMeta(debugName: "unregister_webhook", argNames: ["webhookUrl"]);

  @protected
  AnyhowException dco_decode_AnyhowException(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AnyhowException(raw as String);
  }

  @protected
  RustStreamSink<BreezEvent> dco_decode_StreamSink_breez_event_Dco(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    throw UnimplementedError();
  }

  @protected
  RustStreamSink<LogEntry> dco_decode_StreamSink_log_entry_Dco(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    throw UnimplementedError();
  }

  @protected
  String dco_decode_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as String;
  }

  @protected
  AesSuccessActionDataDecrypted dco_decode_aes_success_action_data_decrypted(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return AesSuccessActionDataDecrypted(
      description: dco_decode_String(arr[0]),
      plaintext: dco_decode_String(arr[1]),
    );
  }

  @protected
  AesSuccessActionDataResult dco_decode_aes_success_action_data_result(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return AesSuccessActionDataResult_Decrypted(
          data: dco_decode_box_autoadd_aes_success_action_data_decrypted(raw[1]),
        );
      case 1:
        return AesSuccessActionDataResult_ErrorStatus(reason: dco_decode_String(raw[1]));
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  BackupFailedData dco_decode_backup_failed_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1) throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return BackupFailedData(error: dco_decode_String(arr[0]));
  }

  @protected
  BackupStatus dco_decode_backup_status(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return BackupStatus(
      backedUp: dco_decode_bool(arr[0]),
      lastBackupTime: dco_decode_opt_box_autoadd_u_64(arr[1]),
    );
  }

  @protected
  BindingEventListener dco_decode_binding_event_listener(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 0) throw Exception('unexpected arr length: expect 0 but see ${arr.length}');
    return BindingEventListener();
  }

  @protected
  BitcoinAddressData dco_decode_bitcoin_address_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 5) throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
    return BitcoinAddressData(
      address: dco_decode_String(arr[0]),
      network: dco_decode_network(arr[1]),
      amountSat: dco_decode_opt_box_autoadd_u_64(arr[2]),
      label: dco_decode_opt_String(arr[3]),
      message: dco_decode_opt_String(arr[4]),
    );
  }

  @protected
  bool dco_decode_bool(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as bool;
  }

  @protected
  AesSuccessActionDataDecrypted dco_decode_box_autoadd_aes_success_action_data_decrypted(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_aes_success_action_data_decrypted(raw);
  }

  @protected
  AesSuccessActionDataResult dco_decode_box_autoadd_aes_success_action_data_result(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_aes_success_action_data_result(raw);
  }

  @protected
  BackupFailedData dco_decode_box_autoadd_backup_failed_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_backup_failed_data(raw);
  }

  @protected
  BindingEventListener dco_decode_box_autoadd_binding_event_listener(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_binding_event_listener(raw);
  }

  @protected
  BitcoinAddressData dco_decode_box_autoadd_bitcoin_address_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_bitcoin_address_data(raw);
  }

  @protected
  bool dco_decode_box_autoadd_bool(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as bool;
  }

  @protected
  BreezEvent dco_decode_box_autoadd_breez_event(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_breez_event(raw);
  }

  @protected
  BuyBitcoinRequest dco_decode_box_autoadd_buy_bitcoin_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_buy_bitcoin_request(raw);
  }

  @protected
  CheckMessageRequest dco_decode_box_autoadd_check_message_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_check_message_request(raw);
  }

  @protected
  ClosedChannelPaymentDetails dco_decode_box_autoadd_closed_channel_payment_details(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_closed_channel_payment_details(raw);
  }

  @protected
  ConfigureNodeRequest dco_decode_box_autoadd_configure_node_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_configure_node_request(raw);
  }

  @protected
  ConnectRequest dco_decode_box_autoadd_connect_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_connect_request(raw);
  }

  @protected
  GreenlightCredentials dco_decode_box_autoadd_greenlight_credentials(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_greenlight_credentials(raw);
  }

  @protected
  GreenlightDeviceCredentials dco_decode_box_autoadd_greenlight_device_credentials(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_greenlight_device_credentials(raw);
  }

  @protected
  GreenlightNodeConfig dco_decode_box_autoadd_greenlight_node_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_greenlight_node_config(raw);
  }

  @protected
  PlatformInt64 dco_decode_box_autoadd_i_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_i_64(raw);
  }

  @protected
  InvoicePaidDetails dco_decode_box_autoadd_invoice_paid_details(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_invoice_paid_details(raw);
  }

  @protected
  LevelFilter dco_decode_box_autoadd_level_filter(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_level_filter(raw);
  }

  @protected
  ListPaymentsRequest dco_decode_box_autoadd_list_payments_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_list_payments_request(raw);
  }

  @protected
  ListSwapsRequest dco_decode_box_autoadd_list_swaps_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_list_swaps_request(raw);
  }

  @protected
  LNInvoice dco_decode_box_autoadd_ln_invoice(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ln_invoice(raw);
  }

  @protected
  LnPaymentDetails dco_decode_box_autoadd_ln_payment_details(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ln_payment_details(raw);
  }

  @protected
  LnUrlAuthRequestData dco_decode_box_autoadd_ln_url_auth_request_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ln_url_auth_request_data(raw);
  }

  @protected
  LnUrlErrorData dco_decode_box_autoadd_ln_url_error_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ln_url_error_data(raw);
  }

  @protected
  LnUrlPayErrorData dco_decode_box_autoadd_ln_url_pay_error_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ln_url_pay_error_data(raw);
  }

  @protected
  LnUrlPayRequest dco_decode_box_autoadd_ln_url_pay_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ln_url_pay_request(raw);
  }

  @protected
  LnUrlPayRequestData dco_decode_box_autoadd_ln_url_pay_request_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ln_url_pay_request_data(raw);
  }

  @protected
  LnUrlPaySuccessData dco_decode_box_autoadd_ln_url_pay_success_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ln_url_pay_success_data(raw);
  }

  @protected
  LnUrlWithdrawRequest dco_decode_box_autoadd_ln_url_withdraw_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ln_url_withdraw_request(raw);
  }

  @protected
  LnUrlWithdrawRequestData dco_decode_box_autoadd_ln_url_withdraw_request_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ln_url_withdraw_request_data(raw);
  }

  @protected
  LnUrlWithdrawSuccessData dco_decode_box_autoadd_ln_url_withdraw_success_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ln_url_withdraw_success_data(raw);
  }

  @protected
  LspInformation dco_decode_box_autoadd_lsp_information(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_lsp_information(raw);
  }

  @protected
  MessageSuccessActionData dco_decode_box_autoadd_message_success_action_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_message_success_action_data(raw);
  }

  @protected
  NodeConfig dco_decode_box_autoadd_node_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_node_config(raw);
  }

  @protected
  NodeCredentials dco_decode_box_autoadd_node_credentials(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_node_credentials(raw);
  }

  @protected
  OpenChannelFeeRequest dco_decode_box_autoadd_open_channel_fee_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_open_channel_fee_request(raw);
  }

  @protected
  OpeningFeeParams dco_decode_box_autoadd_opening_fee_params(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_opening_fee_params(raw);
  }

  @protected
  PayOnchainRequest dco_decode_box_autoadd_pay_onchain_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_pay_onchain_request(raw);
  }

  @protected
  Payment dco_decode_box_autoadd_payment(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_payment(raw);
  }

  @protected
  PaymentFailedData dco_decode_box_autoadd_payment_failed_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_payment_failed_data(raw);
  }

  @protected
  PrepareOnchainPaymentRequest dco_decode_box_autoadd_prepare_onchain_payment_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_prepare_onchain_payment_request(raw);
  }

  @protected
  PrepareRedeemOnchainFundsRequest dco_decode_box_autoadd_prepare_redeem_onchain_funds_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_prepare_redeem_onchain_funds_request(raw);
  }

  @protected
  PrepareRefundRequest dco_decode_box_autoadd_prepare_refund_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_prepare_refund_request(raw);
  }

  @protected
  ReceiveOnchainRequest dco_decode_box_autoadd_receive_onchain_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_receive_onchain_request(raw);
  }

  @protected
  ReceivePaymentRequest dco_decode_box_autoadd_receive_payment_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_receive_payment_request(raw);
  }

  @protected
  RedeemOnchainFundsRequest dco_decode_box_autoadd_redeem_onchain_funds_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_redeem_onchain_funds_request(raw);
  }

  @protected
  RefundRequest dco_decode_box_autoadd_refund_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_refund_request(raw);
  }

  @protected
  ReportIssueRequest dco_decode_box_autoadd_report_issue_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_report_issue_request(raw);
  }

  @protected
  ReportPaymentFailureDetails dco_decode_box_autoadd_report_payment_failure_details(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_report_payment_failure_details(raw);
  }

  @protected
  ReverseSwapFeesRequest dco_decode_box_autoadd_reverse_swap_fees_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_reverse_swap_fees_request(raw);
  }

  @protected
  ReverseSwapInfo dco_decode_box_autoadd_reverse_swap_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_reverse_swap_info(raw);
  }

  @protected
  SendPaymentRequest dco_decode_box_autoadd_send_payment_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_send_payment_request(raw);
  }

  @protected
  SendSpontaneousPaymentRequest dco_decode_box_autoadd_send_spontaneous_payment_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_send_spontaneous_payment_request(raw);
  }

  @protected
  SignMessageRequest dco_decode_box_autoadd_sign_message_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_sign_message_request(raw);
  }

  @protected
  StaticBackupRequest dco_decode_box_autoadd_static_backup_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_static_backup_request(raw);
  }

  @protected
  SuccessActionProcessed dco_decode_box_autoadd_success_action_processed(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_success_action_processed(raw);
  }

  @protected
  SwapInfo dco_decode_box_autoadd_swap_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_swap_info(raw);
  }

  @protected
  Symbol dco_decode_box_autoadd_symbol(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_symbol(raw);
  }

  @protected
  int dco_decode_box_autoadd_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  BigInt dco_decode_box_autoadd_u_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_u_64(raw);
  }

  @protected
  UrlSuccessActionData dco_decode_box_autoadd_url_success_action_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_url_success_action_data(raw);
  }

  @protected
  BreezEvent dco_decode_breez_event(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return BreezEvent_NewBlock(block: dco_decode_u_32(raw[1]));
      case 1:
        return BreezEvent_InvoicePaid(details: dco_decode_box_autoadd_invoice_paid_details(raw[1]));
      case 2:
        return BreezEvent_Synced();
      case 3:
        return BreezEvent_PaymentSucceed(details: dco_decode_box_autoadd_payment(raw[1]));
      case 4:
        return BreezEvent_PaymentFailed(details: dco_decode_box_autoadd_payment_failed_data(raw[1]));
      case 5:
        return BreezEvent_BackupStarted();
      case 6:
        return BreezEvent_BackupSucceeded();
      case 7:
        return BreezEvent_BackupFailed(details: dco_decode_box_autoadd_backup_failed_data(raw[1]));
      case 8:
        return BreezEvent_ReverseSwapUpdated(details: dco_decode_box_autoadd_reverse_swap_info(raw[1]));
      case 9:
        return BreezEvent_SwapUpdated(details: dco_decode_box_autoadd_swap_info(raw[1]));
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  BuyBitcoinProvider dco_decode_buy_bitcoin_provider(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return BuyBitcoinProvider.values[raw as int];
  }

  @protected
  BuyBitcoinRequest dco_decode_buy_bitcoin_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3) throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return BuyBitcoinRequest(
      provider: dco_decode_buy_bitcoin_provider(arr[0]),
      openingFeeParams: dco_decode_opt_box_autoadd_opening_fee_params(arr[1]),
      redirectUrl: dco_decode_opt_String(arr[2]),
    );
  }

  @protected
  BuyBitcoinResponse dco_decode_buy_bitcoin_response(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return BuyBitcoinResponse(
      url: dco_decode_String(arr[0]),
      openingFeeParams: dco_decode_opt_box_autoadd_opening_fee_params(arr[1]),
    );
  }

  @protected
  ChannelState dco_decode_channel_state(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ChannelState.values[raw as int];
  }

  @protected
  CheckMessageRequest dco_decode_check_message_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3) throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return CheckMessageRequest(
      message: dco_decode_String(arr[0]),
      pubkey: dco_decode_String(arr[1]),
      signature: dco_decode_String(arr[2]),
    );
  }

  @protected
  CheckMessageResponse dco_decode_check_message_response(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1) throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return CheckMessageResponse(isValid: dco_decode_bool(arr[0]));
  }

  @protected
  ClosedChannelPaymentDetails dco_decode_closed_channel_payment_details(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4) throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return ClosedChannelPaymentDetails(
      state: dco_decode_channel_state(arr[0]),
      fundingTxid: dco_decode_String(arr[1]),
      shortChannelId: dco_decode_opt_String(arr[2]),
      closingTxid: dco_decode_opt_String(arr[3]),
    );
  }

  @protected
  Config dco_decode_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 11) throw Exception('unexpected arr length: expect 11 but see ${arr.length}');
    return Config(
      breezserver: dco_decode_String(arr[0]),
      chainnotifierUrl: dco_decode_String(arr[1]),
      mempoolspaceUrl: dco_decode_opt_String(arr[2]),
      workingDir: dco_decode_String(arr[3]),
      network: dco_decode_network(arr[4]),
      paymentTimeoutSec: dco_decode_u_32(arr[5]),
      defaultLspId: dco_decode_opt_String(arr[6]),
      apiKey: dco_decode_opt_String(arr[7]),
      maxfeePercent: dco_decode_f_64(arr[8]),
      exemptfeeMsat: dco_decode_u_64(arr[9]),
      nodeConfig: dco_decode_node_config(arr[10]),
    );
  }

  @protected
  ConfigureNodeRequest dco_decode_configure_node_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1) throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return ConfigureNodeRequest(closeToAddress: dco_decode_opt_String(arr[0]));
  }

  @protected
  ConnectRequest dco_decode_connect_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3) throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return ConnectRequest(
      config: dco_decode_config(arr[0]),
      seed: dco_decode_list_prim_u_8_strict(arr[1]),
      restoreOnly: dco_decode_opt_box_autoadd_bool(arr[2]),
    );
  }

  @protected
  CurrencyInfo dco_decode_currency_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 7) throw Exception('unexpected arr length: expect 7 but see ${arr.length}');
    return CurrencyInfo(
      name: dco_decode_String(arr[0]),
      fractionSize: dco_decode_u_32(arr[1]),
      spacing: dco_decode_opt_box_autoadd_u_32(arr[2]),
      symbol: dco_decode_opt_box_autoadd_symbol(arr[3]),
      uniqSymbol: dco_decode_opt_box_autoadd_symbol(arr[4]),
      localizedName: dco_decode_list_localized_name(arr[5]),
      localeOverrides: dco_decode_list_locale_overrides(arr[6]),
    );
  }

  @protected
  EnvironmentType dco_decode_environment_type(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return EnvironmentType.values[raw as int];
  }

  @protected
  double dco_decode_f_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as double;
  }

  @protected
  FiatCurrency dco_decode_fiat_currency(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return FiatCurrency(id: dco_decode_String(arr[0]), info: dco_decode_currency_info(arr[1]));
  }

  @protected
  GreenlightCredentials dco_decode_greenlight_credentials(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return GreenlightCredentials(
      developerKey: dco_decode_list_prim_u_8_strict(arr[0]),
      developerCert: dco_decode_list_prim_u_8_strict(arr[1]),
    );
  }

  @protected
  GreenlightDeviceCredentials dco_decode_greenlight_device_credentials(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1) throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return GreenlightDeviceCredentials(device: dco_decode_list_prim_u_8_strict(arr[0]));
  }

  @protected
  GreenlightNodeConfig dco_decode_greenlight_node_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return GreenlightNodeConfig(
      partnerCredentials: dco_decode_opt_box_autoadd_greenlight_credentials(arr[0]),
      inviteCode: dco_decode_opt_String(arr[1]),
    );
  }

  @protected
  HealthCheckStatus dco_decode_health_check_status(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return HealthCheckStatus.values[raw as int];
  }

  @protected
  int dco_decode_i_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  PlatformInt64 dco_decode_i_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeI64(raw);
  }

  @protected
  InputType dco_decode_input_type(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return InputType_BitcoinAddress(address: dco_decode_box_autoadd_bitcoin_address_data(raw[1]));
      case 1:
        return InputType_Bolt11(invoice: dco_decode_box_autoadd_ln_invoice(raw[1]));
      case 2:
        return InputType_NodeId(nodeId: dco_decode_String(raw[1]));
      case 3:
        return InputType_Url(url: dco_decode_String(raw[1]));
      case 4:
        return InputType_LnUrlPay(
          data: dco_decode_box_autoadd_ln_url_pay_request_data(raw[1]),
          bip353Address: dco_decode_opt_String(raw[2]),
        );
      case 5:
        return InputType_LnUrlWithdraw(data: dco_decode_box_autoadd_ln_url_withdraw_request_data(raw[1]));
      case 6:
        return InputType_LnUrlAuth(data: dco_decode_box_autoadd_ln_url_auth_request_data(raw[1]));
      case 7:
        return InputType_LnUrlError(data: dco_decode_box_autoadd_ln_url_error_data(raw[1]));
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  InvoicePaidDetails dco_decode_invoice_paid_details(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3) throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return InvoicePaidDetails(
      paymentHash: dco_decode_String(arr[0]),
      bolt11: dco_decode_String(arr[1]),
      payment: dco_decode_opt_box_autoadd_payment(arr[2]),
    );
  }

  @protected
  LevelFilter dco_decode_level_filter(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return LevelFilter.values[raw as int];
  }

  @protected
  List<String> dco_decode_list_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_String).toList();
  }

  @protected
  List<FiatCurrency> dco_decode_list_fiat_currency(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_fiat_currency).toList();
  }

  @protected
  List<LocaleOverrides> dco_decode_list_locale_overrides(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_locale_overrides).toList();
  }

  @protected
  List<LocalizedName> dco_decode_list_localized_name(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_localized_name).toList();
  }

  @protected
  List<LspInformation> dco_decode_list_lsp_information(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_lsp_information).toList();
  }

  @protected
  List<MetadataFilter> dco_decode_list_metadata_filter(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_metadata_filter).toList();
  }

  @protected
  List<OpeningFeeParams> dco_decode_list_opening_fee_params(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_opening_fee_params).toList();
  }

  @protected
  List<Payment> dco_decode_list_payment(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_payment).toList();
  }

  @protected
  List<PaymentTypeFilter> dco_decode_list_payment_type_filter(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_payment_type_filter).toList();
  }

  @protected
  ListPaymentsRequest dco_decode_list_payments_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 7) throw Exception('unexpected arr length: expect 7 but see ${arr.length}');
    return ListPaymentsRequest(
      filters: dco_decode_opt_list_payment_type_filter(arr[0]),
      metadataFilters: dco_decode_opt_list_metadata_filter(arr[1]),
      fromTimestamp: dco_decode_opt_box_autoadd_i_64(arr[2]),
      toTimestamp: dco_decode_opt_box_autoadd_i_64(arr[3]),
      includeFailures: dco_decode_opt_box_autoadd_bool(arr[4]),
      offset: dco_decode_opt_box_autoadd_u_32(arr[5]),
      limit: dco_decode_opt_box_autoadd_u_32(arr[6]),
    );
  }

  @protected
  Uint8List dco_decode_list_prim_u_8_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as Uint8List;
  }

  @protected
  List<Rate> dco_decode_list_rate(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_rate).toList();
  }

  @protected
  List<ReverseSwapInfo> dco_decode_list_reverse_swap_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_reverse_swap_info).toList();
  }

  @protected
  List<RouteHint> dco_decode_list_route_hint(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_route_hint).toList();
  }

  @protected
  List<RouteHintHop> dco_decode_list_route_hint_hop(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_route_hint_hop).toList();
  }

  @protected
  List<SwapInfo> dco_decode_list_swap_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_swap_info).toList();
  }

  @protected
  List<SwapStatus> dco_decode_list_swap_status(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_swap_status).toList();
  }

  @protected
  ListSwapsRequest dco_decode_list_swaps_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 5) throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
    return ListSwapsRequest(
      status: dco_decode_opt_list_swap_status(arr[0]),
      fromTimestamp: dco_decode_opt_box_autoadd_i_64(arr[1]),
      toTimestamp: dco_decode_opt_box_autoadd_i_64(arr[2]),
      offset: dco_decode_opt_box_autoadd_u_32(arr[3]),
      limit: dco_decode_opt_box_autoadd_u_32(arr[4]),
    );
  }

  @protected
  List<TlvEntry> dco_decode_list_tlv_entry(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_tlv_entry).toList();
  }

  @protected
  List<UnspentTransactionOutput> dco_decode_list_unspent_transaction_output(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_unspent_transaction_output).toList();
  }

  @protected
  LNInvoice dco_decode_ln_invoice(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 12) throw Exception('unexpected arr length: expect 12 but see ${arr.length}');
    return LNInvoice(
      bolt11: dco_decode_String(arr[0]),
      network: dco_decode_network(arr[1]),
      payeePubkey: dco_decode_String(arr[2]),
      paymentHash: dco_decode_String(arr[3]),
      description: dco_decode_opt_String(arr[4]),
      descriptionHash: dco_decode_opt_String(arr[5]),
      amountMsat: dco_decode_opt_box_autoadd_u_64(arr[6]),
      timestamp: dco_decode_u_64(arr[7]),
      expiry: dco_decode_u_64(arr[8]),
      routingHints: dco_decode_list_route_hint(arr[9]),
      paymentSecret: dco_decode_list_prim_u_8_strict(arr[10]),
      minFinalCltvExpiryDelta: dco_decode_u_64(arr[11]),
    );
  }

  @protected
  LnPaymentDetails dco_decode_ln_payment_details(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 16) throw Exception('unexpected arr length: expect 16 but see ${arr.length}');
    return LnPaymentDetails(
      paymentHash: dco_decode_String(arr[0]),
      label: dco_decode_String(arr[1]),
      destinationPubkey: dco_decode_String(arr[2]),
      paymentPreimage: dco_decode_String(arr[3]),
      keysend: dco_decode_bool(arr[4]),
      bolt11: dco_decode_String(arr[5]),
      openChannelBolt11: dco_decode_opt_String(arr[6]),
      lnurlSuccessAction: dco_decode_opt_box_autoadd_success_action_processed(arr[7]),
      lnurlPayDomain: dco_decode_opt_String(arr[8]),
      lnurlPayComment: dco_decode_opt_String(arr[9]),
      lnAddress: dco_decode_opt_String(arr[10]),
      lnurlMetadata: dco_decode_opt_String(arr[11]),
      lnurlWithdrawEndpoint: dco_decode_opt_String(arr[12]),
      swapInfo: dco_decode_opt_box_autoadd_swap_info(arr[13]),
      reverseSwapInfo: dco_decode_opt_box_autoadd_reverse_swap_info(arr[14]),
      pendingExpirationBlock: dco_decode_opt_box_autoadd_u_32(arr[15]),
    );
  }

  @protected
  LnUrlAuthRequestData dco_decode_ln_url_auth_request_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4) throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return LnUrlAuthRequestData(
      k1: dco_decode_String(arr[0]),
      action: dco_decode_opt_String(arr[1]),
      domain: dco_decode_String(arr[2]),
      url: dco_decode_String(arr[3]),
    );
  }

  @protected
  LnUrlCallbackStatus dco_decode_ln_url_callback_status(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return LnUrlCallbackStatus_Ok();
      case 1:
        return LnUrlCallbackStatus_ErrorStatus(data: dco_decode_box_autoadd_ln_url_error_data(raw[1]));
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  LnUrlErrorData dco_decode_ln_url_error_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1) throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return LnUrlErrorData(reason: dco_decode_String(arr[0]));
  }

  @protected
  LnUrlPayErrorData dco_decode_ln_url_pay_error_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return LnUrlPayErrorData(paymentHash: dco_decode_String(arr[0]), reason: dco_decode_String(arr[1]));
  }

  @protected
  LnUrlPayRequest dco_decode_ln_url_pay_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 6) throw Exception('unexpected arr length: expect 6 but see ${arr.length}');
    return LnUrlPayRequest(
      data: dco_decode_ln_url_pay_request_data(arr[0]),
      amountMsat: dco_decode_u_64(arr[1]),
      useTrampoline: dco_decode_bool(arr[2]),
      comment: dco_decode_opt_String(arr[3]),
      paymentLabel: dco_decode_opt_String(arr[4]),
      validateSuccessActionUrl: dco_decode_opt_box_autoadd_bool(arr[5]),
    );
  }

  @protected
  LnUrlPayRequestData dco_decode_ln_url_pay_request_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 9) throw Exception('unexpected arr length: expect 9 but see ${arr.length}');
    return LnUrlPayRequestData(
      callback: dco_decode_String(arr[0]),
      minSendable: dco_decode_u_64(arr[1]),
      maxSendable: dco_decode_u_64(arr[2]),
      metadataStr: dco_decode_String(arr[3]),
      commentAllowed: dco_decode_u_16(arr[4]),
      domain: dco_decode_String(arr[5]),
      allowsNostr: dco_decode_bool(arr[6]),
      nostrPubkey: dco_decode_opt_String(arr[7]),
      lnAddress: dco_decode_opt_String(arr[8]),
    );
  }

  @protected
  LnUrlPayResult dco_decode_ln_url_pay_result(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return LnUrlPayResult_EndpointSuccess(data: dco_decode_box_autoadd_ln_url_pay_success_data(raw[1]));
      case 1:
        return LnUrlPayResult_EndpointError(data: dco_decode_box_autoadd_ln_url_error_data(raw[1]));
      case 2:
        return LnUrlPayResult_PayError(data: dco_decode_box_autoadd_ln_url_pay_error_data(raw[1]));
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  LnUrlPaySuccessData dco_decode_ln_url_pay_success_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return LnUrlPaySuccessData(
      payment: dco_decode_payment(arr[0]),
      successAction: dco_decode_opt_box_autoadd_success_action_processed(arr[1]),
    );
  }

  @protected
  LnUrlWithdrawRequest dco_decode_ln_url_withdraw_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3) throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return LnUrlWithdrawRequest(
      data: dco_decode_ln_url_withdraw_request_data(arr[0]),
      amountMsat: dco_decode_u_64(arr[1]),
      description: dco_decode_opt_String(arr[2]),
    );
  }

  @protected
  LnUrlWithdrawRequestData dco_decode_ln_url_withdraw_request_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 5) throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
    return LnUrlWithdrawRequestData(
      callback: dco_decode_String(arr[0]),
      k1: dco_decode_String(arr[1]),
      defaultDescription: dco_decode_String(arr[2]),
      minWithdrawable: dco_decode_u_64(arr[3]),
      maxWithdrawable: dco_decode_u_64(arr[4]),
    );
  }

  @protected
  LnUrlWithdrawResult dco_decode_ln_url_withdraw_result(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return LnUrlWithdrawResult_Ok(data: dco_decode_box_autoadd_ln_url_withdraw_success_data(raw[1]));
      case 1:
        return LnUrlWithdrawResult_Timeout(data: dco_decode_box_autoadd_ln_url_withdraw_success_data(raw[1]));
      case 2:
        return LnUrlWithdrawResult_ErrorStatus(data: dco_decode_box_autoadd_ln_url_error_data(raw[1]));
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  LnUrlWithdrawSuccessData dco_decode_ln_url_withdraw_success_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1) throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return LnUrlWithdrawSuccessData(invoice: dco_decode_ln_invoice(arr[0]));
  }

  @protected
  LocaleOverrides dco_decode_locale_overrides(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3) throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return LocaleOverrides(
      locale: dco_decode_String(arr[0]),
      spacing: dco_decode_opt_box_autoadd_u_32(arr[1]),
      symbol: dco_decode_symbol(arr[2]),
    );
  }

  @protected
  LocalizedName dco_decode_localized_name(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return LocalizedName(locale: dco_decode_String(arr[0]), name: dco_decode_String(arr[1]));
  }

  @protected
  LogEntry dco_decode_log_entry(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return LogEntry(line: dco_decode_String(arr[0]), level: dco_decode_String(arr[1]));
  }

  @protected
  LspInformation dco_decode_lsp_information(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 11) throw Exception('unexpected arr length: expect 11 but see ${arr.length}');
    return LspInformation(
      id: dco_decode_String(arr[0]),
      name: dco_decode_String(arr[1]),
      widgetUrl: dco_decode_String(arr[2]),
      pubkey: dco_decode_String(arr[3]),
      host: dco_decode_String(arr[4]),
      baseFeeMsat: dco_decode_i_64(arr[5]),
      feeRate: dco_decode_f_64(arr[6]),
      timeLockDelta: dco_decode_u_32(arr[7]),
      minHtlcMsat: dco_decode_i_64(arr[8]),
      lspPubkey: dco_decode_list_prim_u_8_strict(arr[9]),
      openingFeeParamsList: dco_decode_opening_fee_params_menu(arr[10]),
    );
  }

  @protected
  MessageSuccessActionData dco_decode_message_success_action_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1) throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return MessageSuccessActionData(message: dco_decode_String(arr[0]));
  }

  @protected
  MetadataFilter dco_decode_metadata_filter(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return MetadataFilter(jsonPath: dco_decode_String(arr[0]), jsonValue: dco_decode_String(arr[1]));
  }

  @protected
  Network dco_decode_network(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return Network.values[raw as int];
  }

  @protected
  NodeConfig dco_decode_node_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return NodeConfig_Greenlight(config: dco_decode_box_autoadd_greenlight_node_config(raw[1]));
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  NodeCredentials dco_decode_node_credentials(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return NodeCredentials_Greenlight(
          credentials: dco_decode_box_autoadd_greenlight_device_credentials(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  NodeState dco_decode_node_state(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 13) throw Exception('unexpected arr length: expect 13 but see ${arr.length}');
    return NodeState(
      id: dco_decode_String(arr[0]),
      blockHeight: dco_decode_u_32(arr[1]),
      channelsBalanceMsat: dco_decode_u_64(arr[2]),
      onchainBalanceMsat: dco_decode_u_64(arr[3]),
      pendingOnchainBalanceMsat: dco_decode_u_64(arr[4]),
      utxos: dco_decode_list_unspent_transaction_output(arr[5]),
      maxPayableMsat: dco_decode_u_64(arr[6]),
      maxReceivableMsat: dco_decode_u_64(arr[7]),
      maxSinglePaymentAmountMsat: dco_decode_u_64(arr[8]),
      maxChanReserveMsats: dco_decode_u_64(arr[9]),
      connectedPeers: dco_decode_list_String(arr[10]),
      maxReceivableSinglePaymentAmountMsat: dco_decode_u_64(arr[11]),
      totalInboundLiquidityMsats: dco_decode_u_64(arr[12]),
    );
  }

  @protected
  OnchainPaymentLimitsResponse dco_decode_onchain_payment_limits_response(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3) throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return OnchainPaymentLimitsResponse(
      minSat: dco_decode_u_64(arr[0]),
      maxSat: dco_decode_u_64(arr[1]),
      maxPayableSat: dco_decode_u_64(arr[2]),
    );
  }

  @protected
  OpenChannelFeeRequest dco_decode_open_channel_fee_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return OpenChannelFeeRequest(
      amountMsat: dco_decode_opt_box_autoadd_u_64(arr[0]),
      expiry: dco_decode_opt_box_autoadd_u_32(arr[1]),
    );
  }

  @protected
  OpenChannelFeeResponse dco_decode_open_channel_fee_response(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return OpenChannelFeeResponse(
      feeMsat: dco_decode_opt_box_autoadd_u_64(arr[0]),
      feeParams: dco_decode_opening_fee_params(arr[1]),
    );
  }

  @protected
  OpeningFeeParams dco_decode_opening_fee_params(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 6) throw Exception('unexpected arr length: expect 6 but see ${arr.length}');
    return OpeningFeeParams(
      minMsat: dco_decode_u_64(arr[0]),
      proportional: dco_decode_u_32(arr[1]),
      validUntil: dco_decode_String(arr[2]),
      maxIdleTime: dco_decode_u_32(arr[3]),
      maxClientToSelfDelay: dco_decode_u_32(arr[4]),
      promise: dco_decode_String(arr[5]),
    );
  }

  @protected
  OpeningFeeParamsMenu dco_decode_opening_fee_params_menu(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1) throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return OpeningFeeParamsMenu(values: dco_decode_list_opening_fee_params(arr[0]));
  }

  @protected
  String? dco_decode_opt_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_String(raw);
  }

  @protected
  bool? dco_decode_opt_box_autoadd_bool(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_bool(raw);
  }

  @protected
  GreenlightCredentials? dco_decode_opt_box_autoadd_greenlight_credentials(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_greenlight_credentials(raw);
  }

  @protected
  PlatformInt64? dco_decode_opt_box_autoadd_i_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_i_64(raw);
  }

  @protected
  LevelFilter? dco_decode_opt_box_autoadd_level_filter(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_level_filter(raw);
  }

  @protected
  LNInvoice? dco_decode_opt_box_autoadd_ln_invoice(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_ln_invoice(raw);
  }

  @protected
  LspInformation? dco_decode_opt_box_autoadd_lsp_information(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_lsp_information(raw);
  }

  @protected
  NodeCredentials? dco_decode_opt_box_autoadd_node_credentials(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_node_credentials(raw);
  }

  @protected
  OpeningFeeParams? dco_decode_opt_box_autoadd_opening_fee_params(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_opening_fee_params(raw);
  }

  @protected
  Payment? dco_decode_opt_box_autoadd_payment(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_payment(raw);
  }

  @protected
  ReverseSwapInfo? dco_decode_opt_box_autoadd_reverse_swap_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_reverse_swap_info(raw);
  }

  @protected
  SuccessActionProcessed? dco_decode_opt_box_autoadd_success_action_processed(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_success_action_processed(raw);
  }

  @protected
  SwapInfo? dco_decode_opt_box_autoadd_swap_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_swap_info(raw);
  }

  @protected
  Symbol? dco_decode_opt_box_autoadd_symbol(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_symbol(raw);
  }

  @protected
  int? dco_decode_opt_box_autoadd_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_u_32(raw);
  }

  @protected
  BigInt? dco_decode_opt_box_autoadd_u_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_u_64(raw);
  }

  @protected
  List<String>? dco_decode_opt_list_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_list_String(raw);
  }

  @protected
  List<MetadataFilter>? dco_decode_opt_list_metadata_filter(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_list_metadata_filter(raw);
  }

  @protected
  List<PaymentTypeFilter>? dco_decode_opt_list_payment_type_filter(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_list_payment_type_filter(raw);
  }

  @protected
  Uint8List? dco_decode_opt_list_prim_u_8_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_list_prim_u_8_strict(raw);
  }

  @protected
  List<SwapStatus>? dco_decode_opt_list_swap_status(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_list_swap_status(raw);
  }

  @protected
  List<TlvEntry>? dco_decode_opt_list_tlv_entry(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_list_tlv_entry(raw);
  }

  @protected
  PayOnchainRequest dco_decode_pay_onchain_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return PayOnchainRequest(
      recipientAddress: dco_decode_String(arr[0]),
      prepareRes: dco_decode_prepare_onchain_payment_response(arr[1]),
    );
  }

  @protected
  PayOnchainResponse dco_decode_pay_onchain_response(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1) throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return PayOnchainResponse(reverseSwapInfo: dco_decode_reverse_swap_info(arr[0]));
  }

  @protected
  Payment dco_decode_payment(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 10) throw Exception('unexpected arr length: expect 10 but see ${arr.length}');
    return Payment(
      id: dco_decode_String(arr[0]),
      paymentType: dco_decode_payment_type(arr[1]),
      paymentTime: dco_decode_i_64(arr[2]),
      amountMsat: dco_decode_u_64(arr[3]),
      feeMsat: dco_decode_u_64(arr[4]),
      status: dco_decode_payment_status(arr[5]),
      error: dco_decode_opt_String(arr[6]),
      description: dco_decode_opt_String(arr[7]),
      details: dco_decode_payment_details(arr[8]),
      metadata: dco_decode_opt_String(arr[9]),
    );
  }

  @protected
  PaymentDetails dco_decode_payment_details(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return PaymentDetails_Ln(data: dco_decode_box_autoadd_ln_payment_details(raw[1]));
      case 1:
        return PaymentDetails_ClosedChannel(
          data: dco_decode_box_autoadd_closed_channel_payment_details(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  PaymentFailedData dco_decode_payment_failed_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4) throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return PaymentFailedData(
      error: dco_decode_String(arr[0]),
      nodeId: dco_decode_String(arr[1]),
      invoice: dco_decode_opt_box_autoadd_ln_invoice(arr[2]),
      label: dco_decode_opt_String(arr[3]),
    );
  }

  @protected
  PaymentStatus dco_decode_payment_status(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return PaymentStatus.values[raw as int];
  }

  @protected
  PaymentType dco_decode_payment_type(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return PaymentType.values[raw as int];
  }

  @protected
  PaymentTypeFilter dco_decode_payment_type_filter(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return PaymentTypeFilter.values[raw as int];
  }

  @protected
  PrepareOnchainPaymentRequest dco_decode_prepare_onchain_payment_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3) throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return PrepareOnchainPaymentRequest(
      amountSat: dco_decode_u_64(arr[0]),
      amountType: dco_decode_swap_amount_type(arr[1]),
      claimTxFeerate: dco_decode_u_32(arr[2]),
    );
  }

  @protected
  PrepareOnchainPaymentResponse dco_decode_prepare_onchain_payment_response(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 7) throw Exception('unexpected arr length: expect 7 but see ${arr.length}');
    return PrepareOnchainPaymentResponse(
      feesHash: dco_decode_String(arr[0]),
      feesPercentage: dco_decode_f_64(arr[1]),
      feesLockup: dco_decode_u_64(arr[2]),
      feesClaim: dco_decode_u_64(arr[3]),
      senderAmountSat: dco_decode_u_64(arr[4]),
      recipientAmountSat: dco_decode_u_64(arr[5]),
      totalFees: dco_decode_u_64(arr[6]),
    );
  }

  @protected
  PrepareRedeemOnchainFundsRequest dco_decode_prepare_redeem_onchain_funds_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return PrepareRedeemOnchainFundsRequest(
      toAddress: dco_decode_String(arr[0]),
      satPerVbyte: dco_decode_u_32(arr[1]),
    );
  }

  @protected
  PrepareRedeemOnchainFundsResponse dco_decode_prepare_redeem_onchain_funds_response(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return PrepareRedeemOnchainFundsResponse(
      txWeight: dco_decode_u_64(arr[0]),
      txFeeSat: dco_decode_u_64(arr[1]),
    );
  }

  @protected
  PrepareRefundRequest dco_decode_prepare_refund_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4) throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return PrepareRefundRequest(
      swapAddress: dco_decode_String(arr[0]),
      toAddress: dco_decode_String(arr[1]),
      satPerVbyte: dco_decode_u_32(arr[2]),
      unilateral: dco_decode_opt_box_autoadd_bool(arr[3]),
    );
  }

  @protected
  PrepareRefundResponse dco_decode_prepare_refund_response(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return PrepareRefundResponse(
      refundTxWeight: dco_decode_u_32(arr[0]),
      refundTxFeeSat: dco_decode_u_64(arr[1]),
    );
  }

  @protected
  Rate dco_decode_rate(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return Rate(coin: dco_decode_String(arr[0]), value: dco_decode_f_64(arr[1]));
  }

  @protected
  ReceiveOnchainRequest dco_decode_receive_onchain_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1) throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return ReceiveOnchainRequest(openingFeeParams: dco_decode_opt_box_autoadd_opening_fee_params(arr[0]));
  }

  @protected
  ReceivePaymentRequest dco_decode_receive_payment_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 7) throw Exception('unexpected arr length: expect 7 but see ${arr.length}');
    return ReceivePaymentRequest(
      amountMsat: dco_decode_u_64(arr[0]),
      description: dco_decode_String(arr[1]),
      preimage: dco_decode_opt_list_prim_u_8_strict(arr[2]),
      openingFeeParams: dco_decode_opt_box_autoadd_opening_fee_params(arr[3]),
      useDescriptionHash: dco_decode_opt_box_autoadd_bool(arr[4]),
      expiry: dco_decode_opt_box_autoadd_u_32(arr[5]),
      cltv: dco_decode_opt_box_autoadd_u_32(arr[6]),
    );
  }

  @protected
  ReceivePaymentResponse dco_decode_receive_payment_response(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3) throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return ReceivePaymentResponse(
      lnInvoice: dco_decode_ln_invoice(arr[0]),
      openingFeeParams: dco_decode_opt_box_autoadd_opening_fee_params(arr[1]),
      openingFeeMsat: dco_decode_opt_box_autoadd_u_64(arr[2]),
    );
  }

  @protected
  RecommendedFees dco_decode_recommended_fees(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 5) throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
    return RecommendedFees(
      fastestFee: dco_decode_u_64(arr[0]),
      halfHourFee: dco_decode_u_64(arr[1]),
      hourFee: dco_decode_u_64(arr[2]),
      economyFee: dco_decode_u_64(arr[3]),
      minimumFee: dco_decode_u_64(arr[4]),
    );
  }

  @protected
  RedeemOnchainFundsRequest dco_decode_redeem_onchain_funds_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return RedeemOnchainFundsRequest(
      toAddress: dco_decode_String(arr[0]),
      satPerVbyte: dco_decode_u_32(arr[1]),
    );
  }

  @protected
  RedeemOnchainFundsResponse dco_decode_redeem_onchain_funds_response(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1) throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return RedeemOnchainFundsResponse(txid: dco_decode_list_prim_u_8_strict(arr[0]));
  }

  @protected
  RefundRequest dco_decode_refund_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4) throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return RefundRequest(
      swapAddress: dco_decode_String(arr[0]),
      toAddress: dco_decode_String(arr[1]),
      satPerVbyte: dco_decode_u_32(arr[2]),
      unilateral: dco_decode_opt_box_autoadd_bool(arr[3]),
    );
  }

  @protected
  RefundResponse dco_decode_refund_response(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1) throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return RefundResponse(refundTxId: dco_decode_String(arr[0]));
  }

  @protected
  ReportIssueRequest dco_decode_report_issue_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return ReportIssueRequest_PaymentFailure(
          data: dco_decode_box_autoadd_report_payment_failure_details(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  ReportPaymentFailureDetails dco_decode_report_payment_failure_details(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return ReportPaymentFailureDetails(
      paymentHash: dco_decode_String(arr[0]),
      comment: dco_decode_opt_String(arr[1]),
    );
  }

  @protected
  ReverseSwapFeesRequest dco_decode_reverse_swap_fees_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return ReverseSwapFeesRequest(
      sendAmountSat: dco_decode_opt_box_autoadd_u_64(arr[0]),
      claimTxFeerate: dco_decode_opt_box_autoadd_u_32(arr[1]),
    );
  }

  @protected
  ReverseSwapInfo dco_decode_reverse_swap_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 6) throw Exception('unexpected arr length: expect 6 but see ${arr.length}');
    return ReverseSwapInfo(
      id: dco_decode_String(arr[0]),
      claimPubkey: dco_decode_String(arr[1]),
      lockupTxid: dco_decode_opt_String(arr[2]),
      claimTxid: dco_decode_opt_String(arr[3]),
      onchainAmountSat: dco_decode_u_64(arr[4]),
      status: dco_decode_reverse_swap_status(arr[5]),
    );
  }

  @protected
  ReverseSwapPairInfo dco_decode_reverse_swap_pair_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 7) throw Exception('unexpected arr length: expect 7 but see ${arr.length}');
    return ReverseSwapPairInfo(
      min: dco_decode_u_64(arr[0]),
      max: dco_decode_u_64(arr[1]),
      feesHash: dco_decode_String(arr[2]),
      feesPercentage: dco_decode_f_64(arr[3]),
      feesLockup: dco_decode_u_64(arr[4]),
      feesClaim: dco_decode_u_64(arr[5]),
      totalFees: dco_decode_opt_box_autoadd_u_64(arr[6]),
    );
  }

  @protected
  ReverseSwapStatus dco_decode_reverse_swap_status(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ReverseSwapStatus.values[raw as int];
  }

  @protected
  RouteHint dco_decode_route_hint(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1) throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return RouteHint(hops: dco_decode_list_route_hint_hop(arr[0]));
  }

  @protected
  RouteHintHop dco_decode_route_hint_hop(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 7) throw Exception('unexpected arr length: expect 7 but see ${arr.length}');
    return RouteHintHop(
      srcNodeId: dco_decode_String(arr[0]),
      shortChannelId: dco_decode_String(arr[1]),
      feesBaseMsat: dco_decode_u_32(arr[2]),
      feesProportionalMillionths: dco_decode_u_32(arr[3]),
      cltvExpiryDelta: dco_decode_u_64(arr[4]),
      htlcMinimumMsat: dco_decode_opt_box_autoadd_u_64(arr[5]),
      htlcMaximumMsat: dco_decode_opt_box_autoadd_u_64(arr[6]),
    );
  }

  @protected
  SendPaymentRequest dco_decode_send_payment_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4) throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return SendPaymentRequest(
      bolt11: dco_decode_String(arr[0]),
      useTrampoline: dco_decode_bool(arr[1]),
      amountMsat: dco_decode_opt_box_autoadd_u_64(arr[2]),
      label: dco_decode_opt_String(arr[3]),
    );
  }

  @protected
  SendPaymentResponse dco_decode_send_payment_response(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1) throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return SendPaymentResponse(payment: dco_decode_payment(arr[0]));
  }

  @protected
  SendSpontaneousPaymentRequest dco_decode_send_spontaneous_payment_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4) throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return SendSpontaneousPaymentRequest(
      nodeId: dco_decode_String(arr[0]),
      amountMsat: dco_decode_u_64(arr[1]),
      extraTlvs: dco_decode_opt_list_tlv_entry(arr[2]),
      label: dco_decode_opt_String(arr[3]),
    );
  }

  @protected
  ServiceHealthCheckResponse dco_decode_service_health_check_response(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1) throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return ServiceHealthCheckResponse(status: dco_decode_health_check_status(arr[0]));
  }

  @protected
  SignMessageRequest dco_decode_sign_message_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1) throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return SignMessageRequest(message: dco_decode_String(arr[0]));
  }

  @protected
  SignMessageResponse dco_decode_sign_message_response(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1) throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return SignMessageResponse(signature: dco_decode_String(arr[0]));
  }

  @protected
  StaticBackupRequest dco_decode_static_backup_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1) throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return StaticBackupRequest(workingDir: dco_decode_String(arr[0]));
  }

  @protected
  StaticBackupResponse dco_decode_static_backup_response(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1) throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return StaticBackupResponse(backup: dco_decode_opt_list_String(arr[0]));
  }

  @protected
  SuccessActionProcessed dco_decode_success_action_processed(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return SuccessActionProcessed_Aes(
          result: dco_decode_box_autoadd_aes_success_action_data_result(raw[1]),
        );
      case 1:
        return SuccessActionProcessed_Message(
          data: dco_decode_box_autoadd_message_success_action_data(raw[1]),
        );
      case 2:
        return SuccessActionProcessed_Url(data: dco_decode_box_autoadd_url_success_action_data(raw[1]));
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  SwapAmountType dco_decode_swap_amount_type(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return SwapAmountType.values[raw as int];
  }

  @protected
  SwapInfo dco_decode_swap_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 24) throw Exception('unexpected arr length: expect 24 but see ${arr.length}');
    return SwapInfo(
      bitcoinAddress: dco_decode_String(arr[0]),
      createdAt: dco_decode_i_64(arr[1]),
      lockHeight: dco_decode_i_64(arr[2]),
      paymentHash: dco_decode_list_prim_u_8_strict(arr[3]),
      preimage: dco_decode_list_prim_u_8_strict(arr[4]),
      privateKey: dco_decode_list_prim_u_8_strict(arr[5]),
      publicKey: dco_decode_list_prim_u_8_strict(arr[6]),
      swapperPublicKey: dco_decode_list_prim_u_8_strict(arr[7]),
      script: dco_decode_list_prim_u_8_strict(arr[8]),
      bolt11: dco_decode_opt_String(arr[9]),
      paidMsat: dco_decode_u_64(arr[10]),
      totalIncomingTxs: dco_decode_u_64(arr[11]),
      confirmedSats: dco_decode_u_64(arr[12]),
      unconfirmedSats: dco_decode_u_64(arr[13]),
      status: dco_decode_swap_status(arr[14]),
      refundTxIds: dco_decode_list_String(arr[15]),
      unconfirmedTxIds: dco_decode_list_String(arr[16]),
      confirmedTxIds: dco_decode_list_String(arr[17]),
      minAllowedDeposit: dco_decode_i_64(arr[18]),
      maxAllowedDeposit: dco_decode_i_64(arr[19]),
      maxSwapperPayable: dco_decode_i_64(arr[20]),
      lastRedeemError: dco_decode_opt_String(arr[21]),
      channelOpeningFees: dco_decode_opt_box_autoadd_opening_fee_params(arr[22]),
      confirmedAt: dco_decode_opt_box_autoadd_u_32(arr[23]),
    );
  }

  @protected
  SwapStatus dco_decode_swap_status(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return SwapStatus.values[raw as int];
  }

  @protected
  Symbol dco_decode_symbol(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4) throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return Symbol(
      grapheme: dco_decode_opt_String(arr[0]),
      template: dco_decode_opt_String(arr[1]),
      rtl: dco_decode_opt_box_autoadd_bool(arr[2]),
      position: dco_decode_opt_box_autoadd_u_32(arr[3]),
    );
  }

  @protected
  TlvEntry dco_decode_tlv_entry(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return TlvEntry(fieldNumber: dco_decode_u_64(arr[0]), value: dco_decode_list_prim_u_8_strict(arr[1]));
  }

  @protected
  int dco_decode_u_16(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  int dco_decode_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  BigInt dco_decode_u_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeU64(raw);
  }

  @protected
  int dco_decode_u_8(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  void dco_decode_unit(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return;
  }

  @protected
  UnspentTransactionOutput dco_decode_unspent_transaction_output(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 5) throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
    return UnspentTransactionOutput(
      txid: dco_decode_list_prim_u_8_strict(arr[0]),
      outnum: dco_decode_u_32(arr[1]),
      amountMillisatoshi: dco_decode_u_64(arr[2]),
      address: dco_decode_String(arr[3]),
      reserved: dco_decode_bool(arr[4]),
    );
  }

  @protected
  UrlSuccessActionData dco_decode_url_success_action_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3) throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return UrlSuccessActionData(
      description: dco_decode_String(arr[0]),
      url: dco_decode_String(arr[1]),
      matchesCallbackDomain: dco_decode_bool(arr[2]),
    );
  }

  @protected
  AnyhowException sse_decode_AnyhowException(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_String(deserializer);
    return AnyhowException(inner);
  }

  @protected
  RustStreamSink<BreezEvent> sse_decode_StreamSink_breez_event_Dco(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    throw UnimplementedError('Unreachable ()');
  }

  @protected
  RustStreamSink<LogEntry> sse_decode_StreamSink_log_entry_Dco(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    throw UnimplementedError('Unreachable ()');
  }

  @protected
  String sse_decode_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_prim_u_8_strict(deserializer);
    return utf8.decoder.convert(inner);
  }

  @protected
  AesSuccessActionDataDecrypted sse_decode_aes_success_action_data_decrypted(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_description = sse_decode_String(deserializer);
    var var_plaintext = sse_decode_String(deserializer);
    return AesSuccessActionDataDecrypted(description: var_description, plaintext: var_plaintext);
  }

  @protected
  AesSuccessActionDataResult sse_decode_aes_success_action_data_result(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_data = sse_decode_box_autoadd_aes_success_action_data_decrypted(deserializer);
        return AesSuccessActionDataResult_Decrypted(data: var_data);
      case 1:
        var var_reason = sse_decode_String(deserializer);
        return AesSuccessActionDataResult_ErrorStatus(reason: var_reason);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  BackupFailedData sse_decode_backup_failed_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_error = sse_decode_String(deserializer);
    return BackupFailedData(error: var_error);
  }

  @protected
  BackupStatus sse_decode_backup_status(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_backedUp = sse_decode_bool(deserializer);
    var var_lastBackupTime = sse_decode_opt_box_autoadd_u_64(deserializer);
    return BackupStatus(backedUp: var_backedUp, lastBackupTime: var_lastBackupTime);
  }

  @protected
  BindingEventListener sse_decode_binding_event_listener(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return BindingEventListener();
  }

  @protected
  BitcoinAddressData sse_decode_bitcoin_address_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_address = sse_decode_String(deserializer);
    var var_network = sse_decode_network(deserializer);
    var var_amountSat = sse_decode_opt_box_autoadd_u_64(deserializer);
    var var_label = sse_decode_opt_String(deserializer);
    var var_message = sse_decode_opt_String(deserializer);
    return BitcoinAddressData(
      address: var_address,
      network: var_network,
      amountSat: var_amountSat,
      label: var_label,
      message: var_message,
    );
  }

  @protected
  bool sse_decode_bool(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8() != 0;
  }

  @protected
  AesSuccessActionDataDecrypted sse_decode_box_autoadd_aes_success_action_data_decrypted(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_aes_success_action_data_decrypted(deserializer));
  }

  @protected
  AesSuccessActionDataResult sse_decode_box_autoadd_aes_success_action_data_result(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_aes_success_action_data_result(deserializer));
  }

  @protected
  BackupFailedData sse_decode_box_autoadd_backup_failed_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_backup_failed_data(deserializer));
  }

  @protected
  BindingEventListener sse_decode_box_autoadd_binding_event_listener(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_binding_event_listener(deserializer));
  }

  @protected
  BitcoinAddressData sse_decode_box_autoadd_bitcoin_address_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_bitcoin_address_data(deserializer));
  }

  @protected
  bool sse_decode_box_autoadd_bool(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_bool(deserializer));
  }

  @protected
  BreezEvent sse_decode_box_autoadd_breez_event(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_breez_event(deserializer));
  }

  @protected
  BuyBitcoinRequest sse_decode_box_autoadd_buy_bitcoin_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_buy_bitcoin_request(deserializer));
  }

  @protected
  CheckMessageRequest sse_decode_box_autoadd_check_message_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_check_message_request(deserializer));
  }

  @protected
  ClosedChannelPaymentDetails sse_decode_box_autoadd_closed_channel_payment_details(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_closed_channel_payment_details(deserializer));
  }

  @protected
  ConfigureNodeRequest sse_decode_box_autoadd_configure_node_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_configure_node_request(deserializer));
  }

  @protected
  ConnectRequest sse_decode_box_autoadd_connect_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_connect_request(deserializer));
  }

  @protected
  GreenlightCredentials sse_decode_box_autoadd_greenlight_credentials(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_greenlight_credentials(deserializer));
  }

  @protected
  GreenlightDeviceCredentials sse_decode_box_autoadd_greenlight_device_credentials(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_greenlight_device_credentials(deserializer));
  }

  @protected
  GreenlightNodeConfig sse_decode_box_autoadd_greenlight_node_config(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_greenlight_node_config(deserializer));
  }

  @protected
  PlatformInt64 sse_decode_box_autoadd_i_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_i_64(deserializer));
  }

  @protected
  InvoicePaidDetails sse_decode_box_autoadd_invoice_paid_details(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_invoice_paid_details(deserializer));
  }

  @protected
  LevelFilter sse_decode_box_autoadd_level_filter(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_level_filter(deserializer));
  }

  @protected
  ListPaymentsRequest sse_decode_box_autoadd_list_payments_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_list_payments_request(deserializer));
  }

  @protected
  ListSwapsRequest sse_decode_box_autoadd_list_swaps_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_list_swaps_request(deserializer));
  }

  @protected
  LNInvoice sse_decode_box_autoadd_ln_invoice(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ln_invoice(deserializer));
  }

  @protected
  LnPaymentDetails sse_decode_box_autoadd_ln_payment_details(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ln_payment_details(deserializer));
  }

  @protected
  LnUrlAuthRequestData sse_decode_box_autoadd_ln_url_auth_request_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ln_url_auth_request_data(deserializer));
  }

  @protected
  LnUrlErrorData sse_decode_box_autoadd_ln_url_error_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ln_url_error_data(deserializer));
  }

  @protected
  LnUrlPayErrorData sse_decode_box_autoadd_ln_url_pay_error_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ln_url_pay_error_data(deserializer));
  }

  @protected
  LnUrlPayRequest sse_decode_box_autoadd_ln_url_pay_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ln_url_pay_request(deserializer));
  }

  @protected
  LnUrlPayRequestData sse_decode_box_autoadd_ln_url_pay_request_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ln_url_pay_request_data(deserializer));
  }

  @protected
  LnUrlPaySuccessData sse_decode_box_autoadd_ln_url_pay_success_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ln_url_pay_success_data(deserializer));
  }

  @protected
  LnUrlWithdrawRequest sse_decode_box_autoadd_ln_url_withdraw_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ln_url_withdraw_request(deserializer));
  }

  @protected
  LnUrlWithdrawRequestData sse_decode_box_autoadd_ln_url_withdraw_request_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ln_url_withdraw_request_data(deserializer));
  }

  @protected
  LnUrlWithdrawSuccessData sse_decode_box_autoadd_ln_url_withdraw_success_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ln_url_withdraw_success_data(deserializer));
  }

  @protected
  LspInformation sse_decode_box_autoadd_lsp_information(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_lsp_information(deserializer));
  }

  @protected
  MessageSuccessActionData sse_decode_box_autoadd_message_success_action_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_message_success_action_data(deserializer));
  }

  @protected
  NodeConfig sse_decode_box_autoadd_node_config(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_node_config(deserializer));
  }

  @protected
  NodeCredentials sse_decode_box_autoadd_node_credentials(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_node_credentials(deserializer));
  }

  @protected
  OpenChannelFeeRequest sse_decode_box_autoadd_open_channel_fee_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_open_channel_fee_request(deserializer));
  }

  @protected
  OpeningFeeParams sse_decode_box_autoadd_opening_fee_params(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_opening_fee_params(deserializer));
  }

  @protected
  PayOnchainRequest sse_decode_box_autoadd_pay_onchain_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_pay_onchain_request(deserializer));
  }

  @protected
  Payment sse_decode_box_autoadd_payment(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_payment(deserializer));
  }

  @protected
  PaymentFailedData sse_decode_box_autoadd_payment_failed_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_payment_failed_data(deserializer));
  }

  @protected
  PrepareOnchainPaymentRequest sse_decode_box_autoadd_prepare_onchain_payment_request(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_prepare_onchain_payment_request(deserializer));
  }

  @protected
  PrepareRedeemOnchainFundsRequest sse_decode_box_autoadd_prepare_redeem_onchain_funds_request(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_prepare_redeem_onchain_funds_request(deserializer));
  }

  @protected
  PrepareRefundRequest sse_decode_box_autoadd_prepare_refund_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_prepare_refund_request(deserializer));
  }

  @protected
  ReceiveOnchainRequest sse_decode_box_autoadd_receive_onchain_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_receive_onchain_request(deserializer));
  }

  @protected
  ReceivePaymentRequest sse_decode_box_autoadd_receive_payment_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_receive_payment_request(deserializer));
  }

  @protected
  RedeemOnchainFundsRequest sse_decode_box_autoadd_redeem_onchain_funds_request(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_redeem_onchain_funds_request(deserializer));
  }

  @protected
  RefundRequest sse_decode_box_autoadd_refund_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_refund_request(deserializer));
  }

  @protected
  ReportIssueRequest sse_decode_box_autoadd_report_issue_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_report_issue_request(deserializer));
  }

  @protected
  ReportPaymentFailureDetails sse_decode_box_autoadd_report_payment_failure_details(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_report_payment_failure_details(deserializer));
  }

  @protected
  ReverseSwapFeesRequest sse_decode_box_autoadd_reverse_swap_fees_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_reverse_swap_fees_request(deserializer));
  }

  @protected
  ReverseSwapInfo sse_decode_box_autoadd_reverse_swap_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_reverse_swap_info(deserializer));
  }

  @protected
  SendPaymentRequest sse_decode_box_autoadd_send_payment_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_send_payment_request(deserializer));
  }

  @protected
  SendSpontaneousPaymentRequest sse_decode_box_autoadd_send_spontaneous_payment_request(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_send_spontaneous_payment_request(deserializer));
  }

  @protected
  SignMessageRequest sse_decode_box_autoadd_sign_message_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_sign_message_request(deserializer));
  }

  @protected
  StaticBackupRequest sse_decode_box_autoadd_static_backup_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_static_backup_request(deserializer));
  }

  @protected
  SuccessActionProcessed sse_decode_box_autoadd_success_action_processed(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_success_action_processed(deserializer));
  }

  @protected
  SwapInfo sse_decode_box_autoadd_swap_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_swap_info(deserializer));
  }

  @protected
  Symbol sse_decode_box_autoadd_symbol(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_symbol(deserializer));
  }

  @protected
  int sse_decode_box_autoadd_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_u_32(deserializer));
  }

  @protected
  BigInt sse_decode_box_autoadd_u_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_u_64(deserializer));
  }

  @protected
  UrlSuccessActionData sse_decode_box_autoadd_url_success_action_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_url_success_action_data(deserializer));
  }

  @protected
  BreezEvent sse_decode_breez_event(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_block = sse_decode_u_32(deserializer);
        return BreezEvent_NewBlock(block: var_block);
      case 1:
        var var_details = sse_decode_box_autoadd_invoice_paid_details(deserializer);
        return BreezEvent_InvoicePaid(details: var_details);
      case 2:
        return BreezEvent_Synced();
      case 3:
        var var_details = sse_decode_box_autoadd_payment(deserializer);
        return BreezEvent_PaymentSucceed(details: var_details);
      case 4:
        var var_details = sse_decode_box_autoadd_payment_failed_data(deserializer);
        return BreezEvent_PaymentFailed(details: var_details);
      case 5:
        return BreezEvent_BackupStarted();
      case 6:
        return BreezEvent_BackupSucceeded();
      case 7:
        var var_details = sse_decode_box_autoadd_backup_failed_data(deserializer);
        return BreezEvent_BackupFailed(details: var_details);
      case 8:
        var var_details = sse_decode_box_autoadd_reverse_swap_info(deserializer);
        return BreezEvent_ReverseSwapUpdated(details: var_details);
      case 9:
        var var_details = sse_decode_box_autoadd_swap_info(deserializer);
        return BreezEvent_SwapUpdated(details: var_details);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  BuyBitcoinProvider sse_decode_buy_bitcoin_provider(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return BuyBitcoinProvider.values[inner];
  }

  @protected
  BuyBitcoinRequest sse_decode_buy_bitcoin_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_provider = sse_decode_buy_bitcoin_provider(deserializer);
    var var_openingFeeParams = sse_decode_opt_box_autoadd_opening_fee_params(deserializer);
    var var_redirectUrl = sse_decode_opt_String(deserializer);
    return BuyBitcoinRequest(
      provider: var_provider,
      openingFeeParams: var_openingFeeParams,
      redirectUrl: var_redirectUrl,
    );
  }

  @protected
  BuyBitcoinResponse sse_decode_buy_bitcoin_response(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_url = sse_decode_String(deserializer);
    var var_openingFeeParams = sse_decode_opt_box_autoadd_opening_fee_params(deserializer);
    return BuyBitcoinResponse(url: var_url, openingFeeParams: var_openingFeeParams);
  }

  @protected
  ChannelState sse_decode_channel_state(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return ChannelState.values[inner];
  }

  @protected
  CheckMessageRequest sse_decode_check_message_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_message = sse_decode_String(deserializer);
    var var_pubkey = sse_decode_String(deserializer);
    var var_signature = sse_decode_String(deserializer);
    return CheckMessageRequest(message: var_message, pubkey: var_pubkey, signature: var_signature);
  }

  @protected
  CheckMessageResponse sse_decode_check_message_response(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_isValid = sse_decode_bool(deserializer);
    return CheckMessageResponse(isValid: var_isValid);
  }

  @protected
  ClosedChannelPaymentDetails sse_decode_closed_channel_payment_details(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_state = sse_decode_channel_state(deserializer);
    var var_fundingTxid = sse_decode_String(deserializer);
    var var_shortChannelId = sse_decode_opt_String(deserializer);
    var var_closingTxid = sse_decode_opt_String(deserializer);
    return ClosedChannelPaymentDetails(
      state: var_state,
      fundingTxid: var_fundingTxid,
      shortChannelId: var_shortChannelId,
      closingTxid: var_closingTxid,
    );
  }

  @protected
  Config sse_decode_config(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_breezserver = sse_decode_String(deserializer);
    var var_chainnotifierUrl = sse_decode_String(deserializer);
    var var_mempoolspaceUrl = sse_decode_opt_String(deserializer);
    var var_workingDir = sse_decode_String(deserializer);
    var var_network = sse_decode_network(deserializer);
    var var_paymentTimeoutSec = sse_decode_u_32(deserializer);
    var var_defaultLspId = sse_decode_opt_String(deserializer);
    var var_apiKey = sse_decode_opt_String(deserializer);
    var var_maxfeePercent = sse_decode_f_64(deserializer);
    var var_exemptfeeMsat = sse_decode_u_64(deserializer);
    var var_nodeConfig = sse_decode_node_config(deserializer);
    return Config(
      breezserver: var_breezserver,
      chainnotifierUrl: var_chainnotifierUrl,
      mempoolspaceUrl: var_mempoolspaceUrl,
      workingDir: var_workingDir,
      network: var_network,
      paymentTimeoutSec: var_paymentTimeoutSec,
      defaultLspId: var_defaultLspId,
      apiKey: var_apiKey,
      maxfeePercent: var_maxfeePercent,
      exemptfeeMsat: var_exemptfeeMsat,
      nodeConfig: var_nodeConfig,
    );
  }

  @protected
  ConfigureNodeRequest sse_decode_configure_node_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_closeToAddress = sse_decode_opt_String(deserializer);
    return ConfigureNodeRequest(closeToAddress: var_closeToAddress);
  }

  @protected
  ConnectRequest sse_decode_connect_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_config = sse_decode_config(deserializer);
    var var_seed = sse_decode_list_prim_u_8_strict(deserializer);
    var var_restoreOnly = sse_decode_opt_box_autoadd_bool(deserializer);
    return ConnectRequest(config: var_config, seed: var_seed, restoreOnly: var_restoreOnly);
  }

  @protected
  CurrencyInfo sse_decode_currency_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_name = sse_decode_String(deserializer);
    var var_fractionSize = sse_decode_u_32(deserializer);
    var var_spacing = sse_decode_opt_box_autoadd_u_32(deserializer);
    var var_symbol = sse_decode_opt_box_autoadd_symbol(deserializer);
    var var_uniqSymbol = sse_decode_opt_box_autoadd_symbol(deserializer);
    var var_localizedName = sse_decode_list_localized_name(deserializer);
    var var_localeOverrides = sse_decode_list_locale_overrides(deserializer);
    return CurrencyInfo(
      name: var_name,
      fractionSize: var_fractionSize,
      spacing: var_spacing,
      symbol: var_symbol,
      uniqSymbol: var_uniqSymbol,
      localizedName: var_localizedName,
      localeOverrides: var_localeOverrides,
    );
  }

  @protected
  EnvironmentType sse_decode_environment_type(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return EnvironmentType.values[inner];
  }

  @protected
  double sse_decode_f_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getFloat64();
  }

  @protected
  FiatCurrency sse_decode_fiat_currency(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_id = sse_decode_String(deserializer);
    var var_info = sse_decode_currency_info(deserializer);
    return FiatCurrency(id: var_id, info: var_info);
  }

  @protected
  GreenlightCredentials sse_decode_greenlight_credentials(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_developerKey = sse_decode_list_prim_u_8_strict(deserializer);
    var var_developerCert = sse_decode_list_prim_u_8_strict(deserializer);
    return GreenlightCredentials(developerKey: var_developerKey, developerCert: var_developerCert);
  }

  @protected
  GreenlightDeviceCredentials sse_decode_greenlight_device_credentials(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_device = sse_decode_list_prim_u_8_strict(deserializer);
    return GreenlightDeviceCredentials(device: var_device);
  }

  @protected
  GreenlightNodeConfig sse_decode_greenlight_node_config(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_partnerCredentials = sse_decode_opt_box_autoadd_greenlight_credentials(deserializer);
    var var_inviteCode = sse_decode_opt_String(deserializer);
    return GreenlightNodeConfig(partnerCredentials: var_partnerCredentials, inviteCode: var_inviteCode);
  }

  @protected
  HealthCheckStatus sse_decode_health_check_status(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return HealthCheckStatus.values[inner];
  }

  @protected
  int sse_decode_i_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getInt32();
  }

  @protected
  PlatformInt64 sse_decode_i_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getPlatformInt64();
  }

  @protected
  InputType sse_decode_input_type(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_address = sse_decode_box_autoadd_bitcoin_address_data(deserializer);
        return InputType_BitcoinAddress(address: var_address);
      case 1:
        var var_invoice = sse_decode_box_autoadd_ln_invoice(deserializer);
        return InputType_Bolt11(invoice: var_invoice);
      case 2:
        var var_nodeId = sse_decode_String(deserializer);
        return InputType_NodeId(nodeId: var_nodeId);
      case 3:
        var var_url = sse_decode_String(deserializer);
        return InputType_Url(url: var_url);
      case 4:
        var var_data = sse_decode_box_autoadd_ln_url_pay_request_data(deserializer);
        var var_bip353Address = sse_decode_opt_String(deserializer);
        return InputType_LnUrlPay(data: var_data, bip353Address: var_bip353Address);
      case 5:
        var var_data = sse_decode_box_autoadd_ln_url_withdraw_request_data(deserializer);
        return InputType_LnUrlWithdraw(data: var_data);
      case 6:
        var var_data = sse_decode_box_autoadd_ln_url_auth_request_data(deserializer);
        return InputType_LnUrlAuth(data: var_data);
      case 7:
        var var_data = sse_decode_box_autoadd_ln_url_error_data(deserializer);
        return InputType_LnUrlError(data: var_data);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  InvoicePaidDetails sse_decode_invoice_paid_details(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_paymentHash = sse_decode_String(deserializer);
    var var_bolt11 = sse_decode_String(deserializer);
    var var_payment = sse_decode_opt_box_autoadd_payment(deserializer);
    return InvoicePaidDetails(paymentHash: var_paymentHash, bolt11: var_bolt11, payment: var_payment);
  }

  @protected
  LevelFilter sse_decode_level_filter(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return LevelFilter.values[inner];
  }

  @protected
  List<String> sse_decode_list_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <String>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_String(deserializer));
    }
    return ans_;
  }

  @protected
  List<FiatCurrency> sse_decode_list_fiat_currency(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <FiatCurrency>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_fiat_currency(deserializer));
    }
    return ans_;
  }

  @protected
  List<LocaleOverrides> sse_decode_list_locale_overrides(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <LocaleOverrides>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_locale_overrides(deserializer));
    }
    return ans_;
  }

  @protected
  List<LocalizedName> sse_decode_list_localized_name(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <LocalizedName>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_localized_name(deserializer));
    }
    return ans_;
  }

  @protected
  List<LspInformation> sse_decode_list_lsp_information(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <LspInformation>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_lsp_information(deserializer));
    }
    return ans_;
  }

  @protected
  List<MetadataFilter> sse_decode_list_metadata_filter(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <MetadataFilter>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_metadata_filter(deserializer));
    }
    return ans_;
  }

  @protected
  List<OpeningFeeParams> sse_decode_list_opening_fee_params(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <OpeningFeeParams>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_opening_fee_params(deserializer));
    }
    return ans_;
  }

  @protected
  List<Payment> sse_decode_list_payment(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <Payment>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_payment(deserializer));
    }
    return ans_;
  }

  @protected
  List<PaymentTypeFilter> sse_decode_list_payment_type_filter(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <PaymentTypeFilter>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_payment_type_filter(deserializer));
    }
    return ans_;
  }

  @protected
  ListPaymentsRequest sse_decode_list_payments_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_filters = sse_decode_opt_list_payment_type_filter(deserializer);
    var var_metadataFilters = sse_decode_opt_list_metadata_filter(deserializer);
    var var_fromTimestamp = sse_decode_opt_box_autoadd_i_64(deserializer);
    var var_toTimestamp = sse_decode_opt_box_autoadd_i_64(deserializer);
    var var_includeFailures = sse_decode_opt_box_autoadd_bool(deserializer);
    var var_offset = sse_decode_opt_box_autoadd_u_32(deserializer);
    var var_limit = sse_decode_opt_box_autoadd_u_32(deserializer);
    return ListPaymentsRequest(
      filters: var_filters,
      metadataFilters: var_metadataFilters,
      fromTimestamp: var_fromTimestamp,
      toTimestamp: var_toTimestamp,
      includeFailures: var_includeFailures,
      offset: var_offset,
      limit: var_limit,
    );
  }

  @protected
  Uint8List sse_decode_list_prim_u_8_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint8List(len_);
  }

  @protected
  List<Rate> sse_decode_list_rate(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <Rate>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_rate(deserializer));
    }
    return ans_;
  }

  @protected
  List<ReverseSwapInfo> sse_decode_list_reverse_swap_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <ReverseSwapInfo>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_reverse_swap_info(deserializer));
    }
    return ans_;
  }

  @protected
  List<RouteHint> sse_decode_list_route_hint(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <RouteHint>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_route_hint(deserializer));
    }
    return ans_;
  }

  @protected
  List<RouteHintHop> sse_decode_list_route_hint_hop(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <RouteHintHop>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_route_hint_hop(deserializer));
    }
    return ans_;
  }

  @protected
  List<SwapInfo> sse_decode_list_swap_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <SwapInfo>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_swap_info(deserializer));
    }
    return ans_;
  }

  @protected
  List<SwapStatus> sse_decode_list_swap_status(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <SwapStatus>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_swap_status(deserializer));
    }
    return ans_;
  }

  @protected
  ListSwapsRequest sse_decode_list_swaps_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_status = sse_decode_opt_list_swap_status(deserializer);
    var var_fromTimestamp = sse_decode_opt_box_autoadd_i_64(deserializer);
    var var_toTimestamp = sse_decode_opt_box_autoadd_i_64(deserializer);
    var var_offset = sse_decode_opt_box_autoadd_u_32(deserializer);
    var var_limit = sse_decode_opt_box_autoadd_u_32(deserializer);
    return ListSwapsRequest(
      status: var_status,
      fromTimestamp: var_fromTimestamp,
      toTimestamp: var_toTimestamp,
      offset: var_offset,
      limit: var_limit,
    );
  }

  @protected
  List<TlvEntry> sse_decode_list_tlv_entry(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <TlvEntry>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_tlv_entry(deserializer));
    }
    return ans_;
  }

  @protected
  List<UnspentTransactionOutput> sse_decode_list_unspent_transaction_output(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <UnspentTransactionOutput>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_unspent_transaction_output(deserializer));
    }
    return ans_;
  }

  @protected
  LNInvoice sse_decode_ln_invoice(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_bolt11 = sse_decode_String(deserializer);
    var var_network = sse_decode_network(deserializer);
    var var_payeePubkey = sse_decode_String(deserializer);
    var var_paymentHash = sse_decode_String(deserializer);
    var var_description = sse_decode_opt_String(deserializer);
    var var_descriptionHash = sse_decode_opt_String(deserializer);
    var var_amountMsat = sse_decode_opt_box_autoadd_u_64(deserializer);
    var var_timestamp = sse_decode_u_64(deserializer);
    var var_expiry = sse_decode_u_64(deserializer);
    var var_routingHints = sse_decode_list_route_hint(deserializer);
    var var_paymentSecret = sse_decode_list_prim_u_8_strict(deserializer);
    var var_minFinalCltvExpiryDelta = sse_decode_u_64(deserializer);
    return LNInvoice(
      bolt11: var_bolt11,
      network: var_network,
      payeePubkey: var_payeePubkey,
      paymentHash: var_paymentHash,
      description: var_description,
      descriptionHash: var_descriptionHash,
      amountMsat: var_amountMsat,
      timestamp: var_timestamp,
      expiry: var_expiry,
      routingHints: var_routingHints,
      paymentSecret: var_paymentSecret,
      minFinalCltvExpiryDelta: var_minFinalCltvExpiryDelta,
    );
  }

  @protected
  LnPaymentDetails sse_decode_ln_payment_details(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_paymentHash = sse_decode_String(deserializer);
    var var_label = sse_decode_String(deserializer);
    var var_destinationPubkey = sse_decode_String(deserializer);
    var var_paymentPreimage = sse_decode_String(deserializer);
    var var_keysend = sse_decode_bool(deserializer);
    var var_bolt11 = sse_decode_String(deserializer);
    var var_openChannelBolt11 = sse_decode_opt_String(deserializer);
    var var_lnurlSuccessAction = sse_decode_opt_box_autoadd_success_action_processed(deserializer);
    var var_lnurlPayDomain = sse_decode_opt_String(deserializer);
    var var_lnurlPayComment = sse_decode_opt_String(deserializer);
    var var_lnAddress = sse_decode_opt_String(deserializer);
    var var_lnurlMetadata = sse_decode_opt_String(deserializer);
    var var_lnurlWithdrawEndpoint = sse_decode_opt_String(deserializer);
    var var_swapInfo = sse_decode_opt_box_autoadd_swap_info(deserializer);
    var var_reverseSwapInfo = sse_decode_opt_box_autoadd_reverse_swap_info(deserializer);
    var var_pendingExpirationBlock = sse_decode_opt_box_autoadd_u_32(deserializer);
    return LnPaymentDetails(
      paymentHash: var_paymentHash,
      label: var_label,
      destinationPubkey: var_destinationPubkey,
      paymentPreimage: var_paymentPreimage,
      keysend: var_keysend,
      bolt11: var_bolt11,
      openChannelBolt11: var_openChannelBolt11,
      lnurlSuccessAction: var_lnurlSuccessAction,
      lnurlPayDomain: var_lnurlPayDomain,
      lnurlPayComment: var_lnurlPayComment,
      lnAddress: var_lnAddress,
      lnurlMetadata: var_lnurlMetadata,
      lnurlWithdrawEndpoint: var_lnurlWithdrawEndpoint,
      swapInfo: var_swapInfo,
      reverseSwapInfo: var_reverseSwapInfo,
      pendingExpirationBlock: var_pendingExpirationBlock,
    );
  }

  @protected
  LnUrlAuthRequestData sse_decode_ln_url_auth_request_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_k1 = sse_decode_String(deserializer);
    var var_action = sse_decode_opt_String(deserializer);
    var var_domain = sse_decode_String(deserializer);
    var var_url = sse_decode_String(deserializer);
    return LnUrlAuthRequestData(k1: var_k1, action: var_action, domain: var_domain, url: var_url);
  }

  @protected
  LnUrlCallbackStatus sse_decode_ln_url_callback_status(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        return LnUrlCallbackStatus_Ok();
      case 1:
        var var_data = sse_decode_box_autoadd_ln_url_error_data(deserializer);
        return LnUrlCallbackStatus_ErrorStatus(data: var_data);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  LnUrlErrorData sse_decode_ln_url_error_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_reason = sse_decode_String(deserializer);
    return LnUrlErrorData(reason: var_reason);
  }

  @protected
  LnUrlPayErrorData sse_decode_ln_url_pay_error_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_paymentHash = sse_decode_String(deserializer);
    var var_reason = sse_decode_String(deserializer);
    return LnUrlPayErrorData(paymentHash: var_paymentHash, reason: var_reason);
  }

  @protected
  LnUrlPayRequest sse_decode_ln_url_pay_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_data = sse_decode_ln_url_pay_request_data(deserializer);
    var var_amountMsat = sse_decode_u_64(deserializer);
    var var_useTrampoline = sse_decode_bool(deserializer);
    var var_comment = sse_decode_opt_String(deserializer);
    var var_paymentLabel = sse_decode_opt_String(deserializer);
    var var_validateSuccessActionUrl = sse_decode_opt_box_autoadd_bool(deserializer);
    return LnUrlPayRequest(
      data: var_data,
      amountMsat: var_amountMsat,
      useTrampoline: var_useTrampoline,
      comment: var_comment,
      paymentLabel: var_paymentLabel,
      validateSuccessActionUrl: var_validateSuccessActionUrl,
    );
  }

  @protected
  LnUrlPayRequestData sse_decode_ln_url_pay_request_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_callback = sse_decode_String(deserializer);
    var var_minSendable = sse_decode_u_64(deserializer);
    var var_maxSendable = sse_decode_u_64(deserializer);
    var var_metadataStr = sse_decode_String(deserializer);
    var var_commentAllowed = sse_decode_u_16(deserializer);
    var var_domain = sse_decode_String(deserializer);
    var var_allowsNostr = sse_decode_bool(deserializer);
    var var_nostrPubkey = sse_decode_opt_String(deserializer);
    var var_lnAddress = sse_decode_opt_String(deserializer);
    return LnUrlPayRequestData(
      callback: var_callback,
      minSendable: var_minSendable,
      maxSendable: var_maxSendable,
      metadataStr: var_metadataStr,
      commentAllowed: var_commentAllowed,
      domain: var_domain,
      allowsNostr: var_allowsNostr,
      nostrPubkey: var_nostrPubkey,
      lnAddress: var_lnAddress,
    );
  }

  @protected
  LnUrlPayResult sse_decode_ln_url_pay_result(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_data = sse_decode_box_autoadd_ln_url_pay_success_data(deserializer);
        return LnUrlPayResult_EndpointSuccess(data: var_data);
      case 1:
        var var_data = sse_decode_box_autoadd_ln_url_error_data(deserializer);
        return LnUrlPayResult_EndpointError(data: var_data);
      case 2:
        var var_data = sse_decode_box_autoadd_ln_url_pay_error_data(deserializer);
        return LnUrlPayResult_PayError(data: var_data);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  LnUrlPaySuccessData sse_decode_ln_url_pay_success_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_payment = sse_decode_payment(deserializer);
    var var_successAction = sse_decode_opt_box_autoadd_success_action_processed(deserializer);
    return LnUrlPaySuccessData(payment: var_payment, successAction: var_successAction);
  }

  @protected
  LnUrlWithdrawRequest sse_decode_ln_url_withdraw_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_data = sse_decode_ln_url_withdraw_request_data(deserializer);
    var var_amountMsat = sse_decode_u_64(deserializer);
    var var_description = sse_decode_opt_String(deserializer);
    return LnUrlWithdrawRequest(data: var_data, amountMsat: var_amountMsat, description: var_description);
  }

  @protected
  LnUrlWithdrawRequestData sse_decode_ln_url_withdraw_request_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_callback = sse_decode_String(deserializer);
    var var_k1 = sse_decode_String(deserializer);
    var var_defaultDescription = sse_decode_String(deserializer);
    var var_minWithdrawable = sse_decode_u_64(deserializer);
    var var_maxWithdrawable = sse_decode_u_64(deserializer);
    return LnUrlWithdrawRequestData(
      callback: var_callback,
      k1: var_k1,
      defaultDescription: var_defaultDescription,
      minWithdrawable: var_minWithdrawable,
      maxWithdrawable: var_maxWithdrawable,
    );
  }

  @protected
  LnUrlWithdrawResult sse_decode_ln_url_withdraw_result(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_data = sse_decode_box_autoadd_ln_url_withdraw_success_data(deserializer);
        return LnUrlWithdrawResult_Ok(data: var_data);
      case 1:
        var var_data = sse_decode_box_autoadd_ln_url_withdraw_success_data(deserializer);
        return LnUrlWithdrawResult_Timeout(data: var_data);
      case 2:
        var var_data = sse_decode_box_autoadd_ln_url_error_data(deserializer);
        return LnUrlWithdrawResult_ErrorStatus(data: var_data);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  LnUrlWithdrawSuccessData sse_decode_ln_url_withdraw_success_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_invoice = sse_decode_ln_invoice(deserializer);
    return LnUrlWithdrawSuccessData(invoice: var_invoice);
  }

  @protected
  LocaleOverrides sse_decode_locale_overrides(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_locale = sse_decode_String(deserializer);
    var var_spacing = sse_decode_opt_box_autoadd_u_32(deserializer);
    var var_symbol = sse_decode_symbol(deserializer);
    return LocaleOverrides(locale: var_locale, spacing: var_spacing, symbol: var_symbol);
  }

  @protected
  LocalizedName sse_decode_localized_name(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_locale = sse_decode_String(deserializer);
    var var_name = sse_decode_String(deserializer);
    return LocalizedName(locale: var_locale, name: var_name);
  }

  @protected
  LogEntry sse_decode_log_entry(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_line = sse_decode_String(deserializer);
    var var_level = sse_decode_String(deserializer);
    return LogEntry(line: var_line, level: var_level);
  }

  @protected
  LspInformation sse_decode_lsp_information(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_id = sse_decode_String(deserializer);
    var var_name = sse_decode_String(deserializer);
    var var_widgetUrl = sse_decode_String(deserializer);
    var var_pubkey = sse_decode_String(deserializer);
    var var_host = sse_decode_String(deserializer);
    var var_baseFeeMsat = sse_decode_i_64(deserializer);
    var var_feeRate = sse_decode_f_64(deserializer);
    var var_timeLockDelta = sse_decode_u_32(deserializer);
    var var_minHtlcMsat = sse_decode_i_64(deserializer);
    var var_lspPubkey = sse_decode_list_prim_u_8_strict(deserializer);
    var var_openingFeeParamsList = sse_decode_opening_fee_params_menu(deserializer);
    return LspInformation(
      id: var_id,
      name: var_name,
      widgetUrl: var_widgetUrl,
      pubkey: var_pubkey,
      host: var_host,
      baseFeeMsat: var_baseFeeMsat,
      feeRate: var_feeRate,
      timeLockDelta: var_timeLockDelta,
      minHtlcMsat: var_minHtlcMsat,
      lspPubkey: var_lspPubkey,
      openingFeeParamsList: var_openingFeeParamsList,
    );
  }

  @protected
  MessageSuccessActionData sse_decode_message_success_action_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_message = sse_decode_String(deserializer);
    return MessageSuccessActionData(message: var_message);
  }

  @protected
  MetadataFilter sse_decode_metadata_filter(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_jsonPath = sse_decode_String(deserializer);
    var var_jsonValue = sse_decode_String(deserializer);
    return MetadataFilter(jsonPath: var_jsonPath, jsonValue: var_jsonValue);
  }

  @protected
  Network sse_decode_network(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return Network.values[inner];
  }

  @protected
  NodeConfig sse_decode_node_config(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_config = sse_decode_box_autoadd_greenlight_node_config(deserializer);
        return NodeConfig_Greenlight(config: var_config);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  NodeCredentials sse_decode_node_credentials(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_credentials = sse_decode_box_autoadd_greenlight_device_credentials(deserializer);
        return NodeCredentials_Greenlight(credentials: var_credentials);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  NodeState sse_decode_node_state(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_id = sse_decode_String(deserializer);
    var var_blockHeight = sse_decode_u_32(deserializer);
    var var_channelsBalanceMsat = sse_decode_u_64(deserializer);
    var var_onchainBalanceMsat = sse_decode_u_64(deserializer);
    var var_pendingOnchainBalanceMsat = sse_decode_u_64(deserializer);
    var var_utxos = sse_decode_list_unspent_transaction_output(deserializer);
    var var_maxPayableMsat = sse_decode_u_64(deserializer);
    var var_maxReceivableMsat = sse_decode_u_64(deserializer);
    var var_maxSinglePaymentAmountMsat = sse_decode_u_64(deserializer);
    var var_maxChanReserveMsats = sse_decode_u_64(deserializer);
    var var_connectedPeers = sse_decode_list_String(deserializer);
    var var_maxReceivableSinglePaymentAmountMsat = sse_decode_u_64(deserializer);
    var var_totalInboundLiquidityMsats = sse_decode_u_64(deserializer);
    return NodeState(
      id: var_id,
      blockHeight: var_blockHeight,
      channelsBalanceMsat: var_channelsBalanceMsat,
      onchainBalanceMsat: var_onchainBalanceMsat,
      pendingOnchainBalanceMsat: var_pendingOnchainBalanceMsat,
      utxos: var_utxos,
      maxPayableMsat: var_maxPayableMsat,
      maxReceivableMsat: var_maxReceivableMsat,
      maxSinglePaymentAmountMsat: var_maxSinglePaymentAmountMsat,
      maxChanReserveMsats: var_maxChanReserveMsats,
      connectedPeers: var_connectedPeers,
      maxReceivableSinglePaymentAmountMsat: var_maxReceivableSinglePaymentAmountMsat,
      totalInboundLiquidityMsats: var_totalInboundLiquidityMsats,
    );
  }

  @protected
  OnchainPaymentLimitsResponse sse_decode_onchain_payment_limits_response(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_minSat = sse_decode_u_64(deserializer);
    var var_maxSat = sse_decode_u_64(deserializer);
    var var_maxPayableSat = sse_decode_u_64(deserializer);
    return OnchainPaymentLimitsResponse(
      minSat: var_minSat,
      maxSat: var_maxSat,
      maxPayableSat: var_maxPayableSat,
    );
  }

  @protected
  OpenChannelFeeRequest sse_decode_open_channel_fee_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_amountMsat = sse_decode_opt_box_autoadd_u_64(deserializer);
    var var_expiry = sse_decode_opt_box_autoadd_u_32(deserializer);
    return OpenChannelFeeRequest(amountMsat: var_amountMsat, expiry: var_expiry);
  }

  @protected
  OpenChannelFeeResponse sse_decode_open_channel_fee_response(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_feeMsat = sse_decode_opt_box_autoadd_u_64(deserializer);
    var var_feeParams = sse_decode_opening_fee_params(deserializer);
    return OpenChannelFeeResponse(feeMsat: var_feeMsat, feeParams: var_feeParams);
  }

  @protected
  OpeningFeeParams sse_decode_opening_fee_params(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_minMsat = sse_decode_u_64(deserializer);
    var var_proportional = sse_decode_u_32(deserializer);
    var var_validUntil = sse_decode_String(deserializer);
    var var_maxIdleTime = sse_decode_u_32(deserializer);
    var var_maxClientToSelfDelay = sse_decode_u_32(deserializer);
    var var_promise = sse_decode_String(deserializer);
    return OpeningFeeParams(
      minMsat: var_minMsat,
      proportional: var_proportional,
      validUntil: var_validUntil,
      maxIdleTime: var_maxIdleTime,
      maxClientToSelfDelay: var_maxClientToSelfDelay,
      promise: var_promise,
    );
  }

  @protected
  OpeningFeeParamsMenu sse_decode_opening_fee_params_menu(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_values = sse_decode_list_opening_fee_params(deserializer);
    return OpeningFeeParamsMenu(values: var_values);
  }

  @protected
  String? sse_decode_opt_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_String(deserializer));
    } else {
      return null;
    }
  }

  @protected
  bool? sse_decode_opt_box_autoadd_bool(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_bool(deserializer));
    } else {
      return null;
    }
  }

  @protected
  GreenlightCredentials? sse_decode_opt_box_autoadd_greenlight_credentials(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_greenlight_credentials(deserializer));
    } else {
      return null;
    }
  }

  @protected
  PlatformInt64? sse_decode_opt_box_autoadd_i_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_i_64(deserializer));
    } else {
      return null;
    }
  }

  @protected
  LevelFilter? sse_decode_opt_box_autoadd_level_filter(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_level_filter(deserializer));
    } else {
      return null;
    }
  }

  @protected
  LNInvoice? sse_decode_opt_box_autoadd_ln_invoice(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_ln_invoice(deserializer));
    } else {
      return null;
    }
  }

  @protected
  LspInformation? sse_decode_opt_box_autoadd_lsp_information(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_lsp_information(deserializer));
    } else {
      return null;
    }
  }

  @protected
  NodeCredentials? sse_decode_opt_box_autoadd_node_credentials(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_node_credentials(deserializer));
    } else {
      return null;
    }
  }

  @protected
  OpeningFeeParams? sse_decode_opt_box_autoadd_opening_fee_params(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_opening_fee_params(deserializer));
    } else {
      return null;
    }
  }

  @protected
  Payment? sse_decode_opt_box_autoadd_payment(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_payment(deserializer));
    } else {
      return null;
    }
  }

  @protected
  ReverseSwapInfo? sse_decode_opt_box_autoadd_reverse_swap_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_reverse_swap_info(deserializer));
    } else {
      return null;
    }
  }

  @protected
  SuccessActionProcessed? sse_decode_opt_box_autoadd_success_action_processed(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_success_action_processed(deserializer));
    } else {
      return null;
    }
  }

  @protected
  SwapInfo? sse_decode_opt_box_autoadd_swap_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_swap_info(deserializer));
    } else {
      return null;
    }
  }

  @protected
  Symbol? sse_decode_opt_box_autoadd_symbol(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_symbol(deserializer));
    } else {
      return null;
    }
  }

  @protected
  int? sse_decode_opt_box_autoadd_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_u_32(deserializer));
    } else {
      return null;
    }
  }

  @protected
  BigInt? sse_decode_opt_box_autoadd_u_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_u_64(deserializer));
    } else {
      return null;
    }
  }

  @protected
  List<String>? sse_decode_opt_list_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_list_String(deserializer));
    } else {
      return null;
    }
  }

  @protected
  List<MetadataFilter>? sse_decode_opt_list_metadata_filter(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_list_metadata_filter(deserializer));
    } else {
      return null;
    }
  }

  @protected
  List<PaymentTypeFilter>? sse_decode_opt_list_payment_type_filter(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_list_payment_type_filter(deserializer));
    } else {
      return null;
    }
  }

  @protected
  Uint8List? sse_decode_opt_list_prim_u_8_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_list_prim_u_8_strict(deserializer));
    } else {
      return null;
    }
  }

  @protected
  List<SwapStatus>? sse_decode_opt_list_swap_status(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_list_swap_status(deserializer));
    } else {
      return null;
    }
  }

  @protected
  List<TlvEntry>? sse_decode_opt_list_tlv_entry(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_list_tlv_entry(deserializer));
    } else {
      return null;
    }
  }

  @protected
  PayOnchainRequest sse_decode_pay_onchain_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_recipientAddress = sse_decode_String(deserializer);
    var var_prepareRes = sse_decode_prepare_onchain_payment_response(deserializer);
    return PayOnchainRequest(recipientAddress: var_recipientAddress, prepareRes: var_prepareRes);
  }

  @protected
  PayOnchainResponse sse_decode_pay_onchain_response(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_reverseSwapInfo = sse_decode_reverse_swap_info(deserializer);
    return PayOnchainResponse(reverseSwapInfo: var_reverseSwapInfo);
  }

  @protected
  Payment sse_decode_payment(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_id = sse_decode_String(deserializer);
    var var_paymentType = sse_decode_payment_type(deserializer);
    var var_paymentTime = sse_decode_i_64(deserializer);
    var var_amountMsat = sse_decode_u_64(deserializer);
    var var_feeMsat = sse_decode_u_64(deserializer);
    var var_status = sse_decode_payment_status(deserializer);
    var var_error = sse_decode_opt_String(deserializer);
    var var_description = sse_decode_opt_String(deserializer);
    var var_details = sse_decode_payment_details(deserializer);
    var var_metadata = sse_decode_opt_String(deserializer);
    return Payment(
      id: var_id,
      paymentType: var_paymentType,
      paymentTime: var_paymentTime,
      amountMsat: var_amountMsat,
      feeMsat: var_feeMsat,
      status: var_status,
      error: var_error,
      description: var_description,
      details: var_details,
      metadata: var_metadata,
    );
  }

  @protected
  PaymentDetails sse_decode_payment_details(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_data = sse_decode_box_autoadd_ln_payment_details(deserializer);
        return PaymentDetails_Ln(data: var_data);
      case 1:
        var var_data = sse_decode_box_autoadd_closed_channel_payment_details(deserializer);
        return PaymentDetails_ClosedChannel(data: var_data);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  PaymentFailedData sse_decode_payment_failed_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_error = sse_decode_String(deserializer);
    var var_nodeId = sse_decode_String(deserializer);
    var var_invoice = sse_decode_opt_box_autoadd_ln_invoice(deserializer);
    var var_label = sse_decode_opt_String(deserializer);
    return PaymentFailedData(error: var_error, nodeId: var_nodeId, invoice: var_invoice, label: var_label);
  }

  @protected
  PaymentStatus sse_decode_payment_status(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return PaymentStatus.values[inner];
  }

  @protected
  PaymentType sse_decode_payment_type(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return PaymentType.values[inner];
  }

  @protected
  PaymentTypeFilter sse_decode_payment_type_filter(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return PaymentTypeFilter.values[inner];
  }

  @protected
  PrepareOnchainPaymentRequest sse_decode_prepare_onchain_payment_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_amountSat = sse_decode_u_64(deserializer);
    var var_amountType = sse_decode_swap_amount_type(deserializer);
    var var_claimTxFeerate = sse_decode_u_32(deserializer);
    return PrepareOnchainPaymentRequest(
      amountSat: var_amountSat,
      amountType: var_amountType,
      claimTxFeerate: var_claimTxFeerate,
    );
  }

  @protected
  PrepareOnchainPaymentResponse sse_decode_prepare_onchain_payment_response(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_feesHash = sse_decode_String(deserializer);
    var var_feesPercentage = sse_decode_f_64(deserializer);
    var var_feesLockup = sse_decode_u_64(deserializer);
    var var_feesClaim = sse_decode_u_64(deserializer);
    var var_senderAmountSat = sse_decode_u_64(deserializer);
    var var_recipientAmountSat = sse_decode_u_64(deserializer);
    var var_totalFees = sse_decode_u_64(deserializer);
    return PrepareOnchainPaymentResponse(
      feesHash: var_feesHash,
      feesPercentage: var_feesPercentage,
      feesLockup: var_feesLockup,
      feesClaim: var_feesClaim,
      senderAmountSat: var_senderAmountSat,
      recipientAmountSat: var_recipientAmountSat,
      totalFees: var_totalFees,
    );
  }

  @protected
  PrepareRedeemOnchainFundsRequest sse_decode_prepare_redeem_onchain_funds_request(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_toAddress = sse_decode_String(deserializer);
    var var_satPerVbyte = sse_decode_u_32(deserializer);
    return PrepareRedeemOnchainFundsRequest(toAddress: var_toAddress, satPerVbyte: var_satPerVbyte);
  }

  @protected
  PrepareRedeemOnchainFundsResponse sse_decode_prepare_redeem_onchain_funds_response(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_txWeight = sse_decode_u_64(deserializer);
    var var_txFeeSat = sse_decode_u_64(deserializer);
    return PrepareRedeemOnchainFundsResponse(txWeight: var_txWeight, txFeeSat: var_txFeeSat);
  }

  @protected
  PrepareRefundRequest sse_decode_prepare_refund_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_swapAddress = sse_decode_String(deserializer);
    var var_toAddress = sse_decode_String(deserializer);
    var var_satPerVbyte = sse_decode_u_32(deserializer);
    var var_unilateral = sse_decode_opt_box_autoadd_bool(deserializer);
    return PrepareRefundRequest(
      swapAddress: var_swapAddress,
      toAddress: var_toAddress,
      satPerVbyte: var_satPerVbyte,
      unilateral: var_unilateral,
    );
  }

  @protected
  PrepareRefundResponse sse_decode_prepare_refund_response(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_refundTxWeight = sse_decode_u_32(deserializer);
    var var_refundTxFeeSat = sse_decode_u_64(deserializer);
    return PrepareRefundResponse(refundTxWeight: var_refundTxWeight, refundTxFeeSat: var_refundTxFeeSat);
  }

  @protected
  Rate sse_decode_rate(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_coin = sse_decode_String(deserializer);
    var var_value = sse_decode_f_64(deserializer);
    return Rate(coin: var_coin, value: var_value);
  }

  @protected
  ReceiveOnchainRequest sse_decode_receive_onchain_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_openingFeeParams = sse_decode_opt_box_autoadd_opening_fee_params(deserializer);
    return ReceiveOnchainRequest(openingFeeParams: var_openingFeeParams);
  }

  @protected
  ReceivePaymentRequest sse_decode_receive_payment_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_amountMsat = sse_decode_u_64(deserializer);
    var var_description = sse_decode_String(deserializer);
    var var_preimage = sse_decode_opt_list_prim_u_8_strict(deserializer);
    var var_openingFeeParams = sse_decode_opt_box_autoadd_opening_fee_params(deserializer);
    var var_useDescriptionHash = sse_decode_opt_box_autoadd_bool(deserializer);
    var var_expiry = sse_decode_opt_box_autoadd_u_32(deserializer);
    var var_cltv = sse_decode_opt_box_autoadd_u_32(deserializer);
    return ReceivePaymentRequest(
      amountMsat: var_amountMsat,
      description: var_description,
      preimage: var_preimage,
      openingFeeParams: var_openingFeeParams,
      useDescriptionHash: var_useDescriptionHash,
      expiry: var_expiry,
      cltv: var_cltv,
    );
  }

  @protected
  ReceivePaymentResponse sse_decode_receive_payment_response(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_lnInvoice = sse_decode_ln_invoice(deserializer);
    var var_openingFeeParams = sse_decode_opt_box_autoadd_opening_fee_params(deserializer);
    var var_openingFeeMsat = sse_decode_opt_box_autoadd_u_64(deserializer);
    return ReceivePaymentResponse(
      lnInvoice: var_lnInvoice,
      openingFeeParams: var_openingFeeParams,
      openingFeeMsat: var_openingFeeMsat,
    );
  }

  @protected
  RecommendedFees sse_decode_recommended_fees(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_fastestFee = sse_decode_u_64(deserializer);
    var var_halfHourFee = sse_decode_u_64(deserializer);
    var var_hourFee = sse_decode_u_64(deserializer);
    var var_economyFee = sse_decode_u_64(deserializer);
    var var_minimumFee = sse_decode_u_64(deserializer);
    return RecommendedFees(
      fastestFee: var_fastestFee,
      halfHourFee: var_halfHourFee,
      hourFee: var_hourFee,
      economyFee: var_economyFee,
      minimumFee: var_minimumFee,
    );
  }

  @protected
  RedeemOnchainFundsRequest sse_decode_redeem_onchain_funds_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_toAddress = sse_decode_String(deserializer);
    var var_satPerVbyte = sse_decode_u_32(deserializer);
    return RedeemOnchainFundsRequest(toAddress: var_toAddress, satPerVbyte: var_satPerVbyte);
  }

  @protected
  RedeemOnchainFundsResponse sse_decode_redeem_onchain_funds_response(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_txid = sse_decode_list_prim_u_8_strict(deserializer);
    return RedeemOnchainFundsResponse(txid: var_txid);
  }

  @protected
  RefundRequest sse_decode_refund_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_swapAddress = sse_decode_String(deserializer);
    var var_toAddress = sse_decode_String(deserializer);
    var var_satPerVbyte = sse_decode_u_32(deserializer);
    var var_unilateral = sse_decode_opt_box_autoadd_bool(deserializer);
    return RefundRequest(
      swapAddress: var_swapAddress,
      toAddress: var_toAddress,
      satPerVbyte: var_satPerVbyte,
      unilateral: var_unilateral,
    );
  }

  @protected
  RefundResponse sse_decode_refund_response(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_refundTxId = sse_decode_String(deserializer);
    return RefundResponse(refundTxId: var_refundTxId);
  }

  @protected
  ReportIssueRequest sse_decode_report_issue_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_data = sse_decode_box_autoadd_report_payment_failure_details(deserializer);
        return ReportIssueRequest_PaymentFailure(data: var_data);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  ReportPaymentFailureDetails sse_decode_report_payment_failure_details(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_paymentHash = sse_decode_String(deserializer);
    var var_comment = sse_decode_opt_String(deserializer);
    return ReportPaymentFailureDetails(paymentHash: var_paymentHash, comment: var_comment);
  }

  @protected
  ReverseSwapFeesRequest sse_decode_reverse_swap_fees_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_sendAmountSat = sse_decode_opt_box_autoadd_u_64(deserializer);
    var var_claimTxFeerate = sse_decode_opt_box_autoadd_u_32(deserializer);
    return ReverseSwapFeesRequest(sendAmountSat: var_sendAmountSat, claimTxFeerate: var_claimTxFeerate);
  }

  @protected
  ReverseSwapInfo sse_decode_reverse_swap_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_id = sse_decode_String(deserializer);
    var var_claimPubkey = sse_decode_String(deserializer);
    var var_lockupTxid = sse_decode_opt_String(deserializer);
    var var_claimTxid = sse_decode_opt_String(deserializer);
    var var_onchainAmountSat = sse_decode_u_64(deserializer);
    var var_status = sse_decode_reverse_swap_status(deserializer);
    return ReverseSwapInfo(
      id: var_id,
      claimPubkey: var_claimPubkey,
      lockupTxid: var_lockupTxid,
      claimTxid: var_claimTxid,
      onchainAmountSat: var_onchainAmountSat,
      status: var_status,
    );
  }

  @protected
  ReverseSwapPairInfo sse_decode_reverse_swap_pair_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_min = sse_decode_u_64(deserializer);
    var var_max = sse_decode_u_64(deserializer);
    var var_feesHash = sse_decode_String(deserializer);
    var var_feesPercentage = sse_decode_f_64(deserializer);
    var var_feesLockup = sse_decode_u_64(deserializer);
    var var_feesClaim = sse_decode_u_64(deserializer);
    var var_totalFees = sse_decode_opt_box_autoadd_u_64(deserializer);
    return ReverseSwapPairInfo(
      min: var_min,
      max: var_max,
      feesHash: var_feesHash,
      feesPercentage: var_feesPercentage,
      feesLockup: var_feesLockup,
      feesClaim: var_feesClaim,
      totalFees: var_totalFees,
    );
  }

  @protected
  ReverseSwapStatus sse_decode_reverse_swap_status(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return ReverseSwapStatus.values[inner];
  }

  @protected
  RouteHint sse_decode_route_hint(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_hops = sse_decode_list_route_hint_hop(deserializer);
    return RouteHint(hops: var_hops);
  }

  @protected
  RouteHintHop sse_decode_route_hint_hop(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_srcNodeId = sse_decode_String(deserializer);
    var var_shortChannelId = sse_decode_String(deserializer);
    var var_feesBaseMsat = sse_decode_u_32(deserializer);
    var var_feesProportionalMillionths = sse_decode_u_32(deserializer);
    var var_cltvExpiryDelta = sse_decode_u_64(deserializer);
    var var_htlcMinimumMsat = sse_decode_opt_box_autoadd_u_64(deserializer);
    var var_htlcMaximumMsat = sse_decode_opt_box_autoadd_u_64(deserializer);
    return RouteHintHop(
      srcNodeId: var_srcNodeId,
      shortChannelId: var_shortChannelId,
      feesBaseMsat: var_feesBaseMsat,
      feesProportionalMillionths: var_feesProportionalMillionths,
      cltvExpiryDelta: var_cltvExpiryDelta,
      htlcMinimumMsat: var_htlcMinimumMsat,
      htlcMaximumMsat: var_htlcMaximumMsat,
    );
  }

  @protected
  SendPaymentRequest sse_decode_send_payment_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_bolt11 = sse_decode_String(deserializer);
    var var_useTrampoline = sse_decode_bool(deserializer);
    var var_amountMsat = sse_decode_opt_box_autoadd_u_64(deserializer);
    var var_label = sse_decode_opt_String(deserializer);
    return SendPaymentRequest(
      bolt11: var_bolt11,
      useTrampoline: var_useTrampoline,
      amountMsat: var_amountMsat,
      label: var_label,
    );
  }

  @protected
  SendPaymentResponse sse_decode_send_payment_response(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_payment = sse_decode_payment(deserializer);
    return SendPaymentResponse(payment: var_payment);
  }

  @protected
  SendSpontaneousPaymentRequest sse_decode_send_spontaneous_payment_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_nodeId = sse_decode_String(deserializer);
    var var_amountMsat = sse_decode_u_64(deserializer);
    var var_extraTlvs = sse_decode_opt_list_tlv_entry(deserializer);
    var var_label = sse_decode_opt_String(deserializer);
    return SendSpontaneousPaymentRequest(
      nodeId: var_nodeId,
      amountMsat: var_amountMsat,
      extraTlvs: var_extraTlvs,
      label: var_label,
    );
  }

  @protected
  ServiceHealthCheckResponse sse_decode_service_health_check_response(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_status = sse_decode_health_check_status(deserializer);
    return ServiceHealthCheckResponse(status: var_status);
  }

  @protected
  SignMessageRequest sse_decode_sign_message_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_message = sse_decode_String(deserializer);
    return SignMessageRequest(message: var_message);
  }

  @protected
  SignMessageResponse sse_decode_sign_message_response(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_signature = sse_decode_String(deserializer);
    return SignMessageResponse(signature: var_signature);
  }

  @protected
  StaticBackupRequest sse_decode_static_backup_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_workingDir = sse_decode_String(deserializer);
    return StaticBackupRequest(workingDir: var_workingDir);
  }

  @protected
  StaticBackupResponse sse_decode_static_backup_response(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_backup = sse_decode_opt_list_String(deserializer);
    return StaticBackupResponse(backup: var_backup);
  }

  @protected
  SuccessActionProcessed sse_decode_success_action_processed(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_result = sse_decode_box_autoadd_aes_success_action_data_result(deserializer);
        return SuccessActionProcessed_Aes(result: var_result);
      case 1:
        var var_data = sse_decode_box_autoadd_message_success_action_data(deserializer);
        return SuccessActionProcessed_Message(data: var_data);
      case 2:
        var var_data = sse_decode_box_autoadd_url_success_action_data(deserializer);
        return SuccessActionProcessed_Url(data: var_data);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  SwapAmountType sse_decode_swap_amount_type(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return SwapAmountType.values[inner];
  }

  @protected
  SwapInfo sse_decode_swap_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_bitcoinAddress = sse_decode_String(deserializer);
    var var_createdAt = sse_decode_i_64(deserializer);
    var var_lockHeight = sse_decode_i_64(deserializer);
    var var_paymentHash = sse_decode_list_prim_u_8_strict(deserializer);
    var var_preimage = sse_decode_list_prim_u_8_strict(deserializer);
    var var_privateKey = sse_decode_list_prim_u_8_strict(deserializer);
    var var_publicKey = sse_decode_list_prim_u_8_strict(deserializer);
    var var_swapperPublicKey = sse_decode_list_prim_u_8_strict(deserializer);
    var var_script = sse_decode_list_prim_u_8_strict(deserializer);
    var var_bolt11 = sse_decode_opt_String(deserializer);
    var var_paidMsat = sse_decode_u_64(deserializer);
    var var_totalIncomingTxs = sse_decode_u_64(deserializer);
    var var_confirmedSats = sse_decode_u_64(deserializer);
    var var_unconfirmedSats = sse_decode_u_64(deserializer);
    var var_status = sse_decode_swap_status(deserializer);
    var var_refundTxIds = sse_decode_list_String(deserializer);
    var var_unconfirmedTxIds = sse_decode_list_String(deserializer);
    var var_confirmedTxIds = sse_decode_list_String(deserializer);
    var var_minAllowedDeposit = sse_decode_i_64(deserializer);
    var var_maxAllowedDeposit = sse_decode_i_64(deserializer);
    var var_maxSwapperPayable = sse_decode_i_64(deserializer);
    var var_lastRedeemError = sse_decode_opt_String(deserializer);
    var var_channelOpeningFees = sse_decode_opt_box_autoadd_opening_fee_params(deserializer);
    var var_confirmedAt = sse_decode_opt_box_autoadd_u_32(deserializer);
    return SwapInfo(
      bitcoinAddress: var_bitcoinAddress,
      createdAt: var_createdAt,
      lockHeight: var_lockHeight,
      paymentHash: var_paymentHash,
      preimage: var_preimage,
      privateKey: var_privateKey,
      publicKey: var_publicKey,
      swapperPublicKey: var_swapperPublicKey,
      script: var_script,
      bolt11: var_bolt11,
      paidMsat: var_paidMsat,
      totalIncomingTxs: var_totalIncomingTxs,
      confirmedSats: var_confirmedSats,
      unconfirmedSats: var_unconfirmedSats,
      status: var_status,
      refundTxIds: var_refundTxIds,
      unconfirmedTxIds: var_unconfirmedTxIds,
      confirmedTxIds: var_confirmedTxIds,
      minAllowedDeposit: var_minAllowedDeposit,
      maxAllowedDeposit: var_maxAllowedDeposit,
      maxSwapperPayable: var_maxSwapperPayable,
      lastRedeemError: var_lastRedeemError,
      channelOpeningFees: var_channelOpeningFees,
      confirmedAt: var_confirmedAt,
    );
  }

  @protected
  SwapStatus sse_decode_swap_status(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return SwapStatus.values[inner];
  }

  @protected
  Symbol sse_decode_symbol(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_grapheme = sse_decode_opt_String(deserializer);
    var var_template = sse_decode_opt_String(deserializer);
    var var_rtl = sse_decode_opt_box_autoadd_bool(deserializer);
    var var_position = sse_decode_opt_box_autoadd_u_32(deserializer);
    return Symbol(grapheme: var_grapheme, template: var_template, rtl: var_rtl, position: var_position);
  }

  @protected
  TlvEntry sse_decode_tlv_entry(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_fieldNumber = sse_decode_u_64(deserializer);
    var var_value = sse_decode_list_prim_u_8_strict(deserializer);
    return TlvEntry(fieldNumber: var_fieldNumber, value: var_value);
  }

  @protected
  int sse_decode_u_16(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint16();
  }

  @protected
  int sse_decode_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint32();
  }

  @protected
  BigInt sse_decode_u_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getBigUint64();
  }

  @protected
  int sse_decode_u_8(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8();
  }

  @protected
  void sse_decode_unit(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  UnspentTransactionOutput sse_decode_unspent_transaction_output(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_txid = sse_decode_list_prim_u_8_strict(deserializer);
    var var_outnum = sse_decode_u_32(deserializer);
    var var_amountMillisatoshi = sse_decode_u_64(deserializer);
    var var_address = sse_decode_String(deserializer);
    var var_reserved = sse_decode_bool(deserializer);
    return UnspentTransactionOutput(
      txid: var_txid,
      outnum: var_outnum,
      amountMillisatoshi: var_amountMillisatoshi,
      address: var_address,
      reserved: var_reserved,
    );
  }

  @protected
  UrlSuccessActionData sse_decode_url_success_action_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_description = sse_decode_String(deserializer);
    var var_url = sse_decode_String(deserializer);
    var var_matchesCallbackDomain = sse_decode_bool(deserializer);
    return UrlSuccessActionData(
      description: var_description,
      url: var_url,
      matchesCallbackDomain: var_matchesCallbackDomain,
    );
  }

  @protected
  bool cst_encode_bool(bool raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  int cst_encode_buy_bitcoin_provider(BuyBitcoinProvider raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return cst_encode_i_32(raw.index);
  }

  @protected
  int cst_encode_channel_state(ChannelState raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return cst_encode_i_32(raw.index);
  }

  @protected
  int cst_encode_environment_type(EnvironmentType raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return cst_encode_i_32(raw.index);
  }

  @protected
  double cst_encode_f_64(double raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  int cst_encode_health_check_status(HealthCheckStatus raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return cst_encode_i_32(raw.index);
  }

  @protected
  int cst_encode_i_32(int raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  int cst_encode_level_filter(LevelFilter raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return cst_encode_i_32(raw.index);
  }

  @protected
  int cst_encode_network(Network raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return cst_encode_i_32(raw.index);
  }

  @protected
  int cst_encode_payment_status(PaymentStatus raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return cst_encode_i_32(raw.index);
  }

  @protected
  int cst_encode_payment_type(PaymentType raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return cst_encode_i_32(raw.index);
  }

  @protected
  int cst_encode_payment_type_filter(PaymentTypeFilter raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return cst_encode_i_32(raw.index);
  }

  @protected
  int cst_encode_reverse_swap_status(ReverseSwapStatus raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return cst_encode_i_32(raw.index);
  }

  @protected
  int cst_encode_swap_amount_type(SwapAmountType raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return cst_encode_i_32(raw.index);
  }

  @protected
  int cst_encode_swap_status(SwapStatus raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return cst_encode_i_32(raw.index);
  }

  @protected
  int cst_encode_u_16(int raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  int cst_encode_u_32(int raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  int cst_encode_u_8(int raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  void cst_encode_unit(void raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  void sse_encode_AnyhowException(AnyhowException self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.message, serializer);
  }

  @protected
  void sse_encode_StreamSink_breez_event_Dco(RustStreamSink<BreezEvent> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(
      self.setupAndSerialize(
        codec: DcoCodec(
          decodeSuccessData: dco_decode_breez_event,
          decodeErrorData: dco_decode_AnyhowException,
        ),
      ),
      serializer,
    );
  }

  @protected
  void sse_encode_StreamSink_log_entry_Dco(RustStreamSink<LogEntry> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(
      self.setupAndSerialize(
        codec: DcoCodec(decodeSuccessData: dco_decode_log_entry, decodeErrorData: dco_decode_AnyhowException),
      ),
      serializer,
    );
  }

  @protected
  void sse_encode_String(String self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(utf8.encoder.convert(self), serializer);
  }

  @protected
  void sse_encode_aes_success_action_data_decrypted(
    AesSuccessActionDataDecrypted self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.description, serializer);
    sse_encode_String(self.plaintext, serializer);
  }

  @protected
  void sse_encode_aes_success_action_data_result(AesSuccessActionDataResult self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case AesSuccessActionDataResult_Decrypted(data: final data):
        sse_encode_i_32(0, serializer);
        sse_encode_box_autoadd_aes_success_action_data_decrypted(data, serializer);
      case AesSuccessActionDataResult_ErrorStatus(reason: final reason):
        sse_encode_i_32(1, serializer);
        sse_encode_String(reason, serializer);
    }
  }

  @protected
  void sse_encode_backup_failed_data(BackupFailedData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.error, serializer);
  }

  @protected
  void sse_encode_backup_status(BackupStatus self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bool(self.backedUp, serializer);
    sse_encode_opt_box_autoadd_u_64(self.lastBackupTime, serializer);
  }

  @protected
  void sse_encode_binding_event_listener(BindingEventListener self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  void sse_encode_bitcoin_address_data(BitcoinAddressData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.address, serializer);
    sse_encode_network(self.network, serializer);
    sse_encode_opt_box_autoadd_u_64(self.amountSat, serializer);
    sse_encode_opt_String(self.label, serializer);
    sse_encode_opt_String(self.message, serializer);
  }

  @protected
  void sse_encode_bool(bool self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self ? 1 : 0);
  }

  @protected
  void sse_encode_box_autoadd_aes_success_action_data_decrypted(
    AesSuccessActionDataDecrypted self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_aes_success_action_data_decrypted(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_aes_success_action_data_result(
    AesSuccessActionDataResult self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_aes_success_action_data_result(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_backup_failed_data(BackupFailedData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_backup_failed_data(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_binding_event_listener(BindingEventListener self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_binding_event_listener(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_bitcoin_address_data(BitcoinAddressData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bitcoin_address_data(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_bool(bool self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bool(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_breez_event(BreezEvent self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_breez_event(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_buy_bitcoin_request(BuyBitcoinRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_buy_bitcoin_request(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_check_message_request(CheckMessageRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_check_message_request(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_closed_channel_payment_details(
    ClosedChannelPaymentDetails self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_closed_channel_payment_details(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_configure_node_request(ConfigureNodeRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_configure_node_request(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_connect_request(ConnectRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_connect_request(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_greenlight_credentials(GreenlightCredentials self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_greenlight_credentials(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_greenlight_device_credentials(
    GreenlightDeviceCredentials self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_greenlight_device_credentials(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_greenlight_node_config(GreenlightNodeConfig self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_greenlight_node_config(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_i_64(PlatformInt64 self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_64(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_invoice_paid_details(InvoicePaidDetails self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_invoice_paid_details(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_level_filter(LevelFilter self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_level_filter(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_list_payments_request(ListPaymentsRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_payments_request(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_list_swaps_request(ListSwapsRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_swaps_request(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ln_invoice(LNInvoice self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ln_invoice(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ln_payment_details(LnPaymentDetails self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ln_payment_details(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ln_url_auth_request_data(LnUrlAuthRequestData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ln_url_auth_request_data(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ln_url_error_data(LnUrlErrorData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ln_url_error_data(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ln_url_pay_error_data(LnUrlPayErrorData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ln_url_pay_error_data(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ln_url_pay_request(LnUrlPayRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ln_url_pay_request(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ln_url_pay_request_data(LnUrlPayRequestData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ln_url_pay_request_data(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ln_url_pay_success_data(LnUrlPaySuccessData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ln_url_pay_success_data(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ln_url_withdraw_request(LnUrlWithdrawRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ln_url_withdraw_request(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ln_url_withdraw_request_data(
    LnUrlWithdrawRequestData self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ln_url_withdraw_request_data(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ln_url_withdraw_success_data(
    LnUrlWithdrawSuccessData self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ln_url_withdraw_success_data(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_lsp_information(LspInformation self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_lsp_information(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_message_success_action_data(
    MessageSuccessActionData self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_message_success_action_data(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_node_config(NodeConfig self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_node_config(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_node_credentials(NodeCredentials self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_node_credentials(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_open_channel_fee_request(OpenChannelFeeRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_open_channel_fee_request(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_opening_fee_params(OpeningFeeParams self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_opening_fee_params(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_pay_onchain_request(PayOnchainRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_pay_onchain_request(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_payment(Payment self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_payment(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_payment_failed_data(PaymentFailedData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_payment_failed_data(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_prepare_onchain_payment_request(
    PrepareOnchainPaymentRequest self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_prepare_onchain_payment_request(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_prepare_redeem_onchain_funds_request(
    PrepareRedeemOnchainFundsRequest self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_prepare_redeem_onchain_funds_request(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_prepare_refund_request(PrepareRefundRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_prepare_refund_request(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_receive_onchain_request(ReceiveOnchainRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_receive_onchain_request(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_receive_payment_request(ReceivePaymentRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_receive_payment_request(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_redeem_onchain_funds_request(
    RedeemOnchainFundsRequest self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_redeem_onchain_funds_request(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_refund_request(RefundRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_refund_request(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_report_issue_request(ReportIssueRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_report_issue_request(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_report_payment_failure_details(
    ReportPaymentFailureDetails self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_report_payment_failure_details(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_reverse_swap_fees_request(
    ReverseSwapFeesRequest self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_reverse_swap_fees_request(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_reverse_swap_info(ReverseSwapInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_reverse_swap_info(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_send_payment_request(SendPaymentRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_send_payment_request(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_send_spontaneous_payment_request(
    SendSpontaneousPaymentRequest self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_send_spontaneous_payment_request(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_sign_message_request(SignMessageRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_sign_message_request(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_static_backup_request(StaticBackupRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_static_backup_request(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_success_action_processed(
    SuccessActionProcessed self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_success_action_processed(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_swap_info(SwapInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_swap_info(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_symbol(Symbol self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_symbol(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_u_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_32(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_u_64(BigInt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_64(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_url_success_action_data(UrlSuccessActionData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_url_success_action_data(self, serializer);
  }

  @protected
  void sse_encode_breez_event(BreezEvent self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case BreezEvent_NewBlock(block: final block):
        sse_encode_i_32(0, serializer);
        sse_encode_u_32(block, serializer);
      case BreezEvent_InvoicePaid(details: final details):
        sse_encode_i_32(1, serializer);
        sse_encode_box_autoadd_invoice_paid_details(details, serializer);
      case BreezEvent_Synced():
        sse_encode_i_32(2, serializer);
      case BreezEvent_PaymentSucceed(details: final details):
        sse_encode_i_32(3, serializer);
        sse_encode_box_autoadd_payment(details, serializer);
      case BreezEvent_PaymentFailed(details: final details):
        sse_encode_i_32(4, serializer);
        sse_encode_box_autoadd_payment_failed_data(details, serializer);
      case BreezEvent_BackupStarted():
        sse_encode_i_32(5, serializer);
      case BreezEvent_BackupSucceeded():
        sse_encode_i_32(6, serializer);
      case BreezEvent_BackupFailed(details: final details):
        sse_encode_i_32(7, serializer);
        sse_encode_box_autoadd_backup_failed_data(details, serializer);
      case BreezEvent_ReverseSwapUpdated(details: final details):
        sse_encode_i_32(8, serializer);
        sse_encode_box_autoadd_reverse_swap_info(details, serializer);
      case BreezEvent_SwapUpdated(details: final details):
        sse_encode_i_32(9, serializer);
        sse_encode_box_autoadd_swap_info(details, serializer);
    }
  }

  @protected
  void sse_encode_buy_bitcoin_provider(BuyBitcoinProvider self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_buy_bitcoin_request(BuyBitcoinRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_buy_bitcoin_provider(self.provider, serializer);
    sse_encode_opt_box_autoadd_opening_fee_params(self.openingFeeParams, serializer);
    sse_encode_opt_String(self.redirectUrl, serializer);
  }

  @protected
  void sse_encode_buy_bitcoin_response(BuyBitcoinResponse self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.url, serializer);
    sse_encode_opt_box_autoadd_opening_fee_params(self.openingFeeParams, serializer);
  }

  @protected
  void sse_encode_channel_state(ChannelState self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_check_message_request(CheckMessageRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.message, serializer);
    sse_encode_String(self.pubkey, serializer);
    sse_encode_String(self.signature, serializer);
  }

  @protected
  void sse_encode_check_message_response(CheckMessageResponse self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bool(self.isValid, serializer);
  }

  @protected
  void sse_encode_closed_channel_payment_details(ClosedChannelPaymentDetails self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_channel_state(self.state, serializer);
    sse_encode_String(self.fundingTxid, serializer);
    sse_encode_opt_String(self.shortChannelId, serializer);
    sse_encode_opt_String(self.closingTxid, serializer);
  }

  @protected
  void sse_encode_config(Config self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.breezserver, serializer);
    sse_encode_String(self.chainnotifierUrl, serializer);
    sse_encode_opt_String(self.mempoolspaceUrl, serializer);
    sse_encode_String(self.workingDir, serializer);
    sse_encode_network(self.network, serializer);
    sse_encode_u_32(self.paymentTimeoutSec, serializer);
    sse_encode_opt_String(self.defaultLspId, serializer);
    sse_encode_opt_String(self.apiKey, serializer);
    sse_encode_f_64(self.maxfeePercent, serializer);
    sse_encode_u_64(self.exemptfeeMsat, serializer);
    sse_encode_node_config(self.nodeConfig, serializer);
  }

  @protected
  void sse_encode_configure_node_request(ConfigureNodeRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_opt_String(self.closeToAddress, serializer);
  }

  @protected
  void sse_encode_connect_request(ConnectRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_config(self.config, serializer);
    sse_encode_list_prim_u_8_strict(self.seed, serializer);
    sse_encode_opt_box_autoadd_bool(self.restoreOnly, serializer);
  }

  @protected
  void sse_encode_currency_info(CurrencyInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.name, serializer);
    sse_encode_u_32(self.fractionSize, serializer);
    sse_encode_opt_box_autoadd_u_32(self.spacing, serializer);
    sse_encode_opt_box_autoadd_symbol(self.symbol, serializer);
    sse_encode_opt_box_autoadd_symbol(self.uniqSymbol, serializer);
    sse_encode_list_localized_name(self.localizedName, serializer);
    sse_encode_list_locale_overrides(self.localeOverrides, serializer);
  }

  @protected
  void sse_encode_environment_type(EnvironmentType self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_f_64(double self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putFloat64(self);
  }

  @protected
  void sse_encode_fiat_currency(FiatCurrency self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.id, serializer);
    sse_encode_currency_info(self.info, serializer);
  }

  @protected
  void sse_encode_greenlight_credentials(GreenlightCredentials self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(self.developerKey, serializer);
    sse_encode_list_prim_u_8_strict(self.developerCert, serializer);
  }

  @protected
  void sse_encode_greenlight_device_credentials(GreenlightDeviceCredentials self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(self.device, serializer);
  }

  @protected
  void sse_encode_greenlight_node_config(GreenlightNodeConfig self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_opt_box_autoadd_greenlight_credentials(self.partnerCredentials, serializer);
    sse_encode_opt_String(self.inviteCode, serializer);
  }

  @protected
  void sse_encode_health_check_status(HealthCheckStatus self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_i_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putInt32(self);
  }

  @protected
  void sse_encode_i_64(PlatformInt64 self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putPlatformInt64(self);
  }

  @protected
  void sse_encode_input_type(InputType self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case InputType_BitcoinAddress(address: final address):
        sse_encode_i_32(0, serializer);
        sse_encode_box_autoadd_bitcoin_address_data(address, serializer);
      case InputType_Bolt11(invoice: final invoice):
        sse_encode_i_32(1, serializer);
        sse_encode_box_autoadd_ln_invoice(invoice, serializer);
      case InputType_NodeId(nodeId: final nodeId):
        sse_encode_i_32(2, serializer);
        sse_encode_String(nodeId, serializer);
      case InputType_Url(url: final url):
        sse_encode_i_32(3, serializer);
        sse_encode_String(url, serializer);
      case InputType_LnUrlPay(data: final data, bip353Address: final bip353Address):
        sse_encode_i_32(4, serializer);
        sse_encode_box_autoadd_ln_url_pay_request_data(data, serializer);
        sse_encode_opt_String(bip353Address, serializer);
      case InputType_LnUrlWithdraw(data: final data):
        sse_encode_i_32(5, serializer);
        sse_encode_box_autoadd_ln_url_withdraw_request_data(data, serializer);
      case InputType_LnUrlAuth(data: final data):
        sse_encode_i_32(6, serializer);
        sse_encode_box_autoadd_ln_url_auth_request_data(data, serializer);
      case InputType_LnUrlError(data: final data):
        sse_encode_i_32(7, serializer);
        sse_encode_box_autoadd_ln_url_error_data(data, serializer);
    }
  }

  @protected
  void sse_encode_invoice_paid_details(InvoicePaidDetails self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.paymentHash, serializer);
    sse_encode_String(self.bolt11, serializer);
    sse_encode_opt_box_autoadd_payment(self.payment, serializer);
  }

  @protected
  void sse_encode_level_filter(LevelFilter self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_list_String(List<String> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_String(item, serializer);
    }
  }

  @protected
  void sse_encode_list_fiat_currency(List<FiatCurrency> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_fiat_currency(item, serializer);
    }
  }

  @protected
  void sse_encode_list_locale_overrides(List<LocaleOverrides> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_locale_overrides(item, serializer);
    }
  }

  @protected
  void sse_encode_list_localized_name(List<LocalizedName> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_localized_name(item, serializer);
    }
  }

  @protected
  void sse_encode_list_lsp_information(List<LspInformation> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_lsp_information(item, serializer);
    }
  }

  @protected
  void sse_encode_list_metadata_filter(List<MetadataFilter> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_metadata_filter(item, serializer);
    }
  }

  @protected
  void sse_encode_list_opening_fee_params(List<OpeningFeeParams> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_opening_fee_params(item, serializer);
    }
  }

  @protected
  void sse_encode_list_payment(List<Payment> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_payment(item, serializer);
    }
  }

  @protected
  void sse_encode_list_payment_type_filter(List<PaymentTypeFilter> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_payment_type_filter(item, serializer);
    }
  }

  @protected
  void sse_encode_list_payments_request(ListPaymentsRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_opt_list_payment_type_filter(self.filters, serializer);
    sse_encode_opt_list_metadata_filter(self.metadataFilters, serializer);
    sse_encode_opt_box_autoadd_i_64(self.fromTimestamp, serializer);
    sse_encode_opt_box_autoadd_i_64(self.toTimestamp, serializer);
    sse_encode_opt_box_autoadd_bool(self.includeFailures, serializer);
    sse_encode_opt_box_autoadd_u_32(self.offset, serializer);
    sse_encode_opt_box_autoadd_u_32(self.limit, serializer);
  }

  @protected
  void sse_encode_list_prim_u_8_strict(Uint8List self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putUint8List(self);
  }

  @protected
  void sse_encode_list_rate(List<Rate> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_rate(item, serializer);
    }
  }

  @protected
  void sse_encode_list_reverse_swap_info(List<ReverseSwapInfo> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_reverse_swap_info(item, serializer);
    }
  }

  @protected
  void sse_encode_list_route_hint(List<RouteHint> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_route_hint(item, serializer);
    }
  }

  @protected
  void sse_encode_list_route_hint_hop(List<RouteHintHop> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_route_hint_hop(item, serializer);
    }
  }

  @protected
  void sse_encode_list_swap_info(List<SwapInfo> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_swap_info(item, serializer);
    }
  }

  @protected
  void sse_encode_list_swap_status(List<SwapStatus> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_swap_status(item, serializer);
    }
  }

  @protected
  void sse_encode_list_swaps_request(ListSwapsRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_opt_list_swap_status(self.status, serializer);
    sse_encode_opt_box_autoadd_i_64(self.fromTimestamp, serializer);
    sse_encode_opt_box_autoadd_i_64(self.toTimestamp, serializer);
    sse_encode_opt_box_autoadd_u_32(self.offset, serializer);
    sse_encode_opt_box_autoadd_u_32(self.limit, serializer);
  }

  @protected
  void sse_encode_list_tlv_entry(List<TlvEntry> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_tlv_entry(item, serializer);
    }
  }

  @protected
  void sse_encode_list_unspent_transaction_output(
    List<UnspentTransactionOutput> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_unspent_transaction_output(item, serializer);
    }
  }

  @protected
  void sse_encode_ln_invoice(LNInvoice self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.bolt11, serializer);
    sse_encode_network(self.network, serializer);
    sse_encode_String(self.payeePubkey, serializer);
    sse_encode_String(self.paymentHash, serializer);
    sse_encode_opt_String(self.description, serializer);
    sse_encode_opt_String(self.descriptionHash, serializer);
    sse_encode_opt_box_autoadd_u_64(self.amountMsat, serializer);
    sse_encode_u_64(self.timestamp, serializer);
    sse_encode_u_64(self.expiry, serializer);
    sse_encode_list_route_hint(self.routingHints, serializer);
    sse_encode_list_prim_u_8_strict(self.paymentSecret, serializer);
    sse_encode_u_64(self.minFinalCltvExpiryDelta, serializer);
  }

  @protected
  void sse_encode_ln_payment_details(LnPaymentDetails self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.paymentHash, serializer);
    sse_encode_String(self.label, serializer);
    sse_encode_String(self.destinationPubkey, serializer);
    sse_encode_String(self.paymentPreimage, serializer);
    sse_encode_bool(self.keysend, serializer);
    sse_encode_String(self.bolt11, serializer);
    sse_encode_opt_String(self.openChannelBolt11, serializer);
    sse_encode_opt_box_autoadd_success_action_processed(self.lnurlSuccessAction, serializer);
    sse_encode_opt_String(self.lnurlPayDomain, serializer);
    sse_encode_opt_String(self.lnurlPayComment, serializer);
    sse_encode_opt_String(self.lnAddress, serializer);
    sse_encode_opt_String(self.lnurlMetadata, serializer);
    sse_encode_opt_String(self.lnurlWithdrawEndpoint, serializer);
    sse_encode_opt_box_autoadd_swap_info(self.swapInfo, serializer);
    sse_encode_opt_box_autoadd_reverse_swap_info(self.reverseSwapInfo, serializer);
    sse_encode_opt_box_autoadd_u_32(self.pendingExpirationBlock, serializer);
  }

  @protected
  void sse_encode_ln_url_auth_request_data(LnUrlAuthRequestData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.k1, serializer);
    sse_encode_opt_String(self.action, serializer);
    sse_encode_String(self.domain, serializer);
    sse_encode_String(self.url, serializer);
  }

  @protected
  void sse_encode_ln_url_callback_status(LnUrlCallbackStatus self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case LnUrlCallbackStatus_Ok():
        sse_encode_i_32(0, serializer);
      case LnUrlCallbackStatus_ErrorStatus(data: final data):
        sse_encode_i_32(1, serializer);
        sse_encode_box_autoadd_ln_url_error_data(data, serializer);
    }
  }

  @protected
  void sse_encode_ln_url_error_data(LnUrlErrorData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.reason, serializer);
  }

  @protected
  void sse_encode_ln_url_pay_error_data(LnUrlPayErrorData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.paymentHash, serializer);
    sse_encode_String(self.reason, serializer);
  }

  @protected
  void sse_encode_ln_url_pay_request(LnUrlPayRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ln_url_pay_request_data(self.data, serializer);
    sse_encode_u_64(self.amountMsat, serializer);
    sse_encode_bool(self.useTrampoline, serializer);
    sse_encode_opt_String(self.comment, serializer);
    sse_encode_opt_String(self.paymentLabel, serializer);
    sse_encode_opt_box_autoadd_bool(self.validateSuccessActionUrl, serializer);
  }

  @protected
  void sse_encode_ln_url_pay_request_data(LnUrlPayRequestData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.callback, serializer);
    sse_encode_u_64(self.minSendable, serializer);
    sse_encode_u_64(self.maxSendable, serializer);
    sse_encode_String(self.metadataStr, serializer);
    sse_encode_u_16(self.commentAllowed, serializer);
    sse_encode_String(self.domain, serializer);
    sse_encode_bool(self.allowsNostr, serializer);
    sse_encode_opt_String(self.nostrPubkey, serializer);
    sse_encode_opt_String(self.lnAddress, serializer);
  }

  @protected
  void sse_encode_ln_url_pay_result(LnUrlPayResult self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case LnUrlPayResult_EndpointSuccess(data: final data):
        sse_encode_i_32(0, serializer);
        sse_encode_box_autoadd_ln_url_pay_success_data(data, serializer);
      case LnUrlPayResult_EndpointError(data: final data):
        sse_encode_i_32(1, serializer);
        sse_encode_box_autoadd_ln_url_error_data(data, serializer);
      case LnUrlPayResult_PayError(data: final data):
        sse_encode_i_32(2, serializer);
        sse_encode_box_autoadd_ln_url_pay_error_data(data, serializer);
    }
  }

  @protected
  void sse_encode_ln_url_pay_success_data(LnUrlPaySuccessData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_payment(self.payment, serializer);
    sse_encode_opt_box_autoadd_success_action_processed(self.successAction, serializer);
  }

  @protected
  void sse_encode_ln_url_withdraw_request(LnUrlWithdrawRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ln_url_withdraw_request_data(self.data, serializer);
    sse_encode_u_64(self.amountMsat, serializer);
    sse_encode_opt_String(self.description, serializer);
  }

  @protected
  void sse_encode_ln_url_withdraw_request_data(LnUrlWithdrawRequestData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.callback, serializer);
    sse_encode_String(self.k1, serializer);
    sse_encode_String(self.defaultDescription, serializer);
    sse_encode_u_64(self.minWithdrawable, serializer);
    sse_encode_u_64(self.maxWithdrawable, serializer);
  }

  @protected
  void sse_encode_ln_url_withdraw_result(LnUrlWithdrawResult self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case LnUrlWithdrawResult_Ok(data: final data):
        sse_encode_i_32(0, serializer);
        sse_encode_box_autoadd_ln_url_withdraw_success_data(data, serializer);
      case LnUrlWithdrawResult_Timeout(data: final data):
        sse_encode_i_32(1, serializer);
        sse_encode_box_autoadd_ln_url_withdraw_success_data(data, serializer);
      case LnUrlWithdrawResult_ErrorStatus(data: final data):
        sse_encode_i_32(2, serializer);
        sse_encode_box_autoadd_ln_url_error_data(data, serializer);
    }
  }

  @protected
  void sse_encode_ln_url_withdraw_success_data(LnUrlWithdrawSuccessData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ln_invoice(self.invoice, serializer);
  }

  @protected
  void sse_encode_locale_overrides(LocaleOverrides self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.locale, serializer);
    sse_encode_opt_box_autoadd_u_32(self.spacing, serializer);
    sse_encode_symbol(self.symbol, serializer);
  }

  @protected
  void sse_encode_localized_name(LocalizedName self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.locale, serializer);
    sse_encode_String(self.name, serializer);
  }

  @protected
  void sse_encode_log_entry(LogEntry self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.line, serializer);
    sse_encode_String(self.level, serializer);
  }

  @protected
  void sse_encode_lsp_information(LspInformation self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.id, serializer);
    sse_encode_String(self.name, serializer);
    sse_encode_String(self.widgetUrl, serializer);
    sse_encode_String(self.pubkey, serializer);
    sse_encode_String(self.host, serializer);
    sse_encode_i_64(self.baseFeeMsat, serializer);
    sse_encode_f_64(self.feeRate, serializer);
    sse_encode_u_32(self.timeLockDelta, serializer);
    sse_encode_i_64(self.minHtlcMsat, serializer);
    sse_encode_list_prim_u_8_strict(self.lspPubkey, serializer);
    sse_encode_opening_fee_params_menu(self.openingFeeParamsList, serializer);
  }

  @protected
  void sse_encode_message_success_action_data(MessageSuccessActionData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.message, serializer);
  }

  @protected
  void sse_encode_metadata_filter(MetadataFilter self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.jsonPath, serializer);
    sse_encode_String(self.jsonValue, serializer);
  }

  @protected
  void sse_encode_network(Network self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_node_config(NodeConfig self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case NodeConfig_Greenlight(config: final config):
        sse_encode_i_32(0, serializer);
        sse_encode_box_autoadd_greenlight_node_config(config, serializer);
    }
  }

  @protected
  void sse_encode_node_credentials(NodeCredentials self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case NodeCredentials_Greenlight(credentials: final credentials):
        sse_encode_i_32(0, serializer);
        sse_encode_box_autoadd_greenlight_device_credentials(credentials, serializer);
    }
  }

  @protected
  void sse_encode_node_state(NodeState self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.id, serializer);
    sse_encode_u_32(self.blockHeight, serializer);
    sse_encode_u_64(self.channelsBalanceMsat, serializer);
    sse_encode_u_64(self.onchainBalanceMsat, serializer);
    sse_encode_u_64(self.pendingOnchainBalanceMsat, serializer);
    sse_encode_list_unspent_transaction_output(self.utxos, serializer);
    sse_encode_u_64(self.maxPayableMsat, serializer);
    sse_encode_u_64(self.maxReceivableMsat, serializer);
    sse_encode_u_64(self.maxSinglePaymentAmountMsat, serializer);
    sse_encode_u_64(self.maxChanReserveMsats, serializer);
    sse_encode_list_String(self.connectedPeers, serializer);
    sse_encode_u_64(self.maxReceivableSinglePaymentAmountMsat, serializer);
    sse_encode_u_64(self.totalInboundLiquidityMsats, serializer);
  }

  @protected
  void sse_encode_onchain_payment_limits_response(
    OnchainPaymentLimitsResponse self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_64(self.minSat, serializer);
    sse_encode_u_64(self.maxSat, serializer);
    sse_encode_u_64(self.maxPayableSat, serializer);
  }

  @protected
  void sse_encode_open_channel_fee_request(OpenChannelFeeRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_opt_box_autoadd_u_64(self.amountMsat, serializer);
    sse_encode_opt_box_autoadd_u_32(self.expiry, serializer);
  }

  @protected
  void sse_encode_open_channel_fee_response(OpenChannelFeeResponse self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_opt_box_autoadd_u_64(self.feeMsat, serializer);
    sse_encode_opening_fee_params(self.feeParams, serializer);
  }

  @protected
  void sse_encode_opening_fee_params(OpeningFeeParams self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_64(self.minMsat, serializer);
    sse_encode_u_32(self.proportional, serializer);
    sse_encode_String(self.validUntil, serializer);
    sse_encode_u_32(self.maxIdleTime, serializer);
    sse_encode_u_32(self.maxClientToSelfDelay, serializer);
    sse_encode_String(self.promise, serializer);
  }

  @protected
  void sse_encode_opening_fee_params_menu(OpeningFeeParamsMenu self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_opening_fee_params(self.values, serializer);
  }

  @protected
  void sse_encode_opt_String(String? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_String(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_bool(bool? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_bool(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_greenlight_credentials(
    GreenlightCredentials? self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_greenlight_credentials(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_i_64(PlatformInt64? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_i_64(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_level_filter(LevelFilter? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_level_filter(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_ln_invoice(LNInvoice? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_ln_invoice(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_lsp_information(LspInformation? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_lsp_information(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_node_credentials(NodeCredentials? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_node_credentials(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_opening_fee_params(OpeningFeeParams? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_opening_fee_params(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_payment(Payment? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_payment(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_reverse_swap_info(ReverseSwapInfo? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_reverse_swap_info(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_success_action_processed(
    SuccessActionProcessed? self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_success_action_processed(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_swap_info(SwapInfo? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_swap_info(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_symbol(Symbol? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_symbol(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_u_32(int? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_u_32(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_u_64(BigInt? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_u_64(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_list_String(List<String>? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_list_String(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_list_metadata_filter(List<MetadataFilter>? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_list_metadata_filter(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_list_payment_type_filter(List<PaymentTypeFilter>? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_list_payment_type_filter(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_list_prim_u_8_strict(Uint8List? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_list_prim_u_8_strict(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_list_swap_status(List<SwapStatus>? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_list_swap_status(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_list_tlv_entry(List<TlvEntry>? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_list_tlv_entry(self, serializer);
    }
  }

  @protected
  void sse_encode_pay_onchain_request(PayOnchainRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.recipientAddress, serializer);
    sse_encode_prepare_onchain_payment_response(self.prepareRes, serializer);
  }

  @protected
  void sse_encode_pay_onchain_response(PayOnchainResponse self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_reverse_swap_info(self.reverseSwapInfo, serializer);
  }

  @protected
  void sse_encode_payment(Payment self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.id, serializer);
    sse_encode_payment_type(self.paymentType, serializer);
    sse_encode_i_64(self.paymentTime, serializer);
    sse_encode_u_64(self.amountMsat, serializer);
    sse_encode_u_64(self.feeMsat, serializer);
    sse_encode_payment_status(self.status, serializer);
    sse_encode_opt_String(self.error, serializer);
    sse_encode_opt_String(self.description, serializer);
    sse_encode_payment_details(self.details, serializer);
    sse_encode_opt_String(self.metadata, serializer);
  }

  @protected
  void sse_encode_payment_details(PaymentDetails self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case PaymentDetails_Ln(data: final data):
        sse_encode_i_32(0, serializer);
        sse_encode_box_autoadd_ln_payment_details(data, serializer);
      case PaymentDetails_ClosedChannel(data: final data):
        sse_encode_i_32(1, serializer);
        sse_encode_box_autoadd_closed_channel_payment_details(data, serializer);
    }
  }

  @protected
  void sse_encode_payment_failed_data(PaymentFailedData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.error, serializer);
    sse_encode_String(self.nodeId, serializer);
    sse_encode_opt_box_autoadd_ln_invoice(self.invoice, serializer);
    sse_encode_opt_String(self.label, serializer);
  }

  @protected
  void sse_encode_payment_status(PaymentStatus self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_payment_type(PaymentType self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_payment_type_filter(PaymentTypeFilter self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_prepare_onchain_payment_request(
    PrepareOnchainPaymentRequest self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_64(self.amountSat, serializer);
    sse_encode_swap_amount_type(self.amountType, serializer);
    sse_encode_u_32(self.claimTxFeerate, serializer);
  }

  @protected
  void sse_encode_prepare_onchain_payment_response(
    PrepareOnchainPaymentResponse self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.feesHash, serializer);
    sse_encode_f_64(self.feesPercentage, serializer);
    sse_encode_u_64(self.feesLockup, serializer);
    sse_encode_u_64(self.feesClaim, serializer);
    sse_encode_u_64(self.senderAmountSat, serializer);
    sse_encode_u_64(self.recipientAmountSat, serializer);
    sse_encode_u_64(self.totalFees, serializer);
  }

  @protected
  void sse_encode_prepare_redeem_onchain_funds_request(
    PrepareRedeemOnchainFundsRequest self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.toAddress, serializer);
    sse_encode_u_32(self.satPerVbyte, serializer);
  }

  @protected
  void sse_encode_prepare_redeem_onchain_funds_response(
    PrepareRedeemOnchainFundsResponse self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_64(self.txWeight, serializer);
    sse_encode_u_64(self.txFeeSat, serializer);
  }

  @protected
  void sse_encode_prepare_refund_request(PrepareRefundRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.swapAddress, serializer);
    sse_encode_String(self.toAddress, serializer);
    sse_encode_u_32(self.satPerVbyte, serializer);
    sse_encode_opt_box_autoadd_bool(self.unilateral, serializer);
  }

  @protected
  void sse_encode_prepare_refund_response(PrepareRefundResponse self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_32(self.refundTxWeight, serializer);
    sse_encode_u_64(self.refundTxFeeSat, serializer);
  }

  @protected
  void sse_encode_rate(Rate self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.coin, serializer);
    sse_encode_f_64(self.value, serializer);
  }

  @protected
  void sse_encode_receive_onchain_request(ReceiveOnchainRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_opt_box_autoadd_opening_fee_params(self.openingFeeParams, serializer);
  }

  @protected
  void sse_encode_receive_payment_request(ReceivePaymentRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_64(self.amountMsat, serializer);
    sse_encode_String(self.description, serializer);
    sse_encode_opt_list_prim_u_8_strict(self.preimage, serializer);
    sse_encode_opt_box_autoadd_opening_fee_params(self.openingFeeParams, serializer);
    sse_encode_opt_box_autoadd_bool(self.useDescriptionHash, serializer);
    sse_encode_opt_box_autoadd_u_32(self.expiry, serializer);
    sse_encode_opt_box_autoadd_u_32(self.cltv, serializer);
  }

  @protected
  void sse_encode_receive_payment_response(ReceivePaymentResponse self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ln_invoice(self.lnInvoice, serializer);
    sse_encode_opt_box_autoadd_opening_fee_params(self.openingFeeParams, serializer);
    sse_encode_opt_box_autoadd_u_64(self.openingFeeMsat, serializer);
  }

  @protected
  void sse_encode_recommended_fees(RecommendedFees self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_64(self.fastestFee, serializer);
    sse_encode_u_64(self.halfHourFee, serializer);
    sse_encode_u_64(self.hourFee, serializer);
    sse_encode_u_64(self.economyFee, serializer);
    sse_encode_u_64(self.minimumFee, serializer);
  }

  @protected
  void sse_encode_redeem_onchain_funds_request(RedeemOnchainFundsRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.toAddress, serializer);
    sse_encode_u_32(self.satPerVbyte, serializer);
  }

  @protected
  void sse_encode_redeem_onchain_funds_response(RedeemOnchainFundsResponse self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(self.txid, serializer);
  }

  @protected
  void sse_encode_refund_request(RefundRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.swapAddress, serializer);
    sse_encode_String(self.toAddress, serializer);
    sse_encode_u_32(self.satPerVbyte, serializer);
    sse_encode_opt_box_autoadd_bool(self.unilateral, serializer);
  }

  @protected
  void sse_encode_refund_response(RefundResponse self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.refundTxId, serializer);
  }

  @protected
  void sse_encode_report_issue_request(ReportIssueRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case ReportIssueRequest_PaymentFailure(data: final data):
        sse_encode_i_32(0, serializer);
        sse_encode_box_autoadd_report_payment_failure_details(data, serializer);
    }
  }

  @protected
  void sse_encode_report_payment_failure_details(ReportPaymentFailureDetails self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.paymentHash, serializer);
    sse_encode_opt_String(self.comment, serializer);
  }

  @protected
  void sse_encode_reverse_swap_fees_request(ReverseSwapFeesRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_opt_box_autoadd_u_64(self.sendAmountSat, serializer);
    sse_encode_opt_box_autoadd_u_32(self.claimTxFeerate, serializer);
  }

  @protected
  void sse_encode_reverse_swap_info(ReverseSwapInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.id, serializer);
    sse_encode_String(self.claimPubkey, serializer);
    sse_encode_opt_String(self.lockupTxid, serializer);
    sse_encode_opt_String(self.claimTxid, serializer);
    sse_encode_u_64(self.onchainAmountSat, serializer);
    sse_encode_reverse_swap_status(self.status, serializer);
  }

  @protected
  void sse_encode_reverse_swap_pair_info(ReverseSwapPairInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_64(self.min, serializer);
    sse_encode_u_64(self.max, serializer);
    sse_encode_String(self.feesHash, serializer);
    sse_encode_f_64(self.feesPercentage, serializer);
    sse_encode_u_64(self.feesLockup, serializer);
    sse_encode_u_64(self.feesClaim, serializer);
    sse_encode_opt_box_autoadd_u_64(self.totalFees, serializer);
  }

  @protected
  void sse_encode_reverse_swap_status(ReverseSwapStatus self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_route_hint(RouteHint self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_route_hint_hop(self.hops, serializer);
  }

  @protected
  void sse_encode_route_hint_hop(RouteHintHop self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.srcNodeId, serializer);
    sse_encode_String(self.shortChannelId, serializer);
    sse_encode_u_32(self.feesBaseMsat, serializer);
    sse_encode_u_32(self.feesProportionalMillionths, serializer);
    sse_encode_u_64(self.cltvExpiryDelta, serializer);
    sse_encode_opt_box_autoadd_u_64(self.htlcMinimumMsat, serializer);
    sse_encode_opt_box_autoadd_u_64(self.htlcMaximumMsat, serializer);
  }

  @protected
  void sse_encode_send_payment_request(SendPaymentRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.bolt11, serializer);
    sse_encode_bool(self.useTrampoline, serializer);
    sse_encode_opt_box_autoadd_u_64(self.amountMsat, serializer);
    sse_encode_opt_String(self.label, serializer);
  }

  @protected
  void sse_encode_send_payment_response(SendPaymentResponse self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_payment(self.payment, serializer);
  }

  @protected
  void sse_encode_send_spontaneous_payment_request(
    SendSpontaneousPaymentRequest self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.nodeId, serializer);
    sse_encode_u_64(self.amountMsat, serializer);
    sse_encode_opt_list_tlv_entry(self.extraTlvs, serializer);
    sse_encode_opt_String(self.label, serializer);
  }

  @protected
  void sse_encode_service_health_check_response(ServiceHealthCheckResponse self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_health_check_status(self.status, serializer);
  }

  @protected
  void sse_encode_sign_message_request(SignMessageRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.message, serializer);
  }

  @protected
  void sse_encode_sign_message_response(SignMessageResponse self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.signature, serializer);
  }

  @protected
  void sse_encode_static_backup_request(StaticBackupRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.workingDir, serializer);
  }

  @protected
  void sse_encode_static_backup_response(StaticBackupResponse self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_opt_list_String(self.backup, serializer);
  }

  @protected
  void sse_encode_success_action_processed(SuccessActionProcessed self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case SuccessActionProcessed_Aes(result: final result):
        sse_encode_i_32(0, serializer);
        sse_encode_box_autoadd_aes_success_action_data_result(result, serializer);
      case SuccessActionProcessed_Message(data: final data):
        sse_encode_i_32(1, serializer);
        sse_encode_box_autoadd_message_success_action_data(data, serializer);
      case SuccessActionProcessed_Url(data: final data):
        sse_encode_i_32(2, serializer);
        sse_encode_box_autoadd_url_success_action_data(data, serializer);
    }
  }

  @protected
  void sse_encode_swap_amount_type(SwapAmountType self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_swap_info(SwapInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.bitcoinAddress, serializer);
    sse_encode_i_64(self.createdAt, serializer);
    sse_encode_i_64(self.lockHeight, serializer);
    sse_encode_list_prim_u_8_strict(self.paymentHash, serializer);
    sse_encode_list_prim_u_8_strict(self.preimage, serializer);
    sse_encode_list_prim_u_8_strict(self.privateKey, serializer);
    sse_encode_list_prim_u_8_strict(self.publicKey, serializer);
    sse_encode_list_prim_u_8_strict(self.swapperPublicKey, serializer);
    sse_encode_list_prim_u_8_strict(self.script, serializer);
    sse_encode_opt_String(self.bolt11, serializer);
    sse_encode_u_64(self.paidMsat, serializer);
    sse_encode_u_64(self.totalIncomingTxs, serializer);
    sse_encode_u_64(self.confirmedSats, serializer);
    sse_encode_u_64(self.unconfirmedSats, serializer);
    sse_encode_swap_status(self.status, serializer);
    sse_encode_list_String(self.refundTxIds, serializer);
    sse_encode_list_String(self.unconfirmedTxIds, serializer);
    sse_encode_list_String(self.confirmedTxIds, serializer);
    sse_encode_i_64(self.minAllowedDeposit, serializer);
    sse_encode_i_64(self.maxAllowedDeposit, serializer);
    sse_encode_i_64(self.maxSwapperPayable, serializer);
    sse_encode_opt_String(self.lastRedeemError, serializer);
    sse_encode_opt_box_autoadd_opening_fee_params(self.channelOpeningFees, serializer);
    sse_encode_opt_box_autoadd_u_32(self.confirmedAt, serializer);
  }

  @protected
  void sse_encode_swap_status(SwapStatus self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_symbol(Symbol self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_opt_String(self.grapheme, serializer);
    sse_encode_opt_String(self.template, serializer);
    sse_encode_opt_box_autoadd_bool(self.rtl, serializer);
    sse_encode_opt_box_autoadd_u_32(self.position, serializer);
  }

  @protected
  void sse_encode_tlv_entry(TlvEntry self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_64(self.fieldNumber, serializer);
    sse_encode_list_prim_u_8_strict(self.value, serializer);
  }

  @protected
  void sse_encode_u_16(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint16(self);
  }

  @protected
  void sse_encode_u_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint32(self);
  }

  @protected
  void sse_encode_u_64(BigInt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putBigUint64(self);
  }

  @protected
  void sse_encode_u_8(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self);
  }

  @protected
  void sse_encode_unit(void self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  void sse_encode_unspent_transaction_output(UnspentTransactionOutput self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(self.txid, serializer);
    sse_encode_u_32(self.outnum, serializer);
    sse_encode_u_64(self.amountMillisatoshi, serializer);
    sse_encode_String(self.address, serializer);
    sse_encode_bool(self.reserved, serializer);
  }

  @protected
  void sse_encode_url_success_action_data(UrlSuccessActionData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.description, serializer);
    sse_encode_String(self.url, serializer);
    sse_encode_bool(self.matchesCallbackDomain, serializer);
  }
}
