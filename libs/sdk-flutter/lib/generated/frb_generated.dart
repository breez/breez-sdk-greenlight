// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.0.0.

// ignore_for_file: unused_import, unused_element, unnecessary_import, duplicate_ignore, invalid_use_of_internal_member, annotate_overrides, non_constant_identifier_names, curly_braces_in_flow_control_structures, prefer_const_literals_to_create_immutables, unused_field

import 'binding.dart';
import 'breez_services.dart';
import 'chain.dart';
import 'dart:async';
import 'dart:convert';
import 'fiat.dart';
import 'frb_generated.dart';
import 'frb_generated.io.dart' if (dart.library.js_interop) 'frb_generated.web.dart';
import 'input_parser.dart';
import 'invoice.dart';
import 'lnurl/pay/model.dart';
import 'lsp.dart';
import 'models.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

/// Main entrypoint of the Rust API
class BreezSdkBindings
    extends BaseEntrypoint<BreezSdkBindingsApi, BreezSdkBindingsApiImpl, BreezSdkBindingsWire> {
  @internal
  static final instance = BreezSdkBindings._();

  BreezSdkBindings._();

  /// Initialize flutter_rust_bridge
  static Future<void> init({
    BreezSdkBindingsApi? api,
    BaseHandler? handler,
    ExternalLibrary? externalLibrary,
  }) async {
    await instance.initImpl(
      api: api,
      handler: handler,
      externalLibrary: externalLibrary,
    );
  }

  /// Dispose flutter_rust_bridge
  ///
  /// The call to this function is optional, since flutter_rust_bridge (and everything else)
  /// is automatically disposed when the app stops.
  static void dispose() => instance.disposeImpl();

  @override
  ApiImplConstructor<BreezSdkBindingsApiImpl, BreezSdkBindingsWire> get apiImplConstructor =>
      BreezSdkBindingsApiImpl.new;

  @override
  WireConstructor<BreezSdkBindingsWire> get wireConstructor => BreezSdkBindingsWire.fromExternalLibrary;

  @override
  Future<void> executeRustInitializers() async {}

  @override
  ExternalLibraryLoaderConfig get defaultExternalLibraryLoaderConfig => kDefaultExternalLibraryLoaderConfig;

  @override
  String get codegenVersion => '2.0.0';

  @override
  int get rustContentHash => 847148110;

  static const kDefaultExternalLibraryLoaderConfig = ExternalLibraryLoaderConfig(
    stem: 'breez_sdk_core',
    ioDirectory: '../sdk-core/target/release/',
    webPrefix: 'pkg/',
  );
}

abstract class BreezSdkBindingsApi extends BaseApi {
  Future<void> crateBindingBackup();

  Future<BackupStatus> crateBindingBackupStatus();

  Future<void> crateBindingBindingEventListenerOnEvent(
      {required BindingEventListener that, required BreezEvent e});

  Stream<BreezEvent> crateBindingBreezEventsStream();

  Stream<LogEntry> crateBindingBreezLogStream();

  Future<BuyBitcoinResponse> crateBindingBuyBitcoin({required BuyBitcoinRequest req});

  Future<CheckMessageResponse> crateBindingCheckMessage({required CheckMessageRequest req});

  Future<void> crateBindingCloseLspChannels();

  Future<void> crateBindingConfigureNode({required ConfigureNodeRequest req});

  Future<void> crateBindingConnect({required ConnectRequest req});

  Future<void> crateBindingConnectLsp({required String lspId});

  Future<Config> crateBindingDefaultConfig(
      {required EnvironmentType envType, required String apiKey, required NodeConfig nodeConfig});

  Future<void> crateBindingDisconnect();

  Future<String> crateBindingExecuteCommand({required String command});

  Future<List<Rate>> crateBindingFetchFiatRates();

  Future<LspInformation?> crateBindingFetchLspInfo({required String id});

  Future<ReverseSwapPairInfo> crateBindingFetchReverseSwapFees({required ReverseSwapFeesRequest req});

  Future<String> crateBindingGenerateDiagnosticData();

  Future<List<ReverseSwapInfo>> crateBindingInProgressOnchainPayments();

  Future<List<ReverseSwapInfo>> crateBindingInProgressReverseSwaps();

  Future<SwapInfo?> crateBindingInProgressSwap();

  Future<bool> crateBindingIsInitialized();

  Future<List<FiatCurrency>> crateBindingListFiatCurrencies();

  Future<List<LspInformation>> crateBindingListLsps();

  Future<List<Payment>> crateBindingListPayments({required ListPaymentsRequest req});

  Future<List<SwapInfo>> crateBindingListRefundables();

  Future<LnUrlCallbackStatus> crateBindingLnurlAuth({required LnUrlAuthRequestData reqData});

  Future<LnUrlPayResult> crateBindingLnurlPay({required LnUrlPayRequest req});

  Future<LnUrlWithdrawResult> crateBindingLnurlWithdraw({required LnUrlWithdrawRequest req});

  Future<String?> crateBindingLspId();

  Future<LspInformation> crateBindingLspInfo();

  Future<MaxReverseSwapAmountResponse> crateBindingMaxReverseSwapAmount();

  Future<Uint8List> crateBindingMnemonicToSeed({required String phrase});

  Future<NodeCredentials?> crateBindingNodeCredentials();

  Future<NodeState> crateBindingNodeInfo();

  Future<OnchainPaymentLimitsResponse> crateBindingOnchainPaymentLimits();

  Future<OpenChannelFeeResponse> crateBindingOpenChannelFee({required OpenChannelFeeRequest req});

  Future<InputType> crateBindingParseInput({required String input});

  Future<LNInvoice> crateBindingParseInvoice({required String invoice});

  Future<PayOnchainResponse> crateBindingPayOnchain({required PayOnchainRequest req});

  Future<Payment?> crateBindingPaymentByHash({required String hash});

  Future<PrepareOnchainPaymentResponse> crateBindingPrepareOnchainPayment(
      {required PrepareOnchainPaymentRequest req});

  Future<PrepareRedeemOnchainFundsResponse> crateBindingPrepareRedeemOnchainFunds(
      {required PrepareRedeemOnchainFundsRequest req});

  Future<PrepareRefundResponse> crateBindingPrepareRefund({required PrepareRefundRequest req});

  Future<SwapInfo> crateBindingReceiveOnchain({required ReceiveOnchainRequest req});

  Future<ReceivePaymentResponse> crateBindingReceivePayment({required ReceivePaymentRequest req});

  Future<RecommendedFees> crateBindingRecommendedFees();

  Future<RedeemOnchainFundsResponse> crateBindingRedeemOnchainFunds({required RedeemOnchainFundsRequest req});

  Future<void> crateBindingRedeemSwap({required String swapAddress});

  Future<RefundResponse> crateBindingRefund({required RefundRequest req});

  Future<void> crateBindingRegisterWebhook({required String webhookUrl});

  Future<void> crateBindingReportIssue({required ReportIssueRequest req});

  Future<void> crateBindingRescanSwaps();

  Future<SendOnchainResponse> crateBindingSendOnchain({required SendOnchainRequest req});

  Future<SendPaymentResponse> crateBindingSendPayment({required SendPaymentRequest req});

  Future<SendPaymentResponse> crateBindingSendSpontaneousPayment(
      {required SendSpontaneousPaymentRequest req});

  Future<ServiceHealthCheckResponse> crateBindingServiceHealthCheck({required String apiKey});

  Future<void> crateBindingSetPaymentMetadata({required String hash, required String metadata});

  Future<SignMessageResponse> crateBindingSignMessage({required SignMessageRequest req});

  Future<StaticBackupResponse> crateBindingStaticBackup({required StaticBackupRequest req});

  Future<void> crateBindingSync();

  Future<void> crateBindingUnregisterWebhook({required String webhookUrl});
}

class BreezSdkBindingsApiImpl extends BreezSdkBindingsApiImplPlatform implements BreezSdkBindingsApi {
  BreezSdkBindingsApiImpl({
    required super.handler,
    required super.wire,
    required super.generalizedFrbRustBinding,
    required super.portManager,
  });

  @override
  Future<void> crateBindingBackup() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        return wire.wire__crate__binding__backup(port_);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateBindingBackupConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBindingBackupConstMeta => const TaskConstMeta(
        debugName: "backup",
        argNames: [],
      );

  @override
  Future<BackupStatus> crateBindingBackupStatus() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        return wire.wire__crate__binding__backup_status(port_);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_backup_status,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateBindingBackupStatusConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBindingBackupStatusConstMeta => const TaskConstMeta(
        debugName: "backup_status",
        argNames: [],
      );

  @override
  Future<void> crateBindingBindingEventListenerOnEvent(
      {required BindingEventListener that, required BreezEvent e}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_binding_event_listener(that);
        var arg1 = cst_encode_box_autoadd_breez_event(e);
        return wire.wire__crate__binding__binding_event_listener_on_event(port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kCrateBindingBindingEventListenerOnEventConstMeta,
      argValues: [that, e],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBindingBindingEventListenerOnEventConstMeta => const TaskConstMeta(
        debugName: "binding_event_listener_on_event",
        argNames: ["that", "e"],
      );

  @override
  Stream<BreezEvent> crateBindingBreezEventsStream() {
    final s = RustStreamSink<BreezEvent>();
    unawaited(handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_StreamSink_breez_event_Dco(s);
        return wire.wire__crate__binding__breez_events_stream(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateBindingBreezEventsStreamConstMeta,
      argValues: [s],
      apiImpl: this,
    )));
    return s.stream;
  }

  TaskConstMeta get kCrateBindingBreezEventsStreamConstMeta => const TaskConstMeta(
        debugName: "breez_events_stream",
        argNames: ["s"],
      );

  @override
  Stream<LogEntry> crateBindingBreezLogStream() {
    final s = RustStreamSink<LogEntry>();
    unawaited(handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_StreamSink_log_entry_Dco(s);
        return wire.wire__crate__binding__breez_log_stream(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateBindingBreezLogStreamConstMeta,
      argValues: [s],
      apiImpl: this,
    )));
    return s.stream;
  }

  TaskConstMeta get kCrateBindingBreezLogStreamConstMeta => const TaskConstMeta(
        debugName: "breez_log_stream",
        argNames: ["s"],
      );

  @override
  Future<BuyBitcoinResponse> crateBindingBuyBitcoin({required BuyBitcoinRequest req}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_buy_bitcoin_request(req);
        return wire.wire__crate__binding__buy_bitcoin(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_buy_bitcoin_response,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateBindingBuyBitcoinConstMeta,
      argValues: [req],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBindingBuyBitcoinConstMeta => const TaskConstMeta(
        debugName: "buy_bitcoin",
        argNames: ["req"],
      );

  @override
  Future<CheckMessageResponse> crateBindingCheckMessage({required CheckMessageRequest req}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_check_message_request(req);
        return wire.wire__crate__binding__check_message(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_check_message_response,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateBindingCheckMessageConstMeta,
      argValues: [req],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBindingCheckMessageConstMeta => const TaskConstMeta(
        debugName: "check_message",
        argNames: ["req"],
      );

  @override
  Future<void> crateBindingCloseLspChannels() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        return wire.wire__crate__binding__close_lsp_channels(port_);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateBindingCloseLspChannelsConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBindingCloseLspChannelsConstMeta => const TaskConstMeta(
        debugName: "close_lsp_channels",
        argNames: [],
      );

  @override
  Future<void> crateBindingConfigureNode({required ConfigureNodeRequest req}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_configure_node_request(req);
        return wire.wire__crate__binding__configure_node(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateBindingConfigureNodeConstMeta,
      argValues: [req],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBindingConfigureNodeConstMeta => const TaskConstMeta(
        debugName: "configure_node",
        argNames: ["req"],
      );

  @override
  Future<void> crateBindingConnect({required ConnectRequest req}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_connect_request(req);
        return wire.wire__crate__binding__connect(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateBindingConnectConstMeta,
      argValues: [req],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBindingConnectConstMeta => const TaskConstMeta(
        debugName: "connect",
        argNames: ["req"],
      );

  @override
  Future<void> crateBindingConnectLsp({required String lspId}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(lspId);
        return wire.wire__crate__binding__connect_lsp(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateBindingConnectLspConstMeta,
      argValues: [lspId],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBindingConnectLspConstMeta => const TaskConstMeta(
        debugName: "connect_lsp",
        argNames: ["lspId"],
      );

  @override
  Future<Config> crateBindingDefaultConfig(
      {required EnvironmentType envType, required String apiKey, required NodeConfig nodeConfig}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_environment_type(envType);
        var arg1 = cst_encode_String(apiKey);
        var arg2 = cst_encode_box_autoadd_node_config(nodeConfig);
        return wire.wire__crate__binding__default_config(port_, arg0, arg1, arg2);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_config,
        decodeErrorData: null,
      ),
      constMeta: kCrateBindingDefaultConfigConstMeta,
      argValues: [envType, apiKey, nodeConfig],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBindingDefaultConfigConstMeta => const TaskConstMeta(
        debugName: "default_config",
        argNames: ["envType", "apiKey", "nodeConfig"],
      );

  @override
  Future<void> crateBindingDisconnect() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        return wire.wire__crate__binding__disconnect(port_);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateBindingDisconnectConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBindingDisconnectConstMeta => const TaskConstMeta(
        debugName: "disconnect",
        argNames: [],
      );

  @override
  Future<String> crateBindingExecuteCommand({required String command}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(command);
        return wire.wire__crate__binding__execute_command(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_String,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateBindingExecuteCommandConstMeta,
      argValues: [command],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBindingExecuteCommandConstMeta => const TaskConstMeta(
        debugName: "execute_command",
        argNames: ["command"],
      );

  @override
  Future<List<Rate>> crateBindingFetchFiatRates() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        return wire.wire__crate__binding__fetch_fiat_rates(port_);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_list_rate,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateBindingFetchFiatRatesConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBindingFetchFiatRatesConstMeta => const TaskConstMeta(
        debugName: "fetch_fiat_rates",
        argNames: [],
      );

  @override
  Future<LspInformation?> crateBindingFetchLspInfo({required String id}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(id);
        return wire.wire__crate__binding__fetch_lsp_info(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_opt_box_autoadd_lsp_information,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateBindingFetchLspInfoConstMeta,
      argValues: [id],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBindingFetchLspInfoConstMeta => const TaskConstMeta(
        debugName: "fetch_lsp_info",
        argNames: ["id"],
      );

  @override
  Future<ReverseSwapPairInfo> crateBindingFetchReverseSwapFees({required ReverseSwapFeesRequest req}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_reverse_swap_fees_request(req);
        return wire.wire__crate__binding__fetch_reverse_swap_fees(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_reverse_swap_pair_info,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateBindingFetchReverseSwapFeesConstMeta,
      argValues: [req],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBindingFetchReverseSwapFeesConstMeta => const TaskConstMeta(
        debugName: "fetch_reverse_swap_fees",
        argNames: ["req"],
      );

  @override
  Future<String> crateBindingGenerateDiagnosticData() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        return wire.wire__crate__binding__generate_diagnostic_data(port_);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_String,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateBindingGenerateDiagnosticDataConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBindingGenerateDiagnosticDataConstMeta => const TaskConstMeta(
        debugName: "generate_diagnostic_data",
        argNames: [],
      );

  @override
  Future<List<ReverseSwapInfo>> crateBindingInProgressOnchainPayments() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        return wire.wire__crate__binding__in_progress_onchain_payments(port_);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_list_reverse_swap_info,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateBindingInProgressOnchainPaymentsConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBindingInProgressOnchainPaymentsConstMeta => const TaskConstMeta(
        debugName: "in_progress_onchain_payments",
        argNames: [],
      );

  @override
  Future<List<ReverseSwapInfo>> crateBindingInProgressReverseSwaps() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        return wire.wire__crate__binding__in_progress_reverse_swaps(port_);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_list_reverse_swap_info,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateBindingInProgressReverseSwapsConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBindingInProgressReverseSwapsConstMeta => const TaskConstMeta(
        debugName: "in_progress_reverse_swaps",
        argNames: [],
      );

  @override
  Future<SwapInfo?> crateBindingInProgressSwap() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        return wire.wire__crate__binding__in_progress_swap(port_);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_opt_box_autoadd_swap_info,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateBindingInProgressSwapConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBindingInProgressSwapConstMeta => const TaskConstMeta(
        debugName: "in_progress_swap",
        argNames: [],
      );

  @override
  Future<bool> crateBindingIsInitialized() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        return wire.wire__crate__binding__is_initialized(port_);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kCrateBindingIsInitializedConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBindingIsInitializedConstMeta => const TaskConstMeta(
        debugName: "is_initialized",
        argNames: [],
      );

  @override
  Future<List<FiatCurrency>> crateBindingListFiatCurrencies() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        return wire.wire__crate__binding__list_fiat_currencies(port_);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_list_fiat_currency,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateBindingListFiatCurrenciesConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBindingListFiatCurrenciesConstMeta => const TaskConstMeta(
        debugName: "list_fiat_currencies",
        argNames: [],
      );

  @override
  Future<List<LspInformation>> crateBindingListLsps() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        return wire.wire__crate__binding__list_lsps(port_);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_list_lsp_information,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateBindingListLspsConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBindingListLspsConstMeta => const TaskConstMeta(
        debugName: "list_lsps",
        argNames: [],
      );

  @override
  Future<List<Payment>> crateBindingListPayments({required ListPaymentsRequest req}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_list_payments_request(req);
        return wire.wire__crate__binding__list_payments(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_list_payment,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateBindingListPaymentsConstMeta,
      argValues: [req],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBindingListPaymentsConstMeta => const TaskConstMeta(
        debugName: "list_payments",
        argNames: ["req"],
      );

  @override
  Future<List<SwapInfo>> crateBindingListRefundables() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        return wire.wire__crate__binding__list_refundables(port_);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_list_swap_info,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateBindingListRefundablesConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBindingListRefundablesConstMeta => const TaskConstMeta(
        debugName: "list_refundables",
        argNames: [],
      );

  @override
  Future<LnUrlCallbackStatus> crateBindingLnurlAuth({required LnUrlAuthRequestData reqData}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ln_url_auth_request_data(reqData);
        return wire.wire__crate__binding__lnurl_auth(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_ln_url_callback_status,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateBindingLnurlAuthConstMeta,
      argValues: [reqData],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBindingLnurlAuthConstMeta => const TaskConstMeta(
        debugName: "lnurl_auth",
        argNames: ["reqData"],
      );

  @override
  Future<LnUrlPayResult> crateBindingLnurlPay({required LnUrlPayRequest req}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ln_url_pay_request(req);
        return wire.wire__crate__binding__lnurl_pay(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_ln_url_pay_result,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateBindingLnurlPayConstMeta,
      argValues: [req],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBindingLnurlPayConstMeta => const TaskConstMeta(
        debugName: "lnurl_pay",
        argNames: ["req"],
      );

  @override
  Future<LnUrlWithdrawResult> crateBindingLnurlWithdraw({required LnUrlWithdrawRequest req}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ln_url_withdraw_request(req);
        return wire.wire__crate__binding__lnurl_withdraw(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_ln_url_withdraw_result,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateBindingLnurlWithdrawConstMeta,
      argValues: [req],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBindingLnurlWithdrawConstMeta => const TaskConstMeta(
        debugName: "lnurl_withdraw",
        argNames: ["req"],
      );

  @override
  Future<String?> crateBindingLspId() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        return wire.wire__crate__binding__lsp_id(port_);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_opt_String,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateBindingLspIdConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBindingLspIdConstMeta => const TaskConstMeta(
        debugName: "lsp_id",
        argNames: [],
      );

  @override
  Future<LspInformation> crateBindingLspInfo() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        return wire.wire__crate__binding__lsp_info(port_);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_lsp_information,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateBindingLspInfoConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBindingLspInfoConstMeta => const TaskConstMeta(
        debugName: "lsp_info",
        argNames: [],
      );

  @override
  Future<MaxReverseSwapAmountResponse> crateBindingMaxReverseSwapAmount() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        return wire.wire__crate__binding__max_reverse_swap_amount(port_);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_max_reverse_swap_amount_response,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateBindingMaxReverseSwapAmountConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBindingMaxReverseSwapAmountConstMeta => const TaskConstMeta(
        debugName: "max_reverse_swap_amount",
        argNames: [],
      );

  @override
  Future<Uint8List> crateBindingMnemonicToSeed({required String phrase}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(phrase);
        return wire.wire__crate__binding__mnemonic_to_seed(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_list_prim_u_8_strict,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateBindingMnemonicToSeedConstMeta,
      argValues: [phrase],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBindingMnemonicToSeedConstMeta => const TaskConstMeta(
        debugName: "mnemonic_to_seed",
        argNames: ["phrase"],
      );

  @override
  Future<NodeCredentials?> crateBindingNodeCredentials() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        return wire.wire__crate__binding__node_credentials(port_);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_opt_box_autoadd_node_credentials,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateBindingNodeCredentialsConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBindingNodeCredentialsConstMeta => const TaskConstMeta(
        debugName: "node_credentials",
        argNames: [],
      );

  @override
  Future<NodeState> crateBindingNodeInfo() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        return wire.wire__crate__binding__node_info(port_);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_node_state,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateBindingNodeInfoConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBindingNodeInfoConstMeta => const TaskConstMeta(
        debugName: "node_info",
        argNames: [],
      );

  @override
  Future<OnchainPaymentLimitsResponse> crateBindingOnchainPaymentLimits() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        return wire.wire__crate__binding__onchain_payment_limits(port_);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_onchain_payment_limits_response,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateBindingOnchainPaymentLimitsConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBindingOnchainPaymentLimitsConstMeta => const TaskConstMeta(
        debugName: "onchain_payment_limits",
        argNames: [],
      );

  @override
  Future<OpenChannelFeeResponse> crateBindingOpenChannelFee({required OpenChannelFeeRequest req}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_open_channel_fee_request(req);
        return wire.wire__crate__binding__open_channel_fee(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_open_channel_fee_response,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateBindingOpenChannelFeeConstMeta,
      argValues: [req],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBindingOpenChannelFeeConstMeta => const TaskConstMeta(
        debugName: "open_channel_fee",
        argNames: ["req"],
      );

  @override
  Future<InputType> crateBindingParseInput({required String input}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(input);
        return wire.wire__crate__binding__parse_input(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_input_type,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateBindingParseInputConstMeta,
      argValues: [input],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBindingParseInputConstMeta => const TaskConstMeta(
        debugName: "parse_input",
        argNames: ["input"],
      );

  @override
  Future<LNInvoice> crateBindingParseInvoice({required String invoice}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(invoice);
        return wire.wire__crate__binding__parse_invoice(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_ln_invoice,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateBindingParseInvoiceConstMeta,
      argValues: [invoice],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBindingParseInvoiceConstMeta => const TaskConstMeta(
        debugName: "parse_invoice",
        argNames: ["invoice"],
      );

  @override
  Future<PayOnchainResponse> crateBindingPayOnchain({required PayOnchainRequest req}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_pay_onchain_request(req);
        return wire.wire__crate__binding__pay_onchain(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_pay_onchain_response,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateBindingPayOnchainConstMeta,
      argValues: [req],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBindingPayOnchainConstMeta => const TaskConstMeta(
        debugName: "pay_onchain",
        argNames: ["req"],
      );

  @override
  Future<Payment?> crateBindingPaymentByHash({required String hash}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(hash);
        return wire.wire__crate__binding__payment_by_hash(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_opt_box_autoadd_payment,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateBindingPaymentByHashConstMeta,
      argValues: [hash],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBindingPaymentByHashConstMeta => const TaskConstMeta(
        debugName: "payment_by_hash",
        argNames: ["hash"],
      );

  @override
  Future<PrepareOnchainPaymentResponse> crateBindingPrepareOnchainPayment(
      {required PrepareOnchainPaymentRequest req}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_prepare_onchain_payment_request(req);
        return wire.wire__crate__binding__prepare_onchain_payment(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_prepare_onchain_payment_response,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateBindingPrepareOnchainPaymentConstMeta,
      argValues: [req],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBindingPrepareOnchainPaymentConstMeta => const TaskConstMeta(
        debugName: "prepare_onchain_payment",
        argNames: ["req"],
      );

  @override
  Future<PrepareRedeemOnchainFundsResponse> crateBindingPrepareRedeemOnchainFunds(
      {required PrepareRedeemOnchainFundsRequest req}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_prepare_redeem_onchain_funds_request(req);
        return wire.wire__crate__binding__prepare_redeem_onchain_funds(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_prepare_redeem_onchain_funds_response,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateBindingPrepareRedeemOnchainFundsConstMeta,
      argValues: [req],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBindingPrepareRedeemOnchainFundsConstMeta => const TaskConstMeta(
        debugName: "prepare_redeem_onchain_funds",
        argNames: ["req"],
      );

  @override
  Future<PrepareRefundResponse> crateBindingPrepareRefund({required PrepareRefundRequest req}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_prepare_refund_request(req);
        return wire.wire__crate__binding__prepare_refund(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_prepare_refund_response,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateBindingPrepareRefundConstMeta,
      argValues: [req],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBindingPrepareRefundConstMeta => const TaskConstMeta(
        debugName: "prepare_refund",
        argNames: ["req"],
      );

  @override
  Future<SwapInfo> crateBindingReceiveOnchain({required ReceiveOnchainRequest req}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_receive_onchain_request(req);
        return wire.wire__crate__binding__receive_onchain(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_swap_info,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateBindingReceiveOnchainConstMeta,
      argValues: [req],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBindingReceiveOnchainConstMeta => const TaskConstMeta(
        debugName: "receive_onchain",
        argNames: ["req"],
      );

  @override
  Future<ReceivePaymentResponse> crateBindingReceivePayment({required ReceivePaymentRequest req}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_receive_payment_request(req);
        return wire.wire__crate__binding__receive_payment(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_receive_payment_response,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateBindingReceivePaymentConstMeta,
      argValues: [req],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBindingReceivePaymentConstMeta => const TaskConstMeta(
        debugName: "receive_payment",
        argNames: ["req"],
      );

  @override
  Future<RecommendedFees> crateBindingRecommendedFees() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        return wire.wire__crate__binding__recommended_fees(port_);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_recommended_fees,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateBindingRecommendedFeesConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBindingRecommendedFeesConstMeta => const TaskConstMeta(
        debugName: "recommended_fees",
        argNames: [],
      );

  @override
  Future<RedeemOnchainFundsResponse> crateBindingRedeemOnchainFunds(
      {required RedeemOnchainFundsRequest req}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_redeem_onchain_funds_request(req);
        return wire.wire__crate__binding__redeem_onchain_funds(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_redeem_onchain_funds_response,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateBindingRedeemOnchainFundsConstMeta,
      argValues: [req],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBindingRedeemOnchainFundsConstMeta => const TaskConstMeta(
        debugName: "redeem_onchain_funds",
        argNames: ["req"],
      );

  @override
  Future<void> crateBindingRedeemSwap({required String swapAddress}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(swapAddress);
        return wire.wire__crate__binding__redeem_swap(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateBindingRedeemSwapConstMeta,
      argValues: [swapAddress],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBindingRedeemSwapConstMeta => const TaskConstMeta(
        debugName: "redeem_swap",
        argNames: ["swapAddress"],
      );

  @override
  Future<RefundResponse> crateBindingRefund({required RefundRequest req}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_refund_request(req);
        return wire.wire__crate__binding__refund(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_refund_response,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateBindingRefundConstMeta,
      argValues: [req],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBindingRefundConstMeta => const TaskConstMeta(
        debugName: "refund",
        argNames: ["req"],
      );

  @override
  Future<void> crateBindingRegisterWebhook({required String webhookUrl}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(webhookUrl);
        return wire.wire__crate__binding__register_webhook(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateBindingRegisterWebhookConstMeta,
      argValues: [webhookUrl],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBindingRegisterWebhookConstMeta => const TaskConstMeta(
        debugName: "register_webhook",
        argNames: ["webhookUrl"],
      );

  @override
  Future<void> crateBindingReportIssue({required ReportIssueRequest req}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_report_issue_request(req);
        return wire.wire__crate__binding__report_issue(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateBindingReportIssueConstMeta,
      argValues: [req],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBindingReportIssueConstMeta => const TaskConstMeta(
        debugName: "report_issue",
        argNames: ["req"],
      );

  @override
  Future<void> crateBindingRescanSwaps() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        return wire.wire__crate__binding__rescan_swaps(port_);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateBindingRescanSwapsConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBindingRescanSwapsConstMeta => const TaskConstMeta(
        debugName: "rescan_swaps",
        argNames: [],
      );

  @override
  Future<SendOnchainResponse> crateBindingSendOnchain({required SendOnchainRequest req}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_send_onchain_request(req);
        return wire.wire__crate__binding__send_onchain(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_send_onchain_response,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateBindingSendOnchainConstMeta,
      argValues: [req],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBindingSendOnchainConstMeta => const TaskConstMeta(
        debugName: "send_onchain",
        argNames: ["req"],
      );

  @override
  Future<SendPaymentResponse> crateBindingSendPayment({required SendPaymentRequest req}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_send_payment_request(req);
        return wire.wire__crate__binding__send_payment(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_send_payment_response,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateBindingSendPaymentConstMeta,
      argValues: [req],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBindingSendPaymentConstMeta => const TaskConstMeta(
        debugName: "send_payment",
        argNames: ["req"],
      );

  @override
  Future<SendPaymentResponse> crateBindingSendSpontaneousPayment(
      {required SendSpontaneousPaymentRequest req}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_send_spontaneous_payment_request(req);
        return wire.wire__crate__binding__send_spontaneous_payment(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_send_payment_response,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateBindingSendSpontaneousPaymentConstMeta,
      argValues: [req],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBindingSendSpontaneousPaymentConstMeta => const TaskConstMeta(
        debugName: "send_spontaneous_payment",
        argNames: ["req"],
      );

  @override
  Future<ServiceHealthCheckResponse> crateBindingServiceHealthCheck({required String apiKey}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(apiKey);
        return wire.wire__crate__binding__service_health_check(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_service_health_check_response,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateBindingServiceHealthCheckConstMeta,
      argValues: [apiKey],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBindingServiceHealthCheckConstMeta => const TaskConstMeta(
        debugName: "service_health_check",
        argNames: ["apiKey"],
      );

  @override
  Future<void> crateBindingSetPaymentMetadata({required String hash, required String metadata}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(hash);
        var arg1 = cst_encode_String(metadata);
        return wire.wire__crate__binding__set_payment_metadata(port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateBindingSetPaymentMetadataConstMeta,
      argValues: [hash, metadata],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBindingSetPaymentMetadataConstMeta => const TaskConstMeta(
        debugName: "set_payment_metadata",
        argNames: ["hash", "metadata"],
      );

  @override
  Future<SignMessageResponse> crateBindingSignMessage({required SignMessageRequest req}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_sign_message_request(req);
        return wire.wire__crate__binding__sign_message(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_sign_message_response,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateBindingSignMessageConstMeta,
      argValues: [req],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBindingSignMessageConstMeta => const TaskConstMeta(
        debugName: "sign_message",
        argNames: ["req"],
      );

  @override
  Future<StaticBackupResponse> crateBindingStaticBackup({required StaticBackupRequest req}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_static_backup_request(req);
        return wire.wire__crate__binding__static_backup(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_static_backup_response,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateBindingStaticBackupConstMeta,
      argValues: [req],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBindingStaticBackupConstMeta => const TaskConstMeta(
        debugName: "static_backup",
        argNames: ["req"],
      );

  @override
  Future<void> crateBindingSync() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        return wire.wire__crate__binding__sync(port_);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateBindingSyncConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBindingSyncConstMeta => const TaskConstMeta(
        debugName: "sync",
        argNames: [],
      );

  @override
  Future<void> crateBindingUnregisterWebhook({required String webhookUrl}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(webhookUrl);
        return wire.wire__crate__binding__unregister_webhook(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateBindingUnregisterWebhookConstMeta,
      argValues: [webhookUrl],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBindingUnregisterWebhookConstMeta => const TaskConstMeta(
        debugName: "unregister_webhook",
        argNames: ["webhookUrl"],
      );

  @protected
  AnyhowException dco_decode_AnyhowException(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AnyhowException(raw as String);
  }

  @protected
  RustStreamSink<BreezEvent> dco_decode_StreamSink_breez_event_Dco(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    throw UnimplementedError();
  }

  @protected
  RustStreamSink<LogEntry> dco_decode_StreamSink_log_entry_Dco(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    throw UnimplementedError();
  }

  @protected
  String dco_decode_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as String;
  }

  @protected
  AesSuccessActionDataDecrypted dco_decode_aes_success_action_data_decrypted(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return AesSuccessActionDataDecrypted(
      description: dco_decode_String(arr[0]),
      plaintext: dco_decode_String(arr[1]),
    );
  }

  @protected
  AesSuccessActionDataResult dco_decode_aes_success_action_data_result(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return AesSuccessActionDataResult_Decrypted(
          data: dco_decode_box_autoadd_aes_success_action_data_decrypted(raw[1]),
        );
      case 1:
        return AesSuccessActionDataResult_ErrorStatus(
          reason: dco_decode_String(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  BackupFailedData dco_decode_backup_failed_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1) throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return BackupFailedData(
      error: dco_decode_String(arr[0]),
    );
  }

  @protected
  BackupStatus dco_decode_backup_status(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return BackupStatus(
      backedUp: dco_decode_bool(arr[0]),
      lastBackupTime: dco_decode_opt_box_autoadd_u_64(arr[1]),
    );
  }

  @protected
  BindingEventListener dco_decode_binding_event_listener(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 0) throw Exception('unexpected arr length: expect 0 but see ${arr.length}');
    return BindingEventListener();
  }

  @protected
  BitcoinAddressData dco_decode_bitcoin_address_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 5) throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
    return BitcoinAddressData(
      address: dco_decode_String(arr[0]),
      network: dco_decode_network(arr[1]),
      amountSat: dco_decode_opt_box_autoadd_u_64(arr[2]),
      label: dco_decode_opt_String(arr[3]),
      message: dco_decode_opt_String(arr[4]),
    );
  }

  @protected
  bool dco_decode_bool(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as bool;
  }

  @protected
  AesSuccessActionDataDecrypted dco_decode_box_autoadd_aes_success_action_data_decrypted(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_aes_success_action_data_decrypted(raw);
  }

  @protected
  AesSuccessActionDataResult dco_decode_box_autoadd_aes_success_action_data_result(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_aes_success_action_data_result(raw);
  }

  @protected
  BackupFailedData dco_decode_box_autoadd_backup_failed_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_backup_failed_data(raw);
  }

  @protected
  BindingEventListener dco_decode_box_autoadd_binding_event_listener(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_binding_event_listener(raw);
  }

  @protected
  BitcoinAddressData dco_decode_box_autoadd_bitcoin_address_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_bitcoin_address_data(raw);
  }

  @protected
  bool dco_decode_box_autoadd_bool(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as bool;
  }

  @protected
  BreezEvent dco_decode_box_autoadd_breez_event(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_breez_event(raw);
  }

  @protected
  BuyBitcoinRequest dco_decode_box_autoadd_buy_bitcoin_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_buy_bitcoin_request(raw);
  }

  @protected
  CheckMessageRequest dco_decode_box_autoadd_check_message_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_check_message_request(raw);
  }

  @protected
  ClosedChannelPaymentDetails dco_decode_box_autoadd_closed_channel_payment_details(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_closed_channel_payment_details(raw);
  }

  @protected
  ConfigureNodeRequest dco_decode_box_autoadd_configure_node_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_configure_node_request(raw);
  }

  @protected
  ConnectRequest dco_decode_box_autoadd_connect_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_connect_request(raw);
  }

  @protected
  GreenlightCredentials dco_decode_box_autoadd_greenlight_credentials(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_greenlight_credentials(raw);
  }

  @protected
  GreenlightNodeConfig dco_decode_box_autoadd_greenlight_node_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_greenlight_node_config(raw);
  }

  @protected
  PlatformInt64 dco_decode_box_autoadd_i_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_i_64(raw);
  }

  @protected
  InvoicePaidDetails dco_decode_box_autoadd_invoice_paid_details(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_invoice_paid_details(raw);
  }

  @protected
  ListPaymentsRequest dco_decode_box_autoadd_list_payments_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_list_payments_request(raw);
  }

  @protected
  LNInvoice dco_decode_box_autoadd_ln_invoice(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ln_invoice(raw);
  }

  @protected
  LnPaymentDetails dco_decode_box_autoadd_ln_payment_details(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ln_payment_details(raw);
  }

  @protected
  LnUrlAuthRequestData dco_decode_box_autoadd_ln_url_auth_request_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ln_url_auth_request_data(raw);
  }

  @protected
  LnUrlErrorData dco_decode_box_autoadd_ln_url_error_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ln_url_error_data(raw);
  }

  @protected
  LnUrlPayErrorData dco_decode_box_autoadd_ln_url_pay_error_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ln_url_pay_error_data(raw);
  }

  @protected
  LnUrlPayRequest dco_decode_box_autoadd_ln_url_pay_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ln_url_pay_request(raw);
  }

  @protected
  LnUrlPayRequestData dco_decode_box_autoadd_ln_url_pay_request_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ln_url_pay_request_data(raw);
  }

  @protected
  LnUrlPaySuccessData dco_decode_box_autoadd_ln_url_pay_success_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ln_url_pay_success_data(raw);
  }

  @protected
  LnUrlWithdrawRequest dco_decode_box_autoadd_ln_url_withdraw_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ln_url_withdraw_request(raw);
  }

  @protected
  LnUrlWithdrawRequestData dco_decode_box_autoadd_ln_url_withdraw_request_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ln_url_withdraw_request_data(raw);
  }

  @protected
  LnUrlWithdrawSuccessData dco_decode_box_autoadd_ln_url_withdraw_success_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ln_url_withdraw_success_data(raw);
  }

  @protected
  LspInformation dco_decode_box_autoadd_lsp_information(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_lsp_information(raw);
  }

  @protected
  MessageSuccessActionData dco_decode_box_autoadd_message_success_action_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_message_success_action_data(raw);
  }

  @protected
  NodeConfig dco_decode_box_autoadd_node_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_node_config(raw);
  }

  @protected
  NodeCredentials dco_decode_box_autoadd_node_credentials(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_node_credentials(raw);
  }

  @protected
  OpenChannelFeeRequest dco_decode_box_autoadd_open_channel_fee_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_open_channel_fee_request(raw);
  }

  @protected
  OpeningFeeParams dco_decode_box_autoadd_opening_fee_params(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_opening_fee_params(raw);
  }

  @protected
  PayOnchainRequest dco_decode_box_autoadd_pay_onchain_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_pay_onchain_request(raw);
  }

  @protected
  Payment dco_decode_box_autoadd_payment(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_payment(raw);
  }

  @protected
  PaymentFailedData dco_decode_box_autoadd_payment_failed_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_payment_failed_data(raw);
  }

  @protected
  PrepareOnchainPaymentRequest dco_decode_box_autoadd_prepare_onchain_payment_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_prepare_onchain_payment_request(raw);
  }

  @protected
  PrepareRedeemOnchainFundsRequest dco_decode_box_autoadd_prepare_redeem_onchain_funds_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_prepare_redeem_onchain_funds_request(raw);
  }

  @protected
  PrepareRefundRequest dco_decode_box_autoadd_prepare_refund_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_prepare_refund_request(raw);
  }

  @protected
  ReceiveOnchainRequest dco_decode_box_autoadd_receive_onchain_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_receive_onchain_request(raw);
  }

  @protected
  ReceivePaymentRequest dco_decode_box_autoadd_receive_payment_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_receive_payment_request(raw);
  }

  @protected
  RedeemOnchainFundsRequest dco_decode_box_autoadd_redeem_onchain_funds_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_redeem_onchain_funds_request(raw);
  }

  @protected
  RefundRequest dco_decode_box_autoadd_refund_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_refund_request(raw);
  }

  @protected
  ReportIssueRequest dco_decode_box_autoadd_report_issue_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_report_issue_request(raw);
  }

  @protected
  ReportPaymentFailureDetails dco_decode_box_autoadd_report_payment_failure_details(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_report_payment_failure_details(raw);
  }

  @protected
  ReverseSwapFeesRequest dco_decode_box_autoadd_reverse_swap_fees_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_reverse_swap_fees_request(raw);
  }

  @protected
  ReverseSwapInfo dco_decode_box_autoadd_reverse_swap_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_reverse_swap_info(raw);
  }

  @protected
  SendOnchainRequest dco_decode_box_autoadd_send_onchain_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_send_onchain_request(raw);
  }

  @protected
  SendPaymentRequest dco_decode_box_autoadd_send_payment_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_send_payment_request(raw);
  }

  @protected
  SendSpontaneousPaymentRequest dco_decode_box_autoadd_send_spontaneous_payment_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_send_spontaneous_payment_request(raw);
  }

  @protected
  SignMessageRequest dco_decode_box_autoadd_sign_message_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_sign_message_request(raw);
  }

  @protected
  StaticBackupRequest dco_decode_box_autoadd_static_backup_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_static_backup_request(raw);
  }

  @protected
  SuccessActionProcessed dco_decode_box_autoadd_success_action_processed(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_success_action_processed(raw);
  }

  @protected
  SwapInfo dco_decode_box_autoadd_swap_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_swap_info(raw);
  }

  @protected
  Symbol dco_decode_box_autoadd_symbol(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_symbol(raw);
  }

  @protected
  int dco_decode_box_autoadd_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  BigInt dco_decode_box_autoadd_u_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_u_64(raw);
  }

  @protected
  UrlSuccessActionData dco_decode_box_autoadd_url_success_action_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_url_success_action_data(raw);
  }

  @protected
  BreezEvent dco_decode_breez_event(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return BreezEvent_NewBlock(
          block: dco_decode_u_32(raw[1]),
        );
      case 1:
        return BreezEvent_InvoicePaid(
          details: dco_decode_box_autoadd_invoice_paid_details(raw[1]),
        );
      case 2:
        return BreezEvent_Synced();
      case 3:
        return BreezEvent_PaymentSucceed(
          details: dco_decode_box_autoadd_payment(raw[1]),
        );
      case 4:
        return BreezEvent_PaymentFailed(
          details: dco_decode_box_autoadd_payment_failed_data(raw[1]),
        );
      case 5:
        return BreezEvent_BackupStarted();
      case 6:
        return BreezEvent_BackupSucceeded();
      case 7:
        return BreezEvent_BackupFailed(
          details: dco_decode_box_autoadd_backup_failed_data(raw[1]),
        );
      case 8:
        return BreezEvent_SwapUpdated(
          details: dco_decode_box_autoadd_swap_info(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  BuyBitcoinProvider dco_decode_buy_bitcoin_provider(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return BuyBitcoinProvider.values[raw as int];
  }

  @protected
  BuyBitcoinRequest dco_decode_buy_bitcoin_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return BuyBitcoinRequest(
      provider: dco_decode_buy_bitcoin_provider(arr[0]),
      openingFeeParams: dco_decode_opt_box_autoadd_opening_fee_params(arr[1]),
    );
  }

  @protected
  BuyBitcoinResponse dco_decode_buy_bitcoin_response(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return BuyBitcoinResponse(
      url: dco_decode_String(arr[0]),
      openingFeeParams: dco_decode_opt_box_autoadd_opening_fee_params(arr[1]),
    );
  }

  @protected
  ChannelState dco_decode_channel_state(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ChannelState.values[raw as int];
  }

  @protected
  CheckMessageRequest dco_decode_check_message_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3) throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return CheckMessageRequest(
      message: dco_decode_String(arr[0]),
      pubkey: dco_decode_String(arr[1]),
      signature: dco_decode_String(arr[2]),
    );
  }

  @protected
  CheckMessageResponse dco_decode_check_message_response(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1) throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return CheckMessageResponse(
      isValid: dco_decode_bool(arr[0]),
    );
  }

  @protected
  ClosedChannelPaymentDetails dco_decode_closed_channel_payment_details(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4) throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return ClosedChannelPaymentDetails(
      state: dco_decode_channel_state(arr[0]),
      fundingTxid: dco_decode_String(arr[1]),
      shortChannelId: dco_decode_opt_String(arr[2]),
      closingTxid: dco_decode_opt_String(arr[3]),
    );
  }

  @protected
  Config dco_decode_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 11) throw Exception('unexpected arr length: expect 11 but see ${arr.length}');
    return Config(
      breezserver: dco_decode_String(arr[0]),
      chainnotifierUrl: dco_decode_String(arr[1]),
      mempoolspaceUrl: dco_decode_opt_String(arr[2]),
      workingDir: dco_decode_String(arr[3]),
      network: dco_decode_network(arr[4]),
      paymentTimeoutSec: dco_decode_u_32(arr[5]),
      defaultLspId: dco_decode_opt_String(arr[6]),
      apiKey: dco_decode_opt_String(arr[7]),
      maxfeePercent: dco_decode_f_64(arr[8]),
      exemptfeeMsat: dco_decode_u_64(arr[9]),
      nodeConfig: dco_decode_node_config(arr[10]),
    );
  }

  @protected
  ConfigureNodeRequest dco_decode_configure_node_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1) throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return ConfigureNodeRequest(
      closeToAddress: dco_decode_opt_String(arr[0]),
    );
  }

  @protected
  ConnectRequest dco_decode_connect_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3) throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return ConnectRequest(
      config: dco_decode_config(arr[0]),
      seed: dco_decode_list_prim_u_8_strict(arr[1]),
      restoreOnly: dco_decode_opt_box_autoadd_bool(arr[2]),
    );
  }

  @protected
  CurrencyInfo dco_decode_currency_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 7) throw Exception('unexpected arr length: expect 7 but see ${arr.length}');
    return CurrencyInfo(
      name: dco_decode_String(arr[0]),
      fractionSize: dco_decode_u_32(arr[1]),
      spacing: dco_decode_opt_box_autoadd_u_32(arr[2]),
      symbol: dco_decode_opt_box_autoadd_symbol(arr[3]),
      uniqSymbol: dco_decode_opt_box_autoadd_symbol(arr[4]),
      localizedName: dco_decode_opt_list_localized_name(arr[5]),
      localeOverrides: dco_decode_opt_list_locale_overrides(arr[6]),
    );
  }

  @protected
  EnvironmentType dco_decode_environment_type(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return EnvironmentType.values[raw as int];
  }

  @protected
  double dco_decode_f_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as double;
  }

  @protected
  FiatCurrency dco_decode_fiat_currency(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return FiatCurrency(
      id: dco_decode_String(arr[0]),
      info: dco_decode_currency_info(arr[1]),
    );
  }

  @protected
  GreenlightCredentials dco_decode_greenlight_credentials(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return GreenlightCredentials(
      deviceKey: dco_decode_list_prim_u_8_strict(arr[0]),
      deviceCert: dco_decode_list_prim_u_8_strict(arr[1]),
    );
  }

  @protected
  GreenlightNodeConfig dco_decode_greenlight_node_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return GreenlightNodeConfig(
      partnerCredentials: dco_decode_opt_box_autoadd_greenlight_credentials(arr[0]),
      inviteCode: dco_decode_opt_String(arr[1]),
    );
  }

  @protected
  HealthCheckStatus dco_decode_health_check_status(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return HealthCheckStatus.values[raw as int];
  }

  @protected
  int dco_decode_i_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  PlatformInt64 dco_decode_i_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeI64(raw);
  }

  @protected
  InputType dco_decode_input_type(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return InputType_BitcoinAddress(
          address: dco_decode_box_autoadd_bitcoin_address_data(raw[1]),
        );
      case 1:
        return InputType_Bolt11(
          invoice: dco_decode_box_autoadd_ln_invoice(raw[1]),
        );
      case 2:
        return InputType_NodeId(
          nodeId: dco_decode_String(raw[1]),
        );
      case 3:
        return InputType_Url(
          url: dco_decode_String(raw[1]),
        );
      case 4:
        return InputType_LnUrlPay(
          data: dco_decode_box_autoadd_ln_url_pay_request_data(raw[1]),
        );
      case 5:
        return InputType_LnUrlWithdraw(
          data: dco_decode_box_autoadd_ln_url_withdraw_request_data(raw[1]),
        );
      case 6:
        return InputType_LnUrlAuth(
          data: dco_decode_box_autoadd_ln_url_auth_request_data(raw[1]),
        );
      case 7:
        return InputType_LnUrlError(
          data: dco_decode_box_autoadd_ln_url_error_data(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  InvoicePaidDetails dco_decode_invoice_paid_details(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3) throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return InvoicePaidDetails(
      paymentHash: dco_decode_String(arr[0]),
      bolt11: dco_decode_String(arr[1]),
      payment: dco_decode_opt_box_autoadd_payment(arr[2]),
    );
  }

  @protected
  List<String> dco_decode_list_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_String).toList();
  }

  @protected
  List<FiatCurrency> dco_decode_list_fiat_currency(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_fiat_currency).toList();
  }

  @protected
  List<LocaleOverrides> dco_decode_list_locale_overrides(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_locale_overrides).toList();
  }

  @protected
  List<LocalizedName> dco_decode_list_localized_name(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_localized_name).toList();
  }

  @protected
  List<LspInformation> dco_decode_list_lsp_information(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_lsp_information).toList();
  }

  @protected
  List<MetadataFilter> dco_decode_list_metadata_filter(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_metadata_filter).toList();
  }

  @protected
  List<OpeningFeeParams> dco_decode_list_opening_fee_params(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_opening_fee_params).toList();
  }

  @protected
  List<Payment> dco_decode_list_payment(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_payment).toList();
  }

  @protected
  List<PaymentTypeFilter> dco_decode_list_payment_type_filter(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_payment_type_filter).toList();
  }

  @protected
  ListPaymentsRequest dco_decode_list_payments_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 7) throw Exception('unexpected arr length: expect 7 but see ${arr.length}');
    return ListPaymentsRequest(
      filters: dco_decode_opt_list_payment_type_filter(arr[0]),
      metadataFilters: dco_decode_opt_list_metadata_filter(arr[1]),
      fromTimestamp: dco_decode_opt_box_autoadd_i_64(arr[2]),
      toTimestamp: dco_decode_opt_box_autoadd_i_64(arr[3]),
      includeFailures: dco_decode_opt_box_autoadd_bool(arr[4]),
      offset: dco_decode_opt_box_autoadd_u_32(arr[5]),
      limit: dco_decode_opt_box_autoadd_u_32(arr[6]),
    );
  }

  @protected
  Uint8List dco_decode_list_prim_u_8_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as Uint8List;
  }

  @protected
  List<Rate> dco_decode_list_rate(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_rate).toList();
  }

  @protected
  List<ReverseSwapInfo> dco_decode_list_reverse_swap_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_reverse_swap_info).toList();
  }

  @protected
  List<RouteHint> dco_decode_list_route_hint(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_route_hint).toList();
  }

  @protected
  List<RouteHintHop> dco_decode_list_route_hint_hop(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_route_hint_hop).toList();
  }

  @protected
  List<SwapInfo> dco_decode_list_swap_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_swap_info).toList();
  }

  @protected
  List<TlvEntry> dco_decode_list_tlv_entry(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_tlv_entry).toList();
  }

  @protected
  List<UnspentTransactionOutput> dco_decode_list_unspent_transaction_output(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_unspent_transaction_output).toList();
  }

  @protected
  LNInvoice dco_decode_ln_invoice(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 12) throw Exception('unexpected arr length: expect 12 but see ${arr.length}');
    return LNInvoice(
      bolt11: dco_decode_String(arr[0]),
      network: dco_decode_network(arr[1]),
      payeePubkey: dco_decode_String(arr[2]),
      paymentHash: dco_decode_String(arr[3]),
      description: dco_decode_opt_String(arr[4]),
      descriptionHash: dco_decode_opt_String(arr[5]),
      amountMsat: dco_decode_opt_box_autoadd_u_64(arr[6]),
      timestamp: dco_decode_u_64(arr[7]),
      expiry: dco_decode_u_64(arr[8]),
      routingHints: dco_decode_list_route_hint(arr[9]),
      paymentSecret: dco_decode_list_prim_u_8_strict(arr[10]),
      minFinalCltvExpiryDelta: dco_decode_u_64(arr[11]),
    );
  }

  @protected
  LnPaymentDetails dco_decode_ln_payment_details(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 16) throw Exception('unexpected arr length: expect 16 but see ${arr.length}');
    return LnPaymentDetails(
      paymentHash: dco_decode_String(arr[0]),
      label: dco_decode_String(arr[1]),
      destinationPubkey: dco_decode_String(arr[2]),
      paymentPreimage: dco_decode_String(arr[3]),
      keysend: dco_decode_bool(arr[4]),
      bolt11: dco_decode_String(arr[5]),
      openChannelBolt11: dco_decode_opt_String(arr[6]),
      lnurlSuccessAction: dco_decode_opt_box_autoadd_success_action_processed(arr[7]),
      lnurlPayDomain: dco_decode_opt_String(arr[8]),
      lnurlPayComment: dco_decode_opt_String(arr[9]),
      lnAddress: dco_decode_opt_String(arr[10]),
      lnurlMetadata: dco_decode_opt_String(arr[11]),
      lnurlWithdrawEndpoint: dco_decode_opt_String(arr[12]),
      swapInfo: dco_decode_opt_box_autoadd_swap_info(arr[13]),
      reverseSwapInfo: dco_decode_opt_box_autoadd_reverse_swap_info(arr[14]),
      pendingExpirationBlock: dco_decode_opt_box_autoadd_u_32(arr[15]),
    );
  }

  @protected
  LnUrlAuthRequestData dco_decode_ln_url_auth_request_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4) throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return LnUrlAuthRequestData(
      k1: dco_decode_String(arr[0]),
      action: dco_decode_opt_String(arr[1]),
      domain: dco_decode_String(arr[2]),
      url: dco_decode_String(arr[3]),
    );
  }

  @protected
  LnUrlCallbackStatus dco_decode_ln_url_callback_status(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return LnUrlCallbackStatus_Ok();
      case 1:
        return LnUrlCallbackStatus_ErrorStatus(
          data: dco_decode_box_autoadd_ln_url_error_data(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  LnUrlErrorData dco_decode_ln_url_error_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1) throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return LnUrlErrorData(
      reason: dco_decode_String(arr[0]),
    );
  }

  @protected
  LnUrlPayErrorData dco_decode_ln_url_pay_error_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return LnUrlPayErrorData(
      paymentHash: dco_decode_String(arr[0]),
      reason: dco_decode_String(arr[1]),
    );
  }

  @protected
  LnUrlPayRequest dco_decode_ln_url_pay_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4) throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return LnUrlPayRequest(
      data: dco_decode_ln_url_pay_request_data(arr[0]),
      amountMsat: dco_decode_u_64(arr[1]),
      comment: dco_decode_opt_String(arr[2]),
      paymentLabel: dco_decode_opt_String(arr[3]),
    );
  }

  @protected
  LnUrlPayRequestData dco_decode_ln_url_pay_request_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 9) throw Exception('unexpected arr length: expect 9 but see ${arr.length}');
    return LnUrlPayRequestData(
      callback: dco_decode_String(arr[0]),
      minSendable: dco_decode_u_64(arr[1]),
      maxSendable: dco_decode_u_64(arr[2]),
      metadataStr: dco_decode_String(arr[3]),
      commentAllowed: dco_decode_u_16(arr[4]),
      domain: dco_decode_String(arr[5]),
      allowsNostr: dco_decode_bool(arr[6]),
      nostrPubkey: dco_decode_opt_String(arr[7]),
      lnAddress: dco_decode_opt_String(arr[8]),
    );
  }

  @protected
  LnUrlPayResult dco_decode_ln_url_pay_result(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return LnUrlPayResult_EndpointSuccess(
          data: dco_decode_box_autoadd_ln_url_pay_success_data(raw[1]),
        );
      case 1:
        return LnUrlPayResult_EndpointError(
          data: dco_decode_box_autoadd_ln_url_error_data(raw[1]),
        );
      case 2:
        return LnUrlPayResult_PayError(
          data: dco_decode_box_autoadd_ln_url_pay_error_data(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  LnUrlPaySuccessData dco_decode_ln_url_pay_success_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return LnUrlPaySuccessData(
      payment: dco_decode_payment(arr[0]),
      successAction: dco_decode_opt_box_autoadd_success_action_processed(arr[1]),
    );
  }

  @protected
  LnUrlWithdrawRequest dco_decode_ln_url_withdraw_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3) throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return LnUrlWithdrawRequest(
      data: dco_decode_ln_url_withdraw_request_data(arr[0]),
      amountMsat: dco_decode_u_64(arr[1]),
      description: dco_decode_opt_String(arr[2]),
    );
  }

  @protected
  LnUrlWithdrawRequestData dco_decode_ln_url_withdraw_request_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 5) throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
    return LnUrlWithdrawRequestData(
      callback: dco_decode_String(arr[0]),
      k1: dco_decode_String(arr[1]),
      defaultDescription: dco_decode_String(arr[2]),
      minWithdrawable: dco_decode_u_64(arr[3]),
      maxWithdrawable: dco_decode_u_64(arr[4]),
    );
  }

  @protected
  LnUrlWithdrawResult dco_decode_ln_url_withdraw_result(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return LnUrlWithdrawResult_Ok(
          data: dco_decode_box_autoadd_ln_url_withdraw_success_data(raw[1]),
        );
      case 1:
        return LnUrlWithdrawResult_ErrorStatus(
          data: dco_decode_box_autoadd_ln_url_error_data(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  LnUrlWithdrawSuccessData dco_decode_ln_url_withdraw_success_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1) throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return LnUrlWithdrawSuccessData(
      invoice: dco_decode_ln_invoice(arr[0]),
    );
  }

  @protected
  LocaleOverrides dco_decode_locale_overrides(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3) throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return LocaleOverrides(
      locale: dco_decode_String(arr[0]),
      spacing: dco_decode_opt_box_autoadd_u_32(arr[1]),
      symbol: dco_decode_symbol(arr[2]),
    );
  }

  @protected
  LocalizedName dco_decode_localized_name(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return LocalizedName(
      locale: dco_decode_String(arr[0]),
      name: dco_decode_String(arr[1]),
    );
  }

  @protected
  LogEntry dco_decode_log_entry(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return LogEntry(
      line: dco_decode_String(arr[0]),
      level: dco_decode_String(arr[1]),
    );
  }

  @protected
  LspInformation dco_decode_lsp_information(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 11) throw Exception('unexpected arr length: expect 11 but see ${arr.length}');
    return LspInformation(
      id: dco_decode_String(arr[0]),
      name: dco_decode_String(arr[1]),
      widgetUrl: dco_decode_String(arr[2]),
      pubkey: dco_decode_String(arr[3]),
      host: dco_decode_String(arr[4]),
      baseFeeMsat: dco_decode_i_64(arr[5]),
      feeRate: dco_decode_f_64(arr[6]),
      timeLockDelta: dco_decode_u_32(arr[7]),
      minHtlcMsat: dco_decode_i_64(arr[8]),
      lspPubkey: dco_decode_list_prim_u_8_strict(arr[9]),
      openingFeeParamsList: dco_decode_opening_fee_params_menu(arr[10]),
    );
  }

  @protected
  MaxReverseSwapAmountResponse dco_decode_max_reverse_swap_amount_response(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1) throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return MaxReverseSwapAmountResponse(
      totalSat: dco_decode_u_64(arr[0]),
    );
  }

  @protected
  MessageSuccessActionData dco_decode_message_success_action_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1) throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return MessageSuccessActionData(
      message: dco_decode_String(arr[0]),
    );
  }

  @protected
  MetadataFilter dco_decode_metadata_filter(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return MetadataFilter(
      jsonPath: dco_decode_String(arr[0]),
      jsonValue: dco_decode_String(arr[1]),
    );
  }

  @protected
  Network dco_decode_network(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return Network.values[raw as int];
  }

  @protected
  NodeConfig dco_decode_node_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return NodeConfig_Greenlight(
          config: dco_decode_box_autoadd_greenlight_node_config(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  NodeCredentials dco_decode_node_credentials(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return NodeCredentials_Greenlight(
          credentials: dco_decode_box_autoadd_greenlight_credentials(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  NodeState dco_decode_node_state(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 12) throw Exception('unexpected arr length: expect 12 but see ${arr.length}');
    return NodeState(
      id: dco_decode_String(arr[0]),
      blockHeight: dco_decode_u_32(arr[1]),
      channelsBalanceMsat: dco_decode_u_64(arr[2]),
      onchainBalanceMsat: dco_decode_u_64(arr[3]),
      pendingOnchainBalanceMsat: dco_decode_u_64(arr[4]),
      utxos: dco_decode_list_unspent_transaction_output(arr[5]),
      maxPayableMsat: dco_decode_u_64(arr[6]),
      maxReceivableMsat: dco_decode_u_64(arr[7]),
      maxSinglePaymentAmountMsat: dco_decode_u_64(arr[8]),
      maxChanReserveMsats: dco_decode_u_64(arr[9]),
      connectedPeers: dco_decode_list_String(arr[10]),
      inboundLiquidityMsats: dco_decode_u_64(arr[11]),
    );
  }

  @protected
  OnchainPaymentLimitsResponse dco_decode_onchain_payment_limits_response(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return OnchainPaymentLimitsResponse(
      minSat: dco_decode_u_64(arr[0]),
      maxSat: dco_decode_u_64(arr[1]),
    );
  }

  @protected
  OpenChannelFeeRequest dco_decode_open_channel_fee_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return OpenChannelFeeRequest(
      amountMsat: dco_decode_opt_box_autoadd_u_64(arr[0]),
      expiry: dco_decode_opt_box_autoadd_u_32(arr[1]),
    );
  }

  @protected
  OpenChannelFeeResponse dco_decode_open_channel_fee_response(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return OpenChannelFeeResponse(
      feeMsat: dco_decode_opt_box_autoadd_u_64(arr[0]),
      feeParams: dco_decode_opening_fee_params(arr[1]),
    );
  }

  @protected
  OpeningFeeParams dco_decode_opening_fee_params(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 6) throw Exception('unexpected arr length: expect 6 but see ${arr.length}');
    return OpeningFeeParams(
      minMsat: dco_decode_u_64(arr[0]),
      proportional: dco_decode_u_32(arr[1]),
      validUntil: dco_decode_String(arr[2]),
      maxIdleTime: dco_decode_u_32(arr[3]),
      maxClientToSelfDelay: dco_decode_u_32(arr[4]),
      promise: dco_decode_String(arr[5]),
    );
  }

  @protected
  OpeningFeeParamsMenu dco_decode_opening_fee_params_menu(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1) throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return OpeningFeeParamsMenu(
      values: dco_decode_list_opening_fee_params(arr[0]),
    );
  }

  @protected
  String? dco_decode_opt_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_String(raw);
  }

  @protected
  bool? dco_decode_opt_box_autoadd_bool(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_bool(raw);
  }

  @protected
  GreenlightCredentials? dco_decode_opt_box_autoadd_greenlight_credentials(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_greenlight_credentials(raw);
  }

  @protected
  PlatformInt64? dco_decode_opt_box_autoadd_i_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_i_64(raw);
  }

  @protected
  LNInvoice? dco_decode_opt_box_autoadd_ln_invoice(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_ln_invoice(raw);
  }

  @protected
  LspInformation? dco_decode_opt_box_autoadd_lsp_information(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_lsp_information(raw);
  }

  @protected
  NodeCredentials? dco_decode_opt_box_autoadd_node_credentials(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_node_credentials(raw);
  }

  @protected
  OpeningFeeParams? dco_decode_opt_box_autoadd_opening_fee_params(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_opening_fee_params(raw);
  }

  @protected
  Payment? dco_decode_opt_box_autoadd_payment(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_payment(raw);
  }

  @protected
  ReverseSwapInfo? dco_decode_opt_box_autoadd_reverse_swap_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_reverse_swap_info(raw);
  }

  @protected
  SuccessActionProcessed? dco_decode_opt_box_autoadd_success_action_processed(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_success_action_processed(raw);
  }

  @protected
  SwapInfo? dco_decode_opt_box_autoadd_swap_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_swap_info(raw);
  }

  @protected
  Symbol? dco_decode_opt_box_autoadd_symbol(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_symbol(raw);
  }

  @protected
  int? dco_decode_opt_box_autoadd_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_u_32(raw);
  }

  @protected
  BigInt? dco_decode_opt_box_autoadd_u_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_u_64(raw);
  }

  @protected
  List<String>? dco_decode_opt_list_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_list_String(raw);
  }

  @protected
  List<LocaleOverrides>? dco_decode_opt_list_locale_overrides(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_list_locale_overrides(raw);
  }

  @protected
  List<LocalizedName>? dco_decode_opt_list_localized_name(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_list_localized_name(raw);
  }

  @protected
  List<MetadataFilter>? dco_decode_opt_list_metadata_filter(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_list_metadata_filter(raw);
  }

  @protected
  List<PaymentTypeFilter>? dco_decode_opt_list_payment_type_filter(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_list_payment_type_filter(raw);
  }

  @protected
  Uint8List? dco_decode_opt_list_prim_u_8_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_list_prim_u_8_strict(raw);
  }

  @protected
  List<TlvEntry>? dco_decode_opt_list_tlv_entry(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_list_tlv_entry(raw);
  }

  @protected
  PayOnchainRequest dco_decode_pay_onchain_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return PayOnchainRequest(
      recipientAddress: dco_decode_String(arr[0]),
      prepareRes: dco_decode_prepare_onchain_payment_response(arr[1]),
    );
  }

  @protected
  PayOnchainResponse dco_decode_pay_onchain_response(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1) throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return PayOnchainResponse(
      reverseSwapInfo: dco_decode_reverse_swap_info(arr[0]),
    );
  }

  @protected
  Payment dco_decode_payment(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 10) throw Exception('unexpected arr length: expect 10 but see ${arr.length}');
    return Payment(
      id: dco_decode_String(arr[0]),
      paymentType: dco_decode_payment_type(arr[1]),
      paymentTime: dco_decode_i_64(arr[2]),
      amountMsat: dco_decode_u_64(arr[3]),
      feeMsat: dco_decode_u_64(arr[4]),
      status: dco_decode_payment_status(arr[5]),
      error: dco_decode_opt_String(arr[6]),
      description: dco_decode_opt_String(arr[7]),
      details: dco_decode_payment_details(arr[8]),
      metadata: dco_decode_opt_String(arr[9]),
    );
  }

  @protected
  PaymentDetails dco_decode_payment_details(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return PaymentDetails_Ln(
          data: dco_decode_box_autoadd_ln_payment_details(raw[1]),
        );
      case 1:
        return PaymentDetails_ClosedChannel(
          data: dco_decode_box_autoadd_closed_channel_payment_details(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  PaymentFailedData dco_decode_payment_failed_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4) throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return PaymentFailedData(
      error: dco_decode_String(arr[0]),
      nodeId: dco_decode_String(arr[1]),
      invoice: dco_decode_opt_box_autoadd_ln_invoice(arr[2]),
      label: dco_decode_opt_String(arr[3]),
    );
  }

  @protected
  PaymentStatus dco_decode_payment_status(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return PaymentStatus.values[raw as int];
  }

  @protected
  PaymentType dco_decode_payment_type(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return PaymentType.values[raw as int];
  }

  @protected
  PaymentTypeFilter dco_decode_payment_type_filter(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return PaymentTypeFilter.values[raw as int];
  }

  @protected
  PrepareOnchainPaymentRequest dco_decode_prepare_onchain_payment_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3) throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return PrepareOnchainPaymentRequest(
      amountSat: dco_decode_u_64(arr[0]),
      amountType: dco_decode_swap_amount_type(arr[1]),
      claimTxFeerate: dco_decode_u_32(arr[2]),
    );
  }

  @protected
  PrepareOnchainPaymentResponse dco_decode_prepare_onchain_payment_response(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 7) throw Exception('unexpected arr length: expect 7 but see ${arr.length}');
    return PrepareOnchainPaymentResponse(
      feesHash: dco_decode_String(arr[0]),
      feesPercentage: dco_decode_f_64(arr[1]),
      feesLockup: dco_decode_u_64(arr[2]),
      feesClaim: dco_decode_u_64(arr[3]),
      senderAmountSat: dco_decode_u_64(arr[4]),
      recipientAmountSat: dco_decode_u_64(arr[5]),
      totalFees: dco_decode_u_64(arr[6]),
    );
  }

  @protected
  PrepareRedeemOnchainFundsRequest dco_decode_prepare_redeem_onchain_funds_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return PrepareRedeemOnchainFundsRequest(
      toAddress: dco_decode_String(arr[0]),
      satPerVbyte: dco_decode_u_32(arr[1]),
    );
  }

  @protected
  PrepareRedeemOnchainFundsResponse dco_decode_prepare_redeem_onchain_funds_response(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return PrepareRedeemOnchainFundsResponse(
      txWeight: dco_decode_u_64(arr[0]),
      txFeeSat: dco_decode_u_64(arr[1]),
    );
  }

  @protected
  PrepareRefundRequest dco_decode_prepare_refund_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3) throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return PrepareRefundRequest(
      swapAddress: dco_decode_String(arr[0]),
      toAddress: dco_decode_String(arr[1]),
      satPerVbyte: dco_decode_u_32(arr[2]),
    );
  }

  @protected
  PrepareRefundResponse dco_decode_prepare_refund_response(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return PrepareRefundResponse(
      refundTxWeight: dco_decode_u_32(arr[0]),
      refundTxFeeSat: dco_decode_u_64(arr[1]),
    );
  }

  @protected
  Rate dco_decode_rate(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return Rate(
      coin: dco_decode_String(arr[0]),
      value: dco_decode_f_64(arr[1]),
    );
  }

  @protected
  ReceiveOnchainRequest dco_decode_receive_onchain_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1) throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return ReceiveOnchainRequest(
      openingFeeParams: dco_decode_opt_box_autoadd_opening_fee_params(arr[0]),
    );
  }

  @protected
  ReceivePaymentRequest dco_decode_receive_payment_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 7) throw Exception('unexpected arr length: expect 7 but see ${arr.length}');
    return ReceivePaymentRequest(
      amountMsat: dco_decode_u_64(arr[0]),
      description: dco_decode_String(arr[1]),
      preimage: dco_decode_opt_list_prim_u_8_strict(arr[2]),
      openingFeeParams: dco_decode_opt_box_autoadd_opening_fee_params(arr[3]),
      useDescriptionHash: dco_decode_opt_box_autoadd_bool(arr[4]),
      expiry: dco_decode_opt_box_autoadd_u_32(arr[5]),
      cltv: dco_decode_opt_box_autoadd_u_32(arr[6]),
    );
  }

  @protected
  ReceivePaymentResponse dco_decode_receive_payment_response(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3) throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return ReceivePaymentResponse(
      lnInvoice: dco_decode_ln_invoice(arr[0]),
      openingFeeParams: dco_decode_opt_box_autoadd_opening_fee_params(arr[1]),
      openingFeeMsat: dco_decode_opt_box_autoadd_u_64(arr[2]),
    );
  }

  @protected
  RecommendedFees dco_decode_recommended_fees(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 5) throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
    return RecommendedFees(
      fastestFee: dco_decode_u_64(arr[0]),
      halfHourFee: dco_decode_u_64(arr[1]),
      hourFee: dco_decode_u_64(arr[2]),
      economyFee: dco_decode_u_64(arr[3]),
      minimumFee: dco_decode_u_64(arr[4]),
    );
  }

  @protected
  RedeemOnchainFundsRequest dco_decode_redeem_onchain_funds_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return RedeemOnchainFundsRequest(
      toAddress: dco_decode_String(arr[0]),
      satPerVbyte: dco_decode_u_32(arr[1]),
    );
  }

  @protected
  RedeemOnchainFundsResponse dco_decode_redeem_onchain_funds_response(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1) throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return RedeemOnchainFundsResponse(
      txid: dco_decode_list_prim_u_8_strict(arr[0]),
    );
  }

  @protected
  RefundRequest dco_decode_refund_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3) throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return RefundRequest(
      swapAddress: dco_decode_String(arr[0]),
      toAddress: dco_decode_String(arr[1]),
      satPerVbyte: dco_decode_u_32(arr[2]),
    );
  }

  @protected
  RefundResponse dco_decode_refund_response(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1) throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return RefundResponse(
      refundTxId: dco_decode_String(arr[0]),
    );
  }

  @protected
  ReportIssueRequest dco_decode_report_issue_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return ReportIssueRequest_PaymentFailure(
          data: dco_decode_box_autoadd_report_payment_failure_details(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  ReportPaymentFailureDetails dco_decode_report_payment_failure_details(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return ReportPaymentFailureDetails(
      paymentHash: dco_decode_String(arr[0]),
      comment: dco_decode_opt_String(arr[1]),
    );
  }

  @protected
  ReverseSwapFeesRequest dco_decode_reverse_swap_fees_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return ReverseSwapFeesRequest(
      sendAmountSat: dco_decode_opt_box_autoadd_u_64(arr[0]),
      claimTxFeerate: dco_decode_opt_box_autoadd_u_32(arr[1]),
    );
  }

  @protected
  ReverseSwapInfo dco_decode_reverse_swap_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 6) throw Exception('unexpected arr length: expect 6 but see ${arr.length}');
    return ReverseSwapInfo(
      id: dco_decode_String(arr[0]),
      claimPubkey: dco_decode_String(arr[1]),
      lockupTxid: dco_decode_opt_String(arr[2]),
      claimTxid: dco_decode_opt_String(arr[3]),
      onchainAmountSat: dco_decode_u_64(arr[4]),
      status: dco_decode_reverse_swap_status(arr[5]),
    );
  }

  @protected
  ReverseSwapPairInfo dco_decode_reverse_swap_pair_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 7) throw Exception('unexpected arr length: expect 7 but see ${arr.length}');
    return ReverseSwapPairInfo(
      min: dco_decode_u_64(arr[0]),
      max: dco_decode_u_64(arr[1]),
      feesHash: dco_decode_String(arr[2]),
      feesPercentage: dco_decode_f_64(arr[3]),
      feesLockup: dco_decode_u_64(arr[4]),
      feesClaim: dco_decode_u_64(arr[5]),
      totalFees: dco_decode_opt_box_autoadd_u_64(arr[6]),
    );
  }

  @protected
  ReverseSwapStatus dco_decode_reverse_swap_status(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ReverseSwapStatus.values[raw as int];
  }

  @protected
  RouteHint dco_decode_route_hint(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1) throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return RouteHint(
      hops: dco_decode_list_route_hint_hop(arr[0]),
    );
  }

  @protected
  RouteHintHop dco_decode_route_hint_hop(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 7) throw Exception('unexpected arr length: expect 7 but see ${arr.length}');
    return RouteHintHop(
      srcNodeId: dco_decode_String(arr[0]),
      shortChannelId: dco_decode_u_64(arr[1]),
      feesBaseMsat: dco_decode_u_32(arr[2]),
      feesProportionalMillionths: dco_decode_u_32(arr[3]),
      cltvExpiryDelta: dco_decode_u_64(arr[4]),
      htlcMinimumMsat: dco_decode_opt_box_autoadd_u_64(arr[5]),
      htlcMaximumMsat: dco_decode_opt_box_autoadd_u_64(arr[6]),
    );
  }

  @protected
  SendOnchainRequest dco_decode_send_onchain_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4) throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return SendOnchainRequest(
      amountSat: dco_decode_u_64(arr[0]),
      onchainRecipientAddress: dco_decode_String(arr[1]),
      pairHash: dco_decode_String(arr[2]),
      satPerVbyte: dco_decode_u_32(arr[3]),
    );
  }

  @protected
  SendOnchainResponse dco_decode_send_onchain_response(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1) throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return SendOnchainResponse(
      reverseSwapInfo: dco_decode_reverse_swap_info(arr[0]),
    );
  }

  @protected
  SendPaymentRequest dco_decode_send_payment_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3) throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return SendPaymentRequest(
      bolt11: dco_decode_String(arr[0]),
      amountMsat: dco_decode_opt_box_autoadd_u_64(arr[1]),
      label: dco_decode_opt_String(arr[2]),
    );
  }

  @protected
  SendPaymentResponse dco_decode_send_payment_response(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1) throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return SendPaymentResponse(
      payment: dco_decode_payment(arr[0]),
    );
  }

  @protected
  SendSpontaneousPaymentRequest dco_decode_send_spontaneous_payment_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4) throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return SendSpontaneousPaymentRequest(
      nodeId: dco_decode_String(arr[0]),
      amountMsat: dco_decode_u_64(arr[1]),
      extraTlvs: dco_decode_opt_list_tlv_entry(arr[2]),
      label: dco_decode_opt_String(arr[3]),
    );
  }

  @protected
  ServiceHealthCheckResponse dco_decode_service_health_check_response(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1) throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return ServiceHealthCheckResponse(
      status: dco_decode_health_check_status(arr[0]),
    );
  }

  @protected
  SignMessageRequest dco_decode_sign_message_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1) throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return SignMessageRequest(
      message: dco_decode_String(arr[0]),
    );
  }

  @protected
  SignMessageResponse dco_decode_sign_message_response(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1) throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return SignMessageResponse(
      signature: dco_decode_String(arr[0]),
    );
  }

  @protected
  StaticBackupRequest dco_decode_static_backup_request(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1) throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return StaticBackupRequest(
      workingDir: dco_decode_String(arr[0]),
    );
  }

  @protected
  StaticBackupResponse dco_decode_static_backup_response(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1) throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return StaticBackupResponse(
      backup: dco_decode_opt_list_String(arr[0]),
    );
  }

  @protected
  SuccessActionProcessed dco_decode_success_action_processed(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return SuccessActionProcessed_Aes(
          result: dco_decode_box_autoadd_aes_success_action_data_result(raw[1]),
        );
      case 1:
        return SuccessActionProcessed_Message(
          data: dco_decode_box_autoadd_message_success_action_data(raw[1]),
        );
      case 2:
        return SuccessActionProcessed_Url(
          data: dco_decode_box_autoadd_url_success_action_data(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  SwapAmountType dco_decode_swap_amount_type(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return SwapAmountType.values[raw as int];
  }

  @protected
  SwapInfo dco_decode_swap_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 24) throw Exception('unexpected arr length: expect 24 but see ${arr.length}');
    return SwapInfo(
      bitcoinAddress: dco_decode_String(arr[0]),
      createdAt: dco_decode_i_64(arr[1]),
      lockHeight: dco_decode_i_64(arr[2]),
      paymentHash: dco_decode_list_prim_u_8_strict(arr[3]),
      preimage: dco_decode_list_prim_u_8_strict(arr[4]),
      privateKey: dco_decode_list_prim_u_8_strict(arr[5]),
      publicKey: dco_decode_list_prim_u_8_strict(arr[6]),
      swapperPublicKey: dco_decode_list_prim_u_8_strict(arr[7]),
      script: dco_decode_list_prim_u_8_strict(arr[8]),
      bolt11: dco_decode_opt_String(arr[9]),
      paidMsat: dco_decode_u_64(arr[10]),
      totalIncomingTxs: dco_decode_u_64(arr[11]),
      confirmedSats: dco_decode_u_64(arr[12]),
      unconfirmedSats: dco_decode_u_64(arr[13]),
      status: dco_decode_swap_status(arr[14]),
      refundTxIds: dco_decode_list_String(arr[15]),
      unconfirmedTxIds: dco_decode_list_String(arr[16]),
      confirmedTxIds: dco_decode_list_String(arr[17]),
      minAllowedDeposit: dco_decode_i_64(arr[18]),
      maxAllowedDeposit: dco_decode_i_64(arr[19]),
      maxSwapperPayable: dco_decode_i_64(arr[20]),
      lastRedeemError: dco_decode_opt_String(arr[21]),
      channelOpeningFees: dco_decode_opt_box_autoadd_opening_fee_params(arr[22]),
      confirmedAt: dco_decode_opt_box_autoadd_u_32(arr[23]),
    );
  }

  @protected
  SwapStatus dco_decode_swap_status(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return SwapStatus.values[raw as int];
  }

  @protected
  Symbol dco_decode_symbol(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4) throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return Symbol(
      grapheme: dco_decode_opt_String(arr[0]),
      template: dco_decode_opt_String(arr[1]),
      rtl: dco_decode_opt_box_autoadd_bool(arr[2]),
      position: dco_decode_opt_box_autoadd_u_32(arr[3]),
    );
  }

  @protected
  TlvEntry dco_decode_tlv_entry(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return TlvEntry(
      fieldNumber: dco_decode_u_64(arr[0]),
      value: dco_decode_list_prim_u_8_strict(arr[1]),
    );
  }

  @protected
  int dco_decode_u_16(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  int dco_decode_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  BigInt dco_decode_u_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeU64(raw);
  }

  @protected
  int dco_decode_u_8(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  void dco_decode_unit(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return;
  }

  @protected
  UnspentTransactionOutput dco_decode_unspent_transaction_output(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 5) throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
    return UnspentTransactionOutput(
      txid: dco_decode_list_prim_u_8_strict(arr[0]),
      outnum: dco_decode_u_32(arr[1]),
      amountMillisatoshi: dco_decode_u_64(arr[2]),
      address: dco_decode_String(arr[3]),
      reserved: dco_decode_bool(arr[4]),
    );
  }

  @protected
  UrlSuccessActionData dco_decode_url_success_action_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return UrlSuccessActionData(
      description: dco_decode_String(arr[0]),
      url: dco_decode_String(arr[1]),
    );
  }

  @protected
  AnyhowException sse_decode_AnyhowException(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_String(deserializer);
    return AnyhowException(inner);
  }

  @protected
  RustStreamSink<BreezEvent> sse_decode_StreamSink_breez_event_Dco(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    throw UnimplementedError('Unreachable ()');
  }

  @protected
  RustStreamSink<LogEntry> sse_decode_StreamSink_log_entry_Dco(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    throw UnimplementedError('Unreachable ()');
  }

  @protected
  String sse_decode_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_prim_u_8_strict(deserializer);
    return utf8.decoder.convert(inner);
  }

  @protected
  AesSuccessActionDataDecrypted sse_decode_aes_success_action_data_decrypted(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_description = sse_decode_String(deserializer);
    var var_plaintext = sse_decode_String(deserializer);
    return AesSuccessActionDataDecrypted(description: var_description, plaintext: var_plaintext);
  }

  @protected
  AesSuccessActionDataResult sse_decode_aes_success_action_data_result(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_data = sse_decode_box_autoadd_aes_success_action_data_decrypted(deserializer);
        return AesSuccessActionDataResult_Decrypted(data: var_data);
      case 1:
        var var_reason = sse_decode_String(deserializer);
        return AesSuccessActionDataResult_ErrorStatus(reason: var_reason);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  BackupFailedData sse_decode_backup_failed_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_error = sse_decode_String(deserializer);
    return BackupFailedData(error: var_error);
  }

  @protected
  BackupStatus sse_decode_backup_status(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_backedUp = sse_decode_bool(deserializer);
    var var_lastBackupTime = sse_decode_opt_box_autoadd_u_64(deserializer);
    return BackupStatus(backedUp: var_backedUp, lastBackupTime: var_lastBackupTime);
  }

  @protected
  BindingEventListener sse_decode_binding_event_listener(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return BindingEventListener();
  }

  @protected
  BitcoinAddressData sse_decode_bitcoin_address_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_address = sse_decode_String(deserializer);
    var var_network = sse_decode_network(deserializer);
    var var_amountSat = sse_decode_opt_box_autoadd_u_64(deserializer);
    var var_label = sse_decode_opt_String(deserializer);
    var var_message = sse_decode_opt_String(deserializer);
    return BitcoinAddressData(
        address: var_address,
        network: var_network,
        amountSat: var_amountSat,
        label: var_label,
        message: var_message);
  }

  @protected
  bool sse_decode_bool(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8() != 0;
  }

  @protected
  AesSuccessActionDataDecrypted sse_decode_box_autoadd_aes_success_action_data_decrypted(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_aes_success_action_data_decrypted(deserializer));
  }

  @protected
  AesSuccessActionDataResult sse_decode_box_autoadd_aes_success_action_data_result(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_aes_success_action_data_result(deserializer));
  }

  @protected
  BackupFailedData sse_decode_box_autoadd_backup_failed_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_backup_failed_data(deserializer));
  }

  @protected
  BindingEventListener sse_decode_box_autoadd_binding_event_listener(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_binding_event_listener(deserializer));
  }

  @protected
  BitcoinAddressData sse_decode_box_autoadd_bitcoin_address_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_bitcoin_address_data(deserializer));
  }

  @protected
  bool sse_decode_box_autoadd_bool(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_bool(deserializer));
  }

  @protected
  BreezEvent sse_decode_box_autoadd_breez_event(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_breez_event(deserializer));
  }

  @protected
  BuyBitcoinRequest sse_decode_box_autoadd_buy_bitcoin_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_buy_bitcoin_request(deserializer));
  }

  @protected
  CheckMessageRequest sse_decode_box_autoadd_check_message_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_check_message_request(deserializer));
  }

  @protected
  ClosedChannelPaymentDetails sse_decode_box_autoadd_closed_channel_payment_details(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_closed_channel_payment_details(deserializer));
  }

  @protected
  ConfigureNodeRequest sse_decode_box_autoadd_configure_node_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_configure_node_request(deserializer));
  }

  @protected
  ConnectRequest sse_decode_box_autoadd_connect_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_connect_request(deserializer));
  }

  @protected
  GreenlightCredentials sse_decode_box_autoadd_greenlight_credentials(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_greenlight_credentials(deserializer));
  }

  @protected
  GreenlightNodeConfig sse_decode_box_autoadd_greenlight_node_config(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_greenlight_node_config(deserializer));
  }

  @protected
  PlatformInt64 sse_decode_box_autoadd_i_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_i_64(deserializer));
  }

  @protected
  InvoicePaidDetails sse_decode_box_autoadd_invoice_paid_details(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_invoice_paid_details(deserializer));
  }

  @protected
  ListPaymentsRequest sse_decode_box_autoadd_list_payments_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_list_payments_request(deserializer));
  }

  @protected
  LNInvoice sse_decode_box_autoadd_ln_invoice(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ln_invoice(deserializer));
  }

  @protected
  LnPaymentDetails sse_decode_box_autoadd_ln_payment_details(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ln_payment_details(deserializer));
  }

  @protected
  LnUrlAuthRequestData sse_decode_box_autoadd_ln_url_auth_request_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ln_url_auth_request_data(deserializer));
  }

  @protected
  LnUrlErrorData sse_decode_box_autoadd_ln_url_error_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ln_url_error_data(deserializer));
  }

  @protected
  LnUrlPayErrorData sse_decode_box_autoadd_ln_url_pay_error_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ln_url_pay_error_data(deserializer));
  }

  @protected
  LnUrlPayRequest sse_decode_box_autoadd_ln_url_pay_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ln_url_pay_request(deserializer));
  }

  @protected
  LnUrlPayRequestData sse_decode_box_autoadd_ln_url_pay_request_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ln_url_pay_request_data(deserializer));
  }

  @protected
  LnUrlPaySuccessData sse_decode_box_autoadd_ln_url_pay_success_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ln_url_pay_success_data(deserializer));
  }

  @protected
  LnUrlWithdrawRequest sse_decode_box_autoadd_ln_url_withdraw_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ln_url_withdraw_request(deserializer));
  }

  @protected
  LnUrlWithdrawRequestData sse_decode_box_autoadd_ln_url_withdraw_request_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ln_url_withdraw_request_data(deserializer));
  }

  @protected
  LnUrlWithdrawSuccessData sse_decode_box_autoadd_ln_url_withdraw_success_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ln_url_withdraw_success_data(deserializer));
  }

  @protected
  LspInformation sse_decode_box_autoadd_lsp_information(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_lsp_information(deserializer));
  }

  @protected
  MessageSuccessActionData sse_decode_box_autoadd_message_success_action_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_message_success_action_data(deserializer));
  }

  @protected
  NodeConfig sse_decode_box_autoadd_node_config(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_node_config(deserializer));
  }

  @protected
  NodeCredentials sse_decode_box_autoadd_node_credentials(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_node_credentials(deserializer));
  }

  @protected
  OpenChannelFeeRequest sse_decode_box_autoadd_open_channel_fee_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_open_channel_fee_request(deserializer));
  }

  @protected
  OpeningFeeParams sse_decode_box_autoadd_opening_fee_params(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_opening_fee_params(deserializer));
  }

  @protected
  PayOnchainRequest sse_decode_box_autoadd_pay_onchain_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_pay_onchain_request(deserializer));
  }

  @protected
  Payment sse_decode_box_autoadd_payment(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_payment(deserializer));
  }

  @protected
  PaymentFailedData sse_decode_box_autoadd_payment_failed_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_payment_failed_data(deserializer));
  }

  @protected
  PrepareOnchainPaymentRequest sse_decode_box_autoadd_prepare_onchain_payment_request(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_prepare_onchain_payment_request(deserializer));
  }

  @protected
  PrepareRedeemOnchainFundsRequest sse_decode_box_autoadd_prepare_redeem_onchain_funds_request(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_prepare_redeem_onchain_funds_request(deserializer));
  }

  @protected
  PrepareRefundRequest sse_decode_box_autoadd_prepare_refund_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_prepare_refund_request(deserializer));
  }

  @protected
  ReceiveOnchainRequest sse_decode_box_autoadd_receive_onchain_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_receive_onchain_request(deserializer));
  }

  @protected
  ReceivePaymentRequest sse_decode_box_autoadd_receive_payment_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_receive_payment_request(deserializer));
  }

  @protected
  RedeemOnchainFundsRequest sse_decode_box_autoadd_redeem_onchain_funds_request(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_redeem_onchain_funds_request(deserializer));
  }

  @protected
  RefundRequest sse_decode_box_autoadd_refund_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_refund_request(deserializer));
  }

  @protected
  ReportIssueRequest sse_decode_box_autoadd_report_issue_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_report_issue_request(deserializer));
  }

  @protected
  ReportPaymentFailureDetails sse_decode_box_autoadd_report_payment_failure_details(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_report_payment_failure_details(deserializer));
  }

  @protected
  ReverseSwapFeesRequest sse_decode_box_autoadd_reverse_swap_fees_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_reverse_swap_fees_request(deserializer));
  }

  @protected
  ReverseSwapInfo sse_decode_box_autoadd_reverse_swap_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_reverse_swap_info(deserializer));
  }

  @protected
  SendOnchainRequest sse_decode_box_autoadd_send_onchain_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_send_onchain_request(deserializer));
  }

  @protected
  SendPaymentRequest sse_decode_box_autoadd_send_payment_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_send_payment_request(deserializer));
  }

  @protected
  SendSpontaneousPaymentRequest sse_decode_box_autoadd_send_spontaneous_payment_request(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_send_spontaneous_payment_request(deserializer));
  }

  @protected
  SignMessageRequest sse_decode_box_autoadd_sign_message_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_sign_message_request(deserializer));
  }

  @protected
  StaticBackupRequest sse_decode_box_autoadd_static_backup_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_static_backup_request(deserializer));
  }

  @protected
  SuccessActionProcessed sse_decode_box_autoadd_success_action_processed(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_success_action_processed(deserializer));
  }

  @protected
  SwapInfo sse_decode_box_autoadd_swap_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_swap_info(deserializer));
  }

  @protected
  Symbol sse_decode_box_autoadd_symbol(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_symbol(deserializer));
  }

  @protected
  int sse_decode_box_autoadd_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_u_32(deserializer));
  }

  @protected
  BigInt sse_decode_box_autoadd_u_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_u_64(deserializer));
  }

  @protected
  UrlSuccessActionData sse_decode_box_autoadd_url_success_action_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_url_success_action_data(deserializer));
  }

  @protected
  BreezEvent sse_decode_breez_event(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_block = sse_decode_u_32(deserializer);
        return BreezEvent_NewBlock(block: var_block);
      case 1:
        var var_details = sse_decode_box_autoadd_invoice_paid_details(deserializer);
        return BreezEvent_InvoicePaid(details: var_details);
      case 2:
        return BreezEvent_Synced();
      case 3:
        var var_details = sse_decode_box_autoadd_payment(deserializer);
        return BreezEvent_PaymentSucceed(details: var_details);
      case 4:
        var var_details = sse_decode_box_autoadd_payment_failed_data(deserializer);
        return BreezEvent_PaymentFailed(details: var_details);
      case 5:
        return BreezEvent_BackupStarted();
      case 6:
        return BreezEvent_BackupSucceeded();
      case 7:
        var var_details = sse_decode_box_autoadd_backup_failed_data(deserializer);
        return BreezEvent_BackupFailed(details: var_details);
      case 8:
        var var_details = sse_decode_box_autoadd_swap_info(deserializer);
        return BreezEvent_SwapUpdated(details: var_details);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  BuyBitcoinProvider sse_decode_buy_bitcoin_provider(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return BuyBitcoinProvider.values[inner];
  }

  @protected
  BuyBitcoinRequest sse_decode_buy_bitcoin_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_provider = sse_decode_buy_bitcoin_provider(deserializer);
    var var_openingFeeParams = sse_decode_opt_box_autoadd_opening_fee_params(deserializer);
    return BuyBitcoinRequest(provider: var_provider, openingFeeParams: var_openingFeeParams);
  }

  @protected
  BuyBitcoinResponse sse_decode_buy_bitcoin_response(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_url = sse_decode_String(deserializer);
    var var_openingFeeParams = sse_decode_opt_box_autoadd_opening_fee_params(deserializer);
    return BuyBitcoinResponse(url: var_url, openingFeeParams: var_openingFeeParams);
  }

  @protected
  ChannelState sse_decode_channel_state(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return ChannelState.values[inner];
  }

  @protected
  CheckMessageRequest sse_decode_check_message_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_message = sse_decode_String(deserializer);
    var var_pubkey = sse_decode_String(deserializer);
    var var_signature = sse_decode_String(deserializer);
    return CheckMessageRequest(message: var_message, pubkey: var_pubkey, signature: var_signature);
  }

  @protected
  CheckMessageResponse sse_decode_check_message_response(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_isValid = sse_decode_bool(deserializer);
    return CheckMessageResponse(isValid: var_isValid);
  }

  @protected
  ClosedChannelPaymentDetails sse_decode_closed_channel_payment_details(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_state = sse_decode_channel_state(deserializer);
    var var_fundingTxid = sse_decode_String(deserializer);
    var var_shortChannelId = sse_decode_opt_String(deserializer);
    var var_closingTxid = sse_decode_opt_String(deserializer);
    return ClosedChannelPaymentDetails(
        state: var_state,
        fundingTxid: var_fundingTxid,
        shortChannelId: var_shortChannelId,
        closingTxid: var_closingTxid);
  }

  @protected
  Config sse_decode_config(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_breezserver = sse_decode_String(deserializer);
    var var_chainnotifierUrl = sse_decode_String(deserializer);
    var var_mempoolspaceUrl = sse_decode_opt_String(deserializer);
    var var_workingDir = sse_decode_String(deserializer);
    var var_network = sse_decode_network(deserializer);
    var var_paymentTimeoutSec = sse_decode_u_32(deserializer);
    var var_defaultLspId = sse_decode_opt_String(deserializer);
    var var_apiKey = sse_decode_opt_String(deserializer);
    var var_maxfeePercent = sse_decode_f_64(deserializer);
    var var_exemptfeeMsat = sse_decode_u_64(deserializer);
    var var_nodeConfig = sse_decode_node_config(deserializer);
    return Config(
        breezserver: var_breezserver,
        chainnotifierUrl: var_chainnotifierUrl,
        mempoolspaceUrl: var_mempoolspaceUrl,
        workingDir: var_workingDir,
        network: var_network,
        paymentTimeoutSec: var_paymentTimeoutSec,
        defaultLspId: var_defaultLspId,
        apiKey: var_apiKey,
        maxfeePercent: var_maxfeePercent,
        exemptfeeMsat: var_exemptfeeMsat,
        nodeConfig: var_nodeConfig);
  }

  @protected
  ConfigureNodeRequest sse_decode_configure_node_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_closeToAddress = sse_decode_opt_String(deserializer);
    return ConfigureNodeRequest(closeToAddress: var_closeToAddress);
  }

  @protected
  ConnectRequest sse_decode_connect_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_config = sse_decode_config(deserializer);
    var var_seed = sse_decode_list_prim_u_8_strict(deserializer);
    var var_restoreOnly = sse_decode_opt_box_autoadd_bool(deserializer);
    return ConnectRequest(config: var_config, seed: var_seed, restoreOnly: var_restoreOnly);
  }

  @protected
  CurrencyInfo sse_decode_currency_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_name = sse_decode_String(deserializer);
    var var_fractionSize = sse_decode_u_32(deserializer);
    var var_spacing = sse_decode_opt_box_autoadd_u_32(deserializer);
    var var_symbol = sse_decode_opt_box_autoadd_symbol(deserializer);
    var var_uniqSymbol = sse_decode_opt_box_autoadd_symbol(deserializer);
    var var_localizedName = sse_decode_opt_list_localized_name(deserializer);
    var var_localeOverrides = sse_decode_opt_list_locale_overrides(deserializer);
    return CurrencyInfo(
        name: var_name,
        fractionSize: var_fractionSize,
        spacing: var_spacing,
        symbol: var_symbol,
        uniqSymbol: var_uniqSymbol,
        localizedName: var_localizedName,
        localeOverrides: var_localeOverrides);
  }

  @protected
  EnvironmentType sse_decode_environment_type(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return EnvironmentType.values[inner];
  }

  @protected
  double sse_decode_f_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getFloat64();
  }

  @protected
  FiatCurrency sse_decode_fiat_currency(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_id = sse_decode_String(deserializer);
    var var_info = sse_decode_currency_info(deserializer);
    return FiatCurrency(id: var_id, info: var_info);
  }

  @protected
  GreenlightCredentials sse_decode_greenlight_credentials(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_deviceKey = sse_decode_list_prim_u_8_strict(deserializer);
    var var_deviceCert = sse_decode_list_prim_u_8_strict(deserializer);
    return GreenlightCredentials(deviceKey: var_deviceKey, deviceCert: var_deviceCert);
  }

  @protected
  GreenlightNodeConfig sse_decode_greenlight_node_config(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_partnerCredentials = sse_decode_opt_box_autoadd_greenlight_credentials(deserializer);
    var var_inviteCode = sse_decode_opt_String(deserializer);
    return GreenlightNodeConfig(partnerCredentials: var_partnerCredentials, inviteCode: var_inviteCode);
  }

  @protected
  HealthCheckStatus sse_decode_health_check_status(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return HealthCheckStatus.values[inner];
  }

  @protected
  int sse_decode_i_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getInt32();
  }

  @protected
  PlatformInt64 sse_decode_i_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getPlatformInt64();
  }

  @protected
  InputType sse_decode_input_type(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_address = sse_decode_box_autoadd_bitcoin_address_data(deserializer);
        return InputType_BitcoinAddress(address: var_address);
      case 1:
        var var_invoice = sse_decode_box_autoadd_ln_invoice(deserializer);
        return InputType_Bolt11(invoice: var_invoice);
      case 2:
        var var_nodeId = sse_decode_String(deserializer);
        return InputType_NodeId(nodeId: var_nodeId);
      case 3:
        var var_url = sse_decode_String(deserializer);
        return InputType_Url(url: var_url);
      case 4:
        var var_data = sse_decode_box_autoadd_ln_url_pay_request_data(deserializer);
        return InputType_LnUrlPay(data: var_data);
      case 5:
        var var_data = sse_decode_box_autoadd_ln_url_withdraw_request_data(deserializer);
        return InputType_LnUrlWithdraw(data: var_data);
      case 6:
        var var_data = sse_decode_box_autoadd_ln_url_auth_request_data(deserializer);
        return InputType_LnUrlAuth(data: var_data);
      case 7:
        var var_data = sse_decode_box_autoadd_ln_url_error_data(deserializer);
        return InputType_LnUrlError(data: var_data);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  InvoicePaidDetails sse_decode_invoice_paid_details(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_paymentHash = sse_decode_String(deserializer);
    var var_bolt11 = sse_decode_String(deserializer);
    var var_payment = sse_decode_opt_box_autoadd_payment(deserializer);
    return InvoicePaidDetails(paymentHash: var_paymentHash, bolt11: var_bolt11, payment: var_payment);
  }

  @protected
  List<String> sse_decode_list_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <String>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_String(deserializer));
    }
    return ans_;
  }

  @protected
  List<FiatCurrency> sse_decode_list_fiat_currency(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <FiatCurrency>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_fiat_currency(deserializer));
    }
    return ans_;
  }

  @protected
  List<LocaleOverrides> sse_decode_list_locale_overrides(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <LocaleOverrides>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_locale_overrides(deserializer));
    }
    return ans_;
  }

  @protected
  List<LocalizedName> sse_decode_list_localized_name(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <LocalizedName>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_localized_name(deserializer));
    }
    return ans_;
  }

  @protected
  List<LspInformation> sse_decode_list_lsp_information(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <LspInformation>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_lsp_information(deserializer));
    }
    return ans_;
  }

  @protected
  List<MetadataFilter> sse_decode_list_metadata_filter(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <MetadataFilter>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_metadata_filter(deserializer));
    }
    return ans_;
  }

  @protected
  List<OpeningFeeParams> sse_decode_list_opening_fee_params(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <OpeningFeeParams>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_opening_fee_params(deserializer));
    }
    return ans_;
  }

  @protected
  List<Payment> sse_decode_list_payment(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <Payment>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_payment(deserializer));
    }
    return ans_;
  }

  @protected
  List<PaymentTypeFilter> sse_decode_list_payment_type_filter(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <PaymentTypeFilter>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_payment_type_filter(deserializer));
    }
    return ans_;
  }

  @protected
  ListPaymentsRequest sse_decode_list_payments_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_filters = sse_decode_opt_list_payment_type_filter(deserializer);
    var var_metadataFilters = sse_decode_opt_list_metadata_filter(deserializer);
    var var_fromTimestamp = sse_decode_opt_box_autoadd_i_64(deserializer);
    var var_toTimestamp = sse_decode_opt_box_autoadd_i_64(deserializer);
    var var_includeFailures = sse_decode_opt_box_autoadd_bool(deserializer);
    var var_offset = sse_decode_opt_box_autoadd_u_32(deserializer);
    var var_limit = sse_decode_opt_box_autoadd_u_32(deserializer);
    return ListPaymentsRequest(
        filters: var_filters,
        metadataFilters: var_metadataFilters,
        fromTimestamp: var_fromTimestamp,
        toTimestamp: var_toTimestamp,
        includeFailures: var_includeFailures,
        offset: var_offset,
        limit: var_limit);
  }

  @protected
  Uint8List sse_decode_list_prim_u_8_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint8List(len_);
  }

  @protected
  List<Rate> sse_decode_list_rate(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <Rate>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_rate(deserializer));
    }
    return ans_;
  }

  @protected
  List<ReverseSwapInfo> sse_decode_list_reverse_swap_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <ReverseSwapInfo>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_reverse_swap_info(deserializer));
    }
    return ans_;
  }

  @protected
  List<RouteHint> sse_decode_list_route_hint(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <RouteHint>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_route_hint(deserializer));
    }
    return ans_;
  }

  @protected
  List<RouteHintHop> sse_decode_list_route_hint_hop(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <RouteHintHop>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_route_hint_hop(deserializer));
    }
    return ans_;
  }

  @protected
  List<SwapInfo> sse_decode_list_swap_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <SwapInfo>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_swap_info(deserializer));
    }
    return ans_;
  }

  @protected
  List<TlvEntry> sse_decode_list_tlv_entry(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <TlvEntry>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_tlv_entry(deserializer));
    }
    return ans_;
  }

  @protected
  List<UnspentTransactionOutput> sse_decode_list_unspent_transaction_output(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <UnspentTransactionOutput>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_unspent_transaction_output(deserializer));
    }
    return ans_;
  }

  @protected
  LNInvoice sse_decode_ln_invoice(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_bolt11 = sse_decode_String(deserializer);
    var var_network = sse_decode_network(deserializer);
    var var_payeePubkey = sse_decode_String(deserializer);
    var var_paymentHash = sse_decode_String(deserializer);
    var var_description = sse_decode_opt_String(deserializer);
    var var_descriptionHash = sse_decode_opt_String(deserializer);
    var var_amountMsat = sse_decode_opt_box_autoadd_u_64(deserializer);
    var var_timestamp = sse_decode_u_64(deserializer);
    var var_expiry = sse_decode_u_64(deserializer);
    var var_routingHints = sse_decode_list_route_hint(deserializer);
    var var_paymentSecret = sse_decode_list_prim_u_8_strict(deserializer);
    var var_minFinalCltvExpiryDelta = sse_decode_u_64(deserializer);
    return LNInvoice(
        bolt11: var_bolt11,
        network: var_network,
        payeePubkey: var_payeePubkey,
        paymentHash: var_paymentHash,
        description: var_description,
        descriptionHash: var_descriptionHash,
        amountMsat: var_amountMsat,
        timestamp: var_timestamp,
        expiry: var_expiry,
        routingHints: var_routingHints,
        paymentSecret: var_paymentSecret,
        minFinalCltvExpiryDelta: var_minFinalCltvExpiryDelta);
  }

  @protected
  LnPaymentDetails sse_decode_ln_payment_details(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_paymentHash = sse_decode_String(deserializer);
    var var_label = sse_decode_String(deserializer);
    var var_destinationPubkey = sse_decode_String(deserializer);
    var var_paymentPreimage = sse_decode_String(deserializer);
    var var_keysend = sse_decode_bool(deserializer);
    var var_bolt11 = sse_decode_String(deserializer);
    var var_openChannelBolt11 = sse_decode_opt_String(deserializer);
    var var_lnurlSuccessAction = sse_decode_opt_box_autoadd_success_action_processed(deserializer);
    var var_lnurlPayDomain = sse_decode_opt_String(deserializer);
    var var_lnurlPayComment = sse_decode_opt_String(deserializer);
    var var_lnAddress = sse_decode_opt_String(deserializer);
    var var_lnurlMetadata = sse_decode_opt_String(deserializer);
    var var_lnurlWithdrawEndpoint = sse_decode_opt_String(deserializer);
    var var_swapInfo = sse_decode_opt_box_autoadd_swap_info(deserializer);
    var var_reverseSwapInfo = sse_decode_opt_box_autoadd_reverse_swap_info(deserializer);
    var var_pendingExpirationBlock = sse_decode_opt_box_autoadd_u_32(deserializer);
    return LnPaymentDetails(
        paymentHash: var_paymentHash,
        label: var_label,
        destinationPubkey: var_destinationPubkey,
        paymentPreimage: var_paymentPreimage,
        keysend: var_keysend,
        bolt11: var_bolt11,
        openChannelBolt11: var_openChannelBolt11,
        lnurlSuccessAction: var_lnurlSuccessAction,
        lnurlPayDomain: var_lnurlPayDomain,
        lnurlPayComment: var_lnurlPayComment,
        lnAddress: var_lnAddress,
        lnurlMetadata: var_lnurlMetadata,
        lnurlWithdrawEndpoint: var_lnurlWithdrawEndpoint,
        swapInfo: var_swapInfo,
        reverseSwapInfo: var_reverseSwapInfo,
        pendingExpirationBlock: var_pendingExpirationBlock);
  }

  @protected
  LnUrlAuthRequestData sse_decode_ln_url_auth_request_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_k1 = sse_decode_String(deserializer);
    var var_action = sse_decode_opt_String(deserializer);
    var var_domain = sse_decode_String(deserializer);
    var var_url = sse_decode_String(deserializer);
    return LnUrlAuthRequestData(k1: var_k1, action: var_action, domain: var_domain, url: var_url);
  }

  @protected
  LnUrlCallbackStatus sse_decode_ln_url_callback_status(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        return LnUrlCallbackStatus_Ok();
      case 1:
        var var_data = sse_decode_box_autoadd_ln_url_error_data(deserializer);
        return LnUrlCallbackStatus_ErrorStatus(data: var_data);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  LnUrlErrorData sse_decode_ln_url_error_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_reason = sse_decode_String(deserializer);
    return LnUrlErrorData(reason: var_reason);
  }

  @protected
  LnUrlPayErrorData sse_decode_ln_url_pay_error_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_paymentHash = sse_decode_String(deserializer);
    var var_reason = sse_decode_String(deserializer);
    return LnUrlPayErrorData(paymentHash: var_paymentHash, reason: var_reason);
  }

  @protected
  LnUrlPayRequest sse_decode_ln_url_pay_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_data = sse_decode_ln_url_pay_request_data(deserializer);
    var var_amountMsat = sse_decode_u_64(deserializer);
    var var_comment = sse_decode_opt_String(deserializer);
    var var_paymentLabel = sse_decode_opt_String(deserializer);
    return LnUrlPayRequest(
        data: var_data, amountMsat: var_amountMsat, comment: var_comment, paymentLabel: var_paymentLabel);
  }

  @protected
  LnUrlPayRequestData sse_decode_ln_url_pay_request_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_callback = sse_decode_String(deserializer);
    var var_minSendable = sse_decode_u_64(deserializer);
    var var_maxSendable = sse_decode_u_64(deserializer);
    var var_metadataStr = sse_decode_String(deserializer);
    var var_commentAllowed = sse_decode_u_16(deserializer);
    var var_domain = sse_decode_String(deserializer);
    var var_allowsNostr = sse_decode_bool(deserializer);
    var var_nostrPubkey = sse_decode_opt_String(deserializer);
    var var_lnAddress = sse_decode_opt_String(deserializer);
    return LnUrlPayRequestData(
        callback: var_callback,
        minSendable: var_minSendable,
        maxSendable: var_maxSendable,
        metadataStr: var_metadataStr,
        commentAllowed: var_commentAllowed,
        domain: var_domain,
        allowsNostr: var_allowsNostr,
        nostrPubkey: var_nostrPubkey,
        lnAddress: var_lnAddress);
  }

  @protected
  LnUrlPayResult sse_decode_ln_url_pay_result(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_data = sse_decode_box_autoadd_ln_url_pay_success_data(deserializer);
        return LnUrlPayResult_EndpointSuccess(data: var_data);
      case 1:
        var var_data = sse_decode_box_autoadd_ln_url_error_data(deserializer);
        return LnUrlPayResult_EndpointError(data: var_data);
      case 2:
        var var_data = sse_decode_box_autoadd_ln_url_pay_error_data(deserializer);
        return LnUrlPayResult_PayError(data: var_data);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  LnUrlPaySuccessData sse_decode_ln_url_pay_success_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_payment = sse_decode_payment(deserializer);
    var var_successAction = sse_decode_opt_box_autoadd_success_action_processed(deserializer);
    return LnUrlPaySuccessData(payment: var_payment, successAction: var_successAction);
  }

  @protected
  LnUrlWithdrawRequest sse_decode_ln_url_withdraw_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_data = sse_decode_ln_url_withdraw_request_data(deserializer);
    var var_amountMsat = sse_decode_u_64(deserializer);
    var var_description = sse_decode_opt_String(deserializer);
    return LnUrlWithdrawRequest(data: var_data, amountMsat: var_amountMsat, description: var_description);
  }

  @protected
  LnUrlWithdrawRequestData sse_decode_ln_url_withdraw_request_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_callback = sse_decode_String(deserializer);
    var var_k1 = sse_decode_String(deserializer);
    var var_defaultDescription = sse_decode_String(deserializer);
    var var_minWithdrawable = sse_decode_u_64(deserializer);
    var var_maxWithdrawable = sse_decode_u_64(deserializer);
    return LnUrlWithdrawRequestData(
        callback: var_callback,
        k1: var_k1,
        defaultDescription: var_defaultDescription,
        minWithdrawable: var_minWithdrawable,
        maxWithdrawable: var_maxWithdrawable);
  }

  @protected
  LnUrlWithdrawResult sse_decode_ln_url_withdraw_result(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_data = sse_decode_box_autoadd_ln_url_withdraw_success_data(deserializer);
        return LnUrlWithdrawResult_Ok(data: var_data);
      case 1:
        var var_data = sse_decode_box_autoadd_ln_url_error_data(deserializer);
        return LnUrlWithdrawResult_ErrorStatus(data: var_data);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  LnUrlWithdrawSuccessData sse_decode_ln_url_withdraw_success_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_invoice = sse_decode_ln_invoice(deserializer);
    return LnUrlWithdrawSuccessData(invoice: var_invoice);
  }

  @protected
  LocaleOverrides sse_decode_locale_overrides(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_locale = sse_decode_String(deserializer);
    var var_spacing = sse_decode_opt_box_autoadd_u_32(deserializer);
    var var_symbol = sse_decode_symbol(deserializer);
    return LocaleOverrides(locale: var_locale, spacing: var_spacing, symbol: var_symbol);
  }

  @protected
  LocalizedName sse_decode_localized_name(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_locale = sse_decode_String(deserializer);
    var var_name = sse_decode_String(deserializer);
    return LocalizedName(locale: var_locale, name: var_name);
  }

  @protected
  LogEntry sse_decode_log_entry(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_line = sse_decode_String(deserializer);
    var var_level = sse_decode_String(deserializer);
    return LogEntry(line: var_line, level: var_level);
  }

  @protected
  LspInformation sse_decode_lsp_information(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_id = sse_decode_String(deserializer);
    var var_name = sse_decode_String(deserializer);
    var var_widgetUrl = sse_decode_String(deserializer);
    var var_pubkey = sse_decode_String(deserializer);
    var var_host = sse_decode_String(deserializer);
    var var_baseFeeMsat = sse_decode_i_64(deserializer);
    var var_feeRate = sse_decode_f_64(deserializer);
    var var_timeLockDelta = sse_decode_u_32(deserializer);
    var var_minHtlcMsat = sse_decode_i_64(deserializer);
    var var_lspPubkey = sse_decode_list_prim_u_8_strict(deserializer);
    var var_openingFeeParamsList = sse_decode_opening_fee_params_menu(deserializer);
    return LspInformation(
        id: var_id,
        name: var_name,
        widgetUrl: var_widgetUrl,
        pubkey: var_pubkey,
        host: var_host,
        baseFeeMsat: var_baseFeeMsat,
        feeRate: var_feeRate,
        timeLockDelta: var_timeLockDelta,
        minHtlcMsat: var_minHtlcMsat,
        lspPubkey: var_lspPubkey,
        openingFeeParamsList: var_openingFeeParamsList);
  }

  @protected
  MaxReverseSwapAmountResponse sse_decode_max_reverse_swap_amount_response(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_totalSat = sse_decode_u_64(deserializer);
    return MaxReverseSwapAmountResponse(totalSat: var_totalSat);
  }

  @protected
  MessageSuccessActionData sse_decode_message_success_action_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_message = sse_decode_String(deserializer);
    return MessageSuccessActionData(message: var_message);
  }

  @protected
  MetadataFilter sse_decode_metadata_filter(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_jsonPath = sse_decode_String(deserializer);
    var var_jsonValue = sse_decode_String(deserializer);
    return MetadataFilter(jsonPath: var_jsonPath, jsonValue: var_jsonValue);
  }

  @protected
  Network sse_decode_network(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return Network.values[inner];
  }

  @protected
  NodeConfig sse_decode_node_config(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_config = sse_decode_box_autoadd_greenlight_node_config(deserializer);
        return NodeConfig_Greenlight(config: var_config);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  NodeCredentials sse_decode_node_credentials(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_credentials = sse_decode_box_autoadd_greenlight_credentials(deserializer);
        return NodeCredentials_Greenlight(credentials: var_credentials);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  NodeState sse_decode_node_state(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_id = sse_decode_String(deserializer);
    var var_blockHeight = sse_decode_u_32(deserializer);
    var var_channelsBalanceMsat = sse_decode_u_64(deserializer);
    var var_onchainBalanceMsat = sse_decode_u_64(deserializer);
    var var_pendingOnchainBalanceMsat = sse_decode_u_64(deserializer);
    var var_utxos = sse_decode_list_unspent_transaction_output(deserializer);
    var var_maxPayableMsat = sse_decode_u_64(deserializer);
    var var_maxReceivableMsat = sse_decode_u_64(deserializer);
    var var_maxSinglePaymentAmountMsat = sse_decode_u_64(deserializer);
    var var_maxChanReserveMsats = sse_decode_u_64(deserializer);
    var var_connectedPeers = sse_decode_list_String(deserializer);
    var var_inboundLiquidityMsats = sse_decode_u_64(deserializer);
    return NodeState(
        id: var_id,
        blockHeight: var_blockHeight,
        channelsBalanceMsat: var_channelsBalanceMsat,
        onchainBalanceMsat: var_onchainBalanceMsat,
        pendingOnchainBalanceMsat: var_pendingOnchainBalanceMsat,
        utxos: var_utxos,
        maxPayableMsat: var_maxPayableMsat,
        maxReceivableMsat: var_maxReceivableMsat,
        maxSinglePaymentAmountMsat: var_maxSinglePaymentAmountMsat,
        maxChanReserveMsats: var_maxChanReserveMsats,
        connectedPeers: var_connectedPeers,
        inboundLiquidityMsats: var_inboundLiquidityMsats);
  }

  @protected
  OnchainPaymentLimitsResponse sse_decode_onchain_payment_limits_response(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_minSat = sse_decode_u_64(deserializer);
    var var_maxSat = sse_decode_u_64(deserializer);
    return OnchainPaymentLimitsResponse(minSat: var_minSat, maxSat: var_maxSat);
  }

  @protected
  OpenChannelFeeRequest sse_decode_open_channel_fee_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_amountMsat = sse_decode_opt_box_autoadd_u_64(deserializer);
    var var_expiry = sse_decode_opt_box_autoadd_u_32(deserializer);
    return OpenChannelFeeRequest(amountMsat: var_amountMsat, expiry: var_expiry);
  }

  @protected
  OpenChannelFeeResponse sse_decode_open_channel_fee_response(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_feeMsat = sse_decode_opt_box_autoadd_u_64(deserializer);
    var var_feeParams = sse_decode_opening_fee_params(deserializer);
    return OpenChannelFeeResponse(feeMsat: var_feeMsat, feeParams: var_feeParams);
  }

  @protected
  OpeningFeeParams sse_decode_opening_fee_params(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_minMsat = sse_decode_u_64(deserializer);
    var var_proportional = sse_decode_u_32(deserializer);
    var var_validUntil = sse_decode_String(deserializer);
    var var_maxIdleTime = sse_decode_u_32(deserializer);
    var var_maxClientToSelfDelay = sse_decode_u_32(deserializer);
    var var_promise = sse_decode_String(deserializer);
    return OpeningFeeParams(
        minMsat: var_minMsat,
        proportional: var_proportional,
        validUntil: var_validUntil,
        maxIdleTime: var_maxIdleTime,
        maxClientToSelfDelay: var_maxClientToSelfDelay,
        promise: var_promise);
  }

  @protected
  OpeningFeeParamsMenu sse_decode_opening_fee_params_menu(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_values = sse_decode_list_opening_fee_params(deserializer);
    return OpeningFeeParamsMenu(values: var_values);
  }

  @protected
  String? sse_decode_opt_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_String(deserializer));
    } else {
      return null;
    }
  }

  @protected
  bool? sse_decode_opt_box_autoadd_bool(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_bool(deserializer));
    } else {
      return null;
    }
  }

  @protected
  GreenlightCredentials? sse_decode_opt_box_autoadd_greenlight_credentials(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_greenlight_credentials(deserializer));
    } else {
      return null;
    }
  }

  @protected
  PlatformInt64? sse_decode_opt_box_autoadd_i_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_i_64(deserializer));
    } else {
      return null;
    }
  }

  @protected
  LNInvoice? sse_decode_opt_box_autoadd_ln_invoice(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_ln_invoice(deserializer));
    } else {
      return null;
    }
  }

  @protected
  LspInformation? sse_decode_opt_box_autoadd_lsp_information(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_lsp_information(deserializer));
    } else {
      return null;
    }
  }

  @protected
  NodeCredentials? sse_decode_opt_box_autoadd_node_credentials(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_node_credentials(deserializer));
    } else {
      return null;
    }
  }

  @protected
  OpeningFeeParams? sse_decode_opt_box_autoadd_opening_fee_params(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_opening_fee_params(deserializer));
    } else {
      return null;
    }
  }

  @protected
  Payment? sse_decode_opt_box_autoadd_payment(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_payment(deserializer));
    } else {
      return null;
    }
  }

  @protected
  ReverseSwapInfo? sse_decode_opt_box_autoadd_reverse_swap_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_reverse_swap_info(deserializer));
    } else {
      return null;
    }
  }

  @protected
  SuccessActionProcessed? sse_decode_opt_box_autoadd_success_action_processed(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_success_action_processed(deserializer));
    } else {
      return null;
    }
  }

  @protected
  SwapInfo? sse_decode_opt_box_autoadd_swap_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_swap_info(deserializer));
    } else {
      return null;
    }
  }

  @protected
  Symbol? sse_decode_opt_box_autoadd_symbol(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_symbol(deserializer));
    } else {
      return null;
    }
  }

  @protected
  int? sse_decode_opt_box_autoadd_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_u_32(deserializer));
    } else {
      return null;
    }
  }

  @protected
  BigInt? sse_decode_opt_box_autoadd_u_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_u_64(deserializer));
    } else {
      return null;
    }
  }

  @protected
  List<String>? sse_decode_opt_list_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_list_String(deserializer));
    } else {
      return null;
    }
  }

  @protected
  List<LocaleOverrides>? sse_decode_opt_list_locale_overrides(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_list_locale_overrides(deserializer));
    } else {
      return null;
    }
  }

  @protected
  List<LocalizedName>? sse_decode_opt_list_localized_name(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_list_localized_name(deserializer));
    } else {
      return null;
    }
  }

  @protected
  List<MetadataFilter>? sse_decode_opt_list_metadata_filter(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_list_metadata_filter(deserializer));
    } else {
      return null;
    }
  }

  @protected
  List<PaymentTypeFilter>? sse_decode_opt_list_payment_type_filter(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_list_payment_type_filter(deserializer));
    } else {
      return null;
    }
  }

  @protected
  Uint8List? sse_decode_opt_list_prim_u_8_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_list_prim_u_8_strict(deserializer));
    } else {
      return null;
    }
  }

  @protected
  List<TlvEntry>? sse_decode_opt_list_tlv_entry(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_list_tlv_entry(deserializer));
    } else {
      return null;
    }
  }

  @protected
  PayOnchainRequest sse_decode_pay_onchain_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_recipientAddress = sse_decode_String(deserializer);
    var var_prepareRes = sse_decode_prepare_onchain_payment_response(deserializer);
    return PayOnchainRequest(recipientAddress: var_recipientAddress, prepareRes: var_prepareRes);
  }

  @protected
  PayOnchainResponse sse_decode_pay_onchain_response(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_reverseSwapInfo = sse_decode_reverse_swap_info(deserializer);
    return PayOnchainResponse(reverseSwapInfo: var_reverseSwapInfo);
  }

  @protected
  Payment sse_decode_payment(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_id = sse_decode_String(deserializer);
    var var_paymentType = sse_decode_payment_type(deserializer);
    var var_paymentTime = sse_decode_i_64(deserializer);
    var var_amountMsat = sse_decode_u_64(deserializer);
    var var_feeMsat = sse_decode_u_64(deserializer);
    var var_status = sse_decode_payment_status(deserializer);
    var var_error = sse_decode_opt_String(deserializer);
    var var_description = sse_decode_opt_String(deserializer);
    var var_details = sse_decode_payment_details(deserializer);
    var var_metadata = sse_decode_opt_String(deserializer);
    return Payment(
        id: var_id,
        paymentType: var_paymentType,
        paymentTime: var_paymentTime,
        amountMsat: var_amountMsat,
        feeMsat: var_feeMsat,
        status: var_status,
        error: var_error,
        description: var_description,
        details: var_details,
        metadata: var_metadata);
  }

  @protected
  PaymentDetails sse_decode_payment_details(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_data = sse_decode_box_autoadd_ln_payment_details(deserializer);
        return PaymentDetails_Ln(data: var_data);
      case 1:
        var var_data = sse_decode_box_autoadd_closed_channel_payment_details(deserializer);
        return PaymentDetails_ClosedChannel(data: var_data);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  PaymentFailedData sse_decode_payment_failed_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_error = sse_decode_String(deserializer);
    var var_nodeId = sse_decode_String(deserializer);
    var var_invoice = sse_decode_opt_box_autoadd_ln_invoice(deserializer);
    var var_label = sse_decode_opt_String(deserializer);
    return PaymentFailedData(error: var_error, nodeId: var_nodeId, invoice: var_invoice, label: var_label);
  }

  @protected
  PaymentStatus sse_decode_payment_status(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return PaymentStatus.values[inner];
  }

  @protected
  PaymentType sse_decode_payment_type(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return PaymentType.values[inner];
  }

  @protected
  PaymentTypeFilter sse_decode_payment_type_filter(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return PaymentTypeFilter.values[inner];
  }

  @protected
  PrepareOnchainPaymentRequest sse_decode_prepare_onchain_payment_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_amountSat = sse_decode_u_64(deserializer);
    var var_amountType = sse_decode_swap_amount_type(deserializer);
    var var_claimTxFeerate = sse_decode_u_32(deserializer);
    return PrepareOnchainPaymentRequest(
        amountSat: var_amountSat, amountType: var_amountType, claimTxFeerate: var_claimTxFeerate);
  }

  @protected
  PrepareOnchainPaymentResponse sse_decode_prepare_onchain_payment_response(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_feesHash = sse_decode_String(deserializer);
    var var_feesPercentage = sse_decode_f_64(deserializer);
    var var_feesLockup = sse_decode_u_64(deserializer);
    var var_feesClaim = sse_decode_u_64(deserializer);
    var var_senderAmountSat = sse_decode_u_64(deserializer);
    var var_recipientAmountSat = sse_decode_u_64(deserializer);
    var var_totalFees = sse_decode_u_64(deserializer);
    return PrepareOnchainPaymentResponse(
        feesHash: var_feesHash,
        feesPercentage: var_feesPercentage,
        feesLockup: var_feesLockup,
        feesClaim: var_feesClaim,
        senderAmountSat: var_senderAmountSat,
        recipientAmountSat: var_recipientAmountSat,
        totalFees: var_totalFees);
  }

  @protected
  PrepareRedeemOnchainFundsRequest sse_decode_prepare_redeem_onchain_funds_request(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_toAddress = sse_decode_String(deserializer);
    var var_satPerVbyte = sse_decode_u_32(deserializer);
    return PrepareRedeemOnchainFundsRequest(toAddress: var_toAddress, satPerVbyte: var_satPerVbyte);
  }

  @protected
  PrepareRedeemOnchainFundsResponse sse_decode_prepare_redeem_onchain_funds_response(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_txWeight = sse_decode_u_64(deserializer);
    var var_txFeeSat = sse_decode_u_64(deserializer);
    return PrepareRedeemOnchainFundsResponse(txWeight: var_txWeight, txFeeSat: var_txFeeSat);
  }

  @protected
  PrepareRefundRequest sse_decode_prepare_refund_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_swapAddress = sse_decode_String(deserializer);
    var var_toAddress = sse_decode_String(deserializer);
    var var_satPerVbyte = sse_decode_u_32(deserializer);
    return PrepareRefundRequest(
        swapAddress: var_swapAddress, toAddress: var_toAddress, satPerVbyte: var_satPerVbyte);
  }

  @protected
  PrepareRefundResponse sse_decode_prepare_refund_response(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_refundTxWeight = sse_decode_u_32(deserializer);
    var var_refundTxFeeSat = sse_decode_u_64(deserializer);
    return PrepareRefundResponse(refundTxWeight: var_refundTxWeight, refundTxFeeSat: var_refundTxFeeSat);
  }

  @protected
  Rate sse_decode_rate(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_coin = sse_decode_String(deserializer);
    var var_value = sse_decode_f_64(deserializer);
    return Rate(coin: var_coin, value: var_value);
  }

  @protected
  ReceiveOnchainRequest sse_decode_receive_onchain_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_openingFeeParams = sse_decode_opt_box_autoadd_opening_fee_params(deserializer);
    return ReceiveOnchainRequest(openingFeeParams: var_openingFeeParams);
  }

  @protected
  ReceivePaymentRequest sse_decode_receive_payment_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_amountMsat = sse_decode_u_64(deserializer);
    var var_description = sse_decode_String(deserializer);
    var var_preimage = sse_decode_opt_list_prim_u_8_strict(deserializer);
    var var_openingFeeParams = sse_decode_opt_box_autoadd_opening_fee_params(deserializer);
    var var_useDescriptionHash = sse_decode_opt_box_autoadd_bool(deserializer);
    var var_expiry = sse_decode_opt_box_autoadd_u_32(deserializer);
    var var_cltv = sse_decode_opt_box_autoadd_u_32(deserializer);
    return ReceivePaymentRequest(
        amountMsat: var_amountMsat,
        description: var_description,
        preimage: var_preimage,
        openingFeeParams: var_openingFeeParams,
        useDescriptionHash: var_useDescriptionHash,
        expiry: var_expiry,
        cltv: var_cltv);
  }

  @protected
  ReceivePaymentResponse sse_decode_receive_payment_response(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_lnInvoice = sse_decode_ln_invoice(deserializer);
    var var_openingFeeParams = sse_decode_opt_box_autoadd_opening_fee_params(deserializer);
    var var_openingFeeMsat = sse_decode_opt_box_autoadd_u_64(deserializer);
    return ReceivePaymentResponse(
        lnInvoice: var_lnInvoice, openingFeeParams: var_openingFeeParams, openingFeeMsat: var_openingFeeMsat);
  }

  @protected
  RecommendedFees sse_decode_recommended_fees(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_fastestFee = sse_decode_u_64(deserializer);
    var var_halfHourFee = sse_decode_u_64(deserializer);
    var var_hourFee = sse_decode_u_64(deserializer);
    var var_economyFee = sse_decode_u_64(deserializer);
    var var_minimumFee = sse_decode_u_64(deserializer);
    return RecommendedFees(
        fastestFee: var_fastestFee,
        halfHourFee: var_halfHourFee,
        hourFee: var_hourFee,
        economyFee: var_economyFee,
        minimumFee: var_minimumFee);
  }

  @protected
  RedeemOnchainFundsRequest sse_decode_redeem_onchain_funds_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_toAddress = sse_decode_String(deserializer);
    var var_satPerVbyte = sse_decode_u_32(deserializer);
    return RedeemOnchainFundsRequest(toAddress: var_toAddress, satPerVbyte: var_satPerVbyte);
  }

  @protected
  RedeemOnchainFundsResponse sse_decode_redeem_onchain_funds_response(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_txid = sse_decode_list_prim_u_8_strict(deserializer);
    return RedeemOnchainFundsResponse(txid: var_txid);
  }

  @protected
  RefundRequest sse_decode_refund_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_swapAddress = sse_decode_String(deserializer);
    var var_toAddress = sse_decode_String(deserializer);
    var var_satPerVbyte = sse_decode_u_32(deserializer);
    return RefundRequest(
        swapAddress: var_swapAddress, toAddress: var_toAddress, satPerVbyte: var_satPerVbyte);
  }

  @protected
  RefundResponse sse_decode_refund_response(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_refundTxId = sse_decode_String(deserializer);
    return RefundResponse(refundTxId: var_refundTxId);
  }

  @protected
  ReportIssueRequest sse_decode_report_issue_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_data = sse_decode_box_autoadd_report_payment_failure_details(deserializer);
        return ReportIssueRequest_PaymentFailure(data: var_data);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  ReportPaymentFailureDetails sse_decode_report_payment_failure_details(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_paymentHash = sse_decode_String(deserializer);
    var var_comment = sse_decode_opt_String(deserializer);
    return ReportPaymentFailureDetails(paymentHash: var_paymentHash, comment: var_comment);
  }

  @protected
  ReverseSwapFeesRequest sse_decode_reverse_swap_fees_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_sendAmountSat = sse_decode_opt_box_autoadd_u_64(deserializer);
    var var_claimTxFeerate = sse_decode_opt_box_autoadd_u_32(deserializer);
    return ReverseSwapFeesRequest(sendAmountSat: var_sendAmountSat, claimTxFeerate: var_claimTxFeerate);
  }

  @protected
  ReverseSwapInfo sse_decode_reverse_swap_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_id = sse_decode_String(deserializer);
    var var_claimPubkey = sse_decode_String(deserializer);
    var var_lockupTxid = sse_decode_opt_String(deserializer);
    var var_claimTxid = sse_decode_opt_String(deserializer);
    var var_onchainAmountSat = sse_decode_u_64(deserializer);
    var var_status = sse_decode_reverse_swap_status(deserializer);
    return ReverseSwapInfo(
        id: var_id,
        claimPubkey: var_claimPubkey,
        lockupTxid: var_lockupTxid,
        claimTxid: var_claimTxid,
        onchainAmountSat: var_onchainAmountSat,
        status: var_status);
  }

  @protected
  ReverseSwapPairInfo sse_decode_reverse_swap_pair_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_min = sse_decode_u_64(deserializer);
    var var_max = sse_decode_u_64(deserializer);
    var var_feesHash = sse_decode_String(deserializer);
    var var_feesPercentage = sse_decode_f_64(deserializer);
    var var_feesLockup = sse_decode_u_64(deserializer);
    var var_feesClaim = sse_decode_u_64(deserializer);
    var var_totalFees = sse_decode_opt_box_autoadd_u_64(deserializer);
    return ReverseSwapPairInfo(
        min: var_min,
        max: var_max,
        feesHash: var_feesHash,
        feesPercentage: var_feesPercentage,
        feesLockup: var_feesLockup,
        feesClaim: var_feesClaim,
        totalFees: var_totalFees);
  }

  @protected
  ReverseSwapStatus sse_decode_reverse_swap_status(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return ReverseSwapStatus.values[inner];
  }

  @protected
  RouteHint sse_decode_route_hint(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_hops = sse_decode_list_route_hint_hop(deserializer);
    return RouteHint(hops: var_hops);
  }

  @protected
  RouteHintHop sse_decode_route_hint_hop(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_srcNodeId = sse_decode_String(deserializer);
    var var_shortChannelId = sse_decode_u_64(deserializer);
    var var_feesBaseMsat = sse_decode_u_32(deserializer);
    var var_feesProportionalMillionths = sse_decode_u_32(deserializer);
    var var_cltvExpiryDelta = sse_decode_u_64(deserializer);
    var var_htlcMinimumMsat = sse_decode_opt_box_autoadd_u_64(deserializer);
    var var_htlcMaximumMsat = sse_decode_opt_box_autoadd_u_64(deserializer);
    return RouteHintHop(
        srcNodeId: var_srcNodeId,
        shortChannelId: var_shortChannelId,
        feesBaseMsat: var_feesBaseMsat,
        feesProportionalMillionths: var_feesProportionalMillionths,
        cltvExpiryDelta: var_cltvExpiryDelta,
        htlcMinimumMsat: var_htlcMinimumMsat,
        htlcMaximumMsat: var_htlcMaximumMsat);
  }

  @protected
  SendOnchainRequest sse_decode_send_onchain_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_amountSat = sse_decode_u_64(deserializer);
    var var_onchainRecipientAddress = sse_decode_String(deserializer);
    var var_pairHash = sse_decode_String(deserializer);
    var var_satPerVbyte = sse_decode_u_32(deserializer);
    return SendOnchainRequest(
        amountSat: var_amountSat,
        onchainRecipientAddress: var_onchainRecipientAddress,
        pairHash: var_pairHash,
        satPerVbyte: var_satPerVbyte);
  }

  @protected
  SendOnchainResponse sse_decode_send_onchain_response(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_reverseSwapInfo = sse_decode_reverse_swap_info(deserializer);
    return SendOnchainResponse(reverseSwapInfo: var_reverseSwapInfo);
  }

  @protected
  SendPaymentRequest sse_decode_send_payment_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_bolt11 = sse_decode_String(deserializer);
    var var_amountMsat = sse_decode_opt_box_autoadd_u_64(deserializer);
    var var_label = sse_decode_opt_String(deserializer);
    return SendPaymentRequest(bolt11: var_bolt11, amountMsat: var_amountMsat, label: var_label);
  }

  @protected
  SendPaymentResponse sse_decode_send_payment_response(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_payment = sse_decode_payment(deserializer);
    return SendPaymentResponse(payment: var_payment);
  }

  @protected
  SendSpontaneousPaymentRequest sse_decode_send_spontaneous_payment_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_nodeId = sse_decode_String(deserializer);
    var var_amountMsat = sse_decode_u_64(deserializer);
    var var_extraTlvs = sse_decode_opt_list_tlv_entry(deserializer);
    var var_label = sse_decode_opt_String(deserializer);
    return SendSpontaneousPaymentRequest(
        nodeId: var_nodeId, amountMsat: var_amountMsat, extraTlvs: var_extraTlvs, label: var_label);
  }

  @protected
  ServiceHealthCheckResponse sse_decode_service_health_check_response(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_status = sse_decode_health_check_status(deserializer);
    return ServiceHealthCheckResponse(status: var_status);
  }

  @protected
  SignMessageRequest sse_decode_sign_message_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_message = sse_decode_String(deserializer);
    return SignMessageRequest(message: var_message);
  }

  @protected
  SignMessageResponse sse_decode_sign_message_response(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_signature = sse_decode_String(deserializer);
    return SignMessageResponse(signature: var_signature);
  }

  @protected
  StaticBackupRequest sse_decode_static_backup_request(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_workingDir = sse_decode_String(deserializer);
    return StaticBackupRequest(workingDir: var_workingDir);
  }

  @protected
  StaticBackupResponse sse_decode_static_backup_response(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_backup = sse_decode_opt_list_String(deserializer);
    return StaticBackupResponse(backup: var_backup);
  }

  @protected
  SuccessActionProcessed sse_decode_success_action_processed(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_result = sse_decode_box_autoadd_aes_success_action_data_result(deserializer);
        return SuccessActionProcessed_Aes(result: var_result);
      case 1:
        var var_data = sse_decode_box_autoadd_message_success_action_data(deserializer);
        return SuccessActionProcessed_Message(data: var_data);
      case 2:
        var var_data = sse_decode_box_autoadd_url_success_action_data(deserializer);
        return SuccessActionProcessed_Url(data: var_data);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  SwapAmountType sse_decode_swap_amount_type(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return SwapAmountType.values[inner];
  }

  @protected
  SwapInfo sse_decode_swap_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_bitcoinAddress = sse_decode_String(deserializer);
    var var_createdAt = sse_decode_i_64(deserializer);
    var var_lockHeight = sse_decode_i_64(deserializer);
    var var_paymentHash = sse_decode_list_prim_u_8_strict(deserializer);
    var var_preimage = sse_decode_list_prim_u_8_strict(deserializer);
    var var_privateKey = sse_decode_list_prim_u_8_strict(deserializer);
    var var_publicKey = sse_decode_list_prim_u_8_strict(deserializer);
    var var_swapperPublicKey = sse_decode_list_prim_u_8_strict(deserializer);
    var var_script = sse_decode_list_prim_u_8_strict(deserializer);
    var var_bolt11 = sse_decode_opt_String(deserializer);
    var var_paidMsat = sse_decode_u_64(deserializer);
    var var_totalIncomingTxs = sse_decode_u_64(deserializer);
    var var_confirmedSats = sse_decode_u_64(deserializer);
    var var_unconfirmedSats = sse_decode_u_64(deserializer);
    var var_status = sse_decode_swap_status(deserializer);
    var var_refundTxIds = sse_decode_list_String(deserializer);
    var var_unconfirmedTxIds = sse_decode_list_String(deserializer);
    var var_confirmedTxIds = sse_decode_list_String(deserializer);
    var var_minAllowedDeposit = sse_decode_i_64(deserializer);
    var var_maxAllowedDeposit = sse_decode_i_64(deserializer);
    var var_maxSwapperPayable = sse_decode_i_64(deserializer);
    var var_lastRedeemError = sse_decode_opt_String(deserializer);
    var var_channelOpeningFees = sse_decode_opt_box_autoadd_opening_fee_params(deserializer);
    var var_confirmedAt = sse_decode_opt_box_autoadd_u_32(deserializer);
    return SwapInfo(
        bitcoinAddress: var_bitcoinAddress,
        createdAt: var_createdAt,
        lockHeight: var_lockHeight,
        paymentHash: var_paymentHash,
        preimage: var_preimage,
        privateKey: var_privateKey,
        publicKey: var_publicKey,
        swapperPublicKey: var_swapperPublicKey,
        script: var_script,
        bolt11: var_bolt11,
        paidMsat: var_paidMsat,
        totalIncomingTxs: var_totalIncomingTxs,
        confirmedSats: var_confirmedSats,
        unconfirmedSats: var_unconfirmedSats,
        status: var_status,
        refundTxIds: var_refundTxIds,
        unconfirmedTxIds: var_unconfirmedTxIds,
        confirmedTxIds: var_confirmedTxIds,
        minAllowedDeposit: var_minAllowedDeposit,
        maxAllowedDeposit: var_maxAllowedDeposit,
        maxSwapperPayable: var_maxSwapperPayable,
        lastRedeemError: var_lastRedeemError,
        channelOpeningFees: var_channelOpeningFees,
        confirmedAt: var_confirmedAt);
  }

  @protected
  SwapStatus sse_decode_swap_status(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return SwapStatus.values[inner];
  }

  @protected
  Symbol sse_decode_symbol(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_grapheme = sse_decode_opt_String(deserializer);
    var var_template = sse_decode_opt_String(deserializer);
    var var_rtl = sse_decode_opt_box_autoadd_bool(deserializer);
    var var_position = sse_decode_opt_box_autoadd_u_32(deserializer);
    return Symbol(grapheme: var_grapheme, template: var_template, rtl: var_rtl, position: var_position);
  }

  @protected
  TlvEntry sse_decode_tlv_entry(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_fieldNumber = sse_decode_u_64(deserializer);
    var var_value = sse_decode_list_prim_u_8_strict(deserializer);
    return TlvEntry(fieldNumber: var_fieldNumber, value: var_value);
  }

  @protected
  int sse_decode_u_16(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint16();
  }

  @protected
  int sse_decode_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint32();
  }

  @protected
  BigInt sse_decode_u_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getBigUint64();
  }

  @protected
  int sse_decode_u_8(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8();
  }

  @protected
  void sse_decode_unit(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  UnspentTransactionOutput sse_decode_unspent_transaction_output(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_txid = sse_decode_list_prim_u_8_strict(deserializer);
    var var_outnum = sse_decode_u_32(deserializer);
    var var_amountMillisatoshi = sse_decode_u_64(deserializer);
    var var_address = sse_decode_String(deserializer);
    var var_reserved = sse_decode_bool(deserializer);
    return UnspentTransactionOutput(
        txid: var_txid,
        outnum: var_outnum,
        amountMillisatoshi: var_amountMillisatoshi,
        address: var_address,
        reserved: var_reserved);
  }

  @protected
  UrlSuccessActionData sse_decode_url_success_action_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_description = sse_decode_String(deserializer);
    var var_url = sse_decode_String(deserializer);
    return UrlSuccessActionData(description: var_description, url: var_url);
  }

  @protected
  bool cst_encode_bool(bool raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  int cst_encode_buy_bitcoin_provider(BuyBitcoinProvider raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return cst_encode_i_32(raw.index);
  }

  @protected
  int cst_encode_channel_state(ChannelState raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return cst_encode_i_32(raw.index);
  }

  @protected
  int cst_encode_environment_type(EnvironmentType raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return cst_encode_i_32(raw.index);
  }

  @protected
  double cst_encode_f_64(double raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  int cst_encode_health_check_status(HealthCheckStatus raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return cst_encode_i_32(raw.index);
  }

  @protected
  int cst_encode_i_32(int raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  int cst_encode_network(Network raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return cst_encode_i_32(raw.index);
  }

  @protected
  int cst_encode_payment_status(PaymentStatus raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return cst_encode_i_32(raw.index);
  }

  @protected
  int cst_encode_payment_type(PaymentType raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return cst_encode_i_32(raw.index);
  }

  @protected
  int cst_encode_payment_type_filter(PaymentTypeFilter raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return cst_encode_i_32(raw.index);
  }

  @protected
  int cst_encode_reverse_swap_status(ReverseSwapStatus raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return cst_encode_i_32(raw.index);
  }

  @protected
  int cst_encode_swap_amount_type(SwapAmountType raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return cst_encode_i_32(raw.index);
  }

  @protected
  int cst_encode_swap_status(SwapStatus raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return cst_encode_i_32(raw.index);
  }

  @protected
  int cst_encode_u_16(int raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  int cst_encode_u_32(int raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  int cst_encode_u_8(int raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  void cst_encode_unit(void raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  void sse_encode_AnyhowException(AnyhowException self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.message, serializer);
  }

  @protected
  void sse_encode_StreamSink_breez_event_Dco(RustStreamSink<BreezEvent> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(
        self.setupAndSerialize(
            codec: DcoCodec(
          decodeSuccessData: dco_decode_breez_event,
          decodeErrorData: dco_decode_AnyhowException,
        )),
        serializer);
  }

  @protected
  void sse_encode_StreamSink_log_entry_Dco(RustStreamSink<LogEntry> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(
        self.setupAndSerialize(
            codec: DcoCodec(
          decodeSuccessData: dco_decode_log_entry,
          decodeErrorData: dco_decode_AnyhowException,
        )),
        serializer);
  }

  @protected
  void sse_encode_String(String self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(utf8.encoder.convert(self), serializer);
  }

  @protected
  void sse_encode_aes_success_action_data_decrypted(
      AesSuccessActionDataDecrypted self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.description, serializer);
    sse_encode_String(self.plaintext, serializer);
  }

  @protected
  void sse_encode_aes_success_action_data_result(AesSuccessActionDataResult self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case AesSuccessActionDataResult_Decrypted(data: final data):
        sse_encode_i_32(0, serializer);
        sse_encode_box_autoadd_aes_success_action_data_decrypted(data, serializer);
      case AesSuccessActionDataResult_ErrorStatus(reason: final reason):
        sse_encode_i_32(1, serializer);
        sse_encode_String(reason, serializer);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  void sse_encode_backup_failed_data(BackupFailedData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.error, serializer);
  }

  @protected
  void sse_encode_backup_status(BackupStatus self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bool(self.backedUp, serializer);
    sse_encode_opt_box_autoadd_u_64(self.lastBackupTime, serializer);
  }

  @protected
  void sse_encode_binding_event_listener(BindingEventListener self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  void sse_encode_bitcoin_address_data(BitcoinAddressData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.address, serializer);
    sse_encode_network(self.network, serializer);
    sse_encode_opt_box_autoadd_u_64(self.amountSat, serializer);
    sse_encode_opt_String(self.label, serializer);
    sse_encode_opt_String(self.message, serializer);
  }

  @protected
  void sse_encode_bool(bool self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self ? 1 : 0);
  }

  @protected
  void sse_encode_box_autoadd_aes_success_action_data_decrypted(
      AesSuccessActionDataDecrypted self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_aes_success_action_data_decrypted(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_aes_success_action_data_result(
      AesSuccessActionDataResult self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_aes_success_action_data_result(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_backup_failed_data(BackupFailedData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_backup_failed_data(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_binding_event_listener(BindingEventListener self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_binding_event_listener(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_bitcoin_address_data(BitcoinAddressData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bitcoin_address_data(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_bool(bool self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bool(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_breez_event(BreezEvent self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_breez_event(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_buy_bitcoin_request(BuyBitcoinRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_buy_bitcoin_request(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_check_message_request(CheckMessageRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_check_message_request(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_closed_channel_payment_details(
      ClosedChannelPaymentDetails self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_closed_channel_payment_details(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_configure_node_request(ConfigureNodeRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_configure_node_request(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_connect_request(ConnectRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_connect_request(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_greenlight_credentials(GreenlightCredentials self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_greenlight_credentials(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_greenlight_node_config(GreenlightNodeConfig self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_greenlight_node_config(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_i_64(PlatformInt64 self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_64(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_invoice_paid_details(InvoicePaidDetails self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_invoice_paid_details(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_list_payments_request(ListPaymentsRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_payments_request(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ln_invoice(LNInvoice self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ln_invoice(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ln_payment_details(LnPaymentDetails self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ln_payment_details(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ln_url_auth_request_data(LnUrlAuthRequestData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ln_url_auth_request_data(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ln_url_error_data(LnUrlErrorData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ln_url_error_data(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ln_url_pay_error_data(LnUrlPayErrorData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ln_url_pay_error_data(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ln_url_pay_request(LnUrlPayRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ln_url_pay_request(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ln_url_pay_request_data(LnUrlPayRequestData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ln_url_pay_request_data(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ln_url_pay_success_data(LnUrlPaySuccessData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ln_url_pay_success_data(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ln_url_withdraw_request(LnUrlWithdrawRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ln_url_withdraw_request(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ln_url_withdraw_request_data(
      LnUrlWithdrawRequestData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ln_url_withdraw_request_data(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ln_url_withdraw_success_data(
      LnUrlWithdrawSuccessData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ln_url_withdraw_success_data(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_lsp_information(LspInformation self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_lsp_information(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_message_success_action_data(
      MessageSuccessActionData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_message_success_action_data(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_node_config(NodeConfig self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_node_config(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_node_credentials(NodeCredentials self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_node_credentials(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_open_channel_fee_request(OpenChannelFeeRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_open_channel_fee_request(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_opening_fee_params(OpeningFeeParams self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_opening_fee_params(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_pay_onchain_request(PayOnchainRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_pay_onchain_request(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_payment(Payment self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_payment(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_payment_failed_data(PaymentFailedData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_payment_failed_data(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_prepare_onchain_payment_request(
      PrepareOnchainPaymentRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_prepare_onchain_payment_request(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_prepare_redeem_onchain_funds_request(
      PrepareRedeemOnchainFundsRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_prepare_redeem_onchain_funds_request(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_prepare_refund_request(PrepareRefundRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_prepare_refund_request(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_receive_onchain_request(ReceiveOnchainRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_receive_onchain_request(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_receive_payment_request(ReceivePaymentRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_receive_payment_request(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_redeem_onchain_funds_request(
      RedeemOnchainFundsRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_redeem_onchain_funds_request(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_refund_request(RefundRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_refund_request(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_report_issue_request(ReportIssueRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_report_issue_request(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_report_payment_failure_details(
      ReportPaymentFailureDetails self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_report_payment_failure_details(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_reverse_swap_fees_request(
      ReverseSwapFeesRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_reverse_swap_fees_request(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_reverse_swap_info(ReverseSwapInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_reverse_swap_info(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_send_onchain_request(SendOnchainRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_send_onchain_request(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_send_payment_request(SendPaymentRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_send_payment_request(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_send_spontaneous_payment_request(
      SendSpontaneousPaymentRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_send_spontaneous_payment_request(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_sign_message_request(SignMessageRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_sign_message_request(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_static_backup_request(StaticBackupRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_static_backup_request(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_success_action_processed(
      SuccessActionProcessed self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_success_action_processed(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_swap_info(SwapInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_swap_info(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_symbol(Symbol self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_symbol(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_u_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_32(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_u_64(BigInt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_64(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_url_success_action_data(UrlSuccessActionData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_url_success_action_data(self, serializer);
  }

  @protected
  void sse_encode_breez_event(BreezEvent self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case BreezEvent_NewBlock(block: final block):
        sse_encode_i_32(0, serializer);
        sse_encode_u_32(block, serializer);
      case BreezEvent_InvoicePaid(details: final details):
        sse_encode_i_32(1, serializer);
        sse_encode_box_autoadd_invoice_paid_details(details, serializer);
      case BreezEvent_Synced():
        sse_encode_i_32(2, serializer);
      case BreezEvent_PaymentSucceed(details: final details):
        sse_encode_i_32(3, serializer);
        sse_encode_box_autoadd_payment(details, serializer);
      case BreezEvent_PaymentFailed(details: final details):
        sse_encode_i_32(4, serializer);
        sse_encode_box_autoadd_payment_failed_data(details, serializer);
      case BreezEvent_BackupStarted():
        sse_encode_i_32(5, serializer);
      case BreezEvent_BackupSucceeded():
        sse_encode_i_32(6, serializer);
      case BreezEvent_BackupFailed(details: final details):
        sse_encode_i_32(7, serializer);
        sse_encode_box_autoadd_backup_failed_data(details, serializer);
      case BreezEvent_SwapUpdated(details: final details):
        sse_encode_i_32(8, serializer);
        sse_encode_box_autoadd_swap_info(details, serializer);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  void sse_encode_buy_bitcoin_provider(BuyBitcoinProvider self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_buy_bitcoin_request(BuyBitcoinRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_buy_bitcoin_provider(self.provider, serializer);
    sse_encode_opt_box_autoadd_opening_fee_params(self.openingFeeParams, serializer);
  }

  @protected
  void sse_encode_buy_bitcoin_response(BuyBitcoinResponse self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.url, serializer);
    sse_encode_opt_box_autoadd_opening_fee_params(self.openingFeeParams, serializer);
  }

  @protected
  void sse_encode_channel_state(ChannelState self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_check_message_request(CheckMessageRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.message, serializer);
    sse_encode_String(self.pubkey, serializer);
    sse_encode_String(self.signature, serializer);
  }

  @protected
  void sse_encode_check_message_response(CheckMessageResponse self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bool(self.isValid, serializer);
  }

  @protected
  void sse_encode_closed_channel_payment_details(ClosedChannelPaymentDetails self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_channel_state(self.state, serializer);
    sse_encode_String(self.fundingTxid, serializer);
    sse_encode_opt_String(self.shortChannelId, serializer);
    sse_encode_opt_String(self.closingTxid, serializer);
  }

  @protected
  void sse_encode_config(Config self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.breezserver, serializer);
    sse_encode_String(self.chainnotifierUrl, serializer);
    sse_encode_opt_String(self.mempoolspaceUrl, serializer);
    sse_encode_String(self.workingDir, serializer);
    sse_encode_network(self.network, serializer);
    sse_encode_u_32(self.paymentTimeoutSec, serializer);
    sse_encode_opt_String(self.defaultLspId, serializer);
    sse_encode_opt_String(self.apiKey, serializer);
    sse_encode_f_64(self.maxfeePercent, serializer);
    sse_encode_u_64(self.exemptfeeMsat, serializer);
    sse_encode_node_config(self.nodeConfig, serializer);
  }

  @protected
  void sse_encode_configure_node_request(ConfigureNodeRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_opt_String(self.closeToAddress, serializer);
  }

  @protected
  void sse_encode_connect_request(ConnectRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_config(self.config, serializer);
    sse_encode_list_prim_u_8_strict(self.seed, serializer);
    sse_encode_opt_box_autoadd_bool(self.restoreOnly, serializer);
  }

  @protected
  void sse_encode_currency_info(CurrencyInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.name, serializer);
    sse_encode_u_32(self.fractionSize, serializer);
    sse_encode_opt_box_autoadd_u_32(self.spacing, serializer);
    sse_encode_opt_box_autoadd_symbol(self.symbol, serializer);
    sse_encode_opt_box_autoadd_symbol(self.uniqSymbol, serializer);
    sse_encode_opt_list_localized_name(self.localizedName, serializer);
    sse_encode_opt_list_locale_overrides(self.localeOverrides, serializer);
  }

  @protected
  void sse_encode_environment_type(EnvironmentType self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_f_64(double self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putFloat64(self);
  }

  @protected
  void sse_encode_fiat_currency(FiatCurrency self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.id, serializer);
    sse_encode_currency_info(self.info, serializer);
  }

  @protected
  void sse_encode_greenlight_credentials(GreenlightCredentials self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(self.deviceKey, serializer);
    sse_encode_list_prim_u_8_strict(self.deviceCert, serializer);
  }

  @protected
  void sse_encode_greenlight_node_config(GreenlightNodeConfig self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_opt_box_autoadd_greenlight_credentials(self.partnerCredentials, serializer);
    sse_encode_opt_String(self.inviteCode, serializer);
  }

  @protected
  void sse_encode_health_check_status(HealthCheckStatus self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_i_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putInt32(self);
  }

  @protected
  void sse_encode_i_64(PlatformInt64 self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putPlatformInt64(self);
  }

  @protected
  void sse_encode_input_type(InputType self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case InputType_BitcoinAddress(address: final address):
        sse_encode_i_32(0, serializer);
        sse_encode_box_autoadd_bitcoin_address_data(address, serializer);
      case InputType_Bolt11(invoice: final invoice):
        sse_encode_i_32(1, serializer);
        sse_encode_box_autoadd_ln_invoice(invoice, serializer);
      case InputType_NodeId(nodeId: final nodeId):
        sse_encode_i_32(2, serializer);
        sse_encode_String(nodeId, serializer);
      case InputType_Url(url: final url):
        sse_encode_i_32(3, serializer);
        sse_encode_String(url, serializer);
      case InputType_LnUrlPay(data: final data):
        sse_encode_i_32(4, serializer);
        sse_encode_box_autoadd_ln_url_pay_request_data(data, serializer);
      case InputType_LnUrlWithdraw(data: final data):
        sse_encode_i_32(5, serializer);
        sse_encode_box_autoadd_ln_url_withdraw_request_data(data, serializer);
      case InputType_LnUrlAuth(data: final data):
        sse_encode_i_32(6, serializer);
        sse_encode_box_autoadd_ln_url_auth_request_data(data, serializer);
      case InputType_LnUrlError(data: final data):
        sse_encode_i_32(7, serializer);
        sse_encode_box_autoadd_ln_url_error_data(data, serializer);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  void sse_encode_invoice_paid_details(InvoicePaidDetails self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.paymentHash, serializer);
    sse_encode_String(self.bolt11, serializer);
    sse_encode_opt_box_autoadd_payment(self.payment, serializer);
  }

  @protected
  void sse_encode_list_String(List<String> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_String(item, serializer);
    }
  }

  @protected
  void sse_encode_list_fiat_currency(List<FiatCurrency> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_fiat_currency(item, serializer);
    }
  }

  @protected
  void sse_encode_list_locale_overrides(List<LocaleOverrides> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_locale_overrides(item, serializer);
    }
  }

  @protected
  void sse_encode_list_localized_name(List<LocalizedName> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_localized_name(item, serializer);
    }
  }

  @protected
  void sse_encode_list_lsp_information(List<LspInformation> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_lsp_information(item, serializer);
    }
  }

  @protected
  void sse_encode_list_metadata_filter(List<MetadataFilter> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_metadata_filter(item, serializer);
    }
  }

  @protected
  void sse_encode_list_opening_fee_params(List<OpeningFeeParams> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_opening_fee_params(item, serializer);
    }
  }

  @protected
  void sse_encode_list_payment(List<Payment> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_payment(item, serializer);
    }
  }

  @protected
  void sse_encode_list_payment_type_filter(List<PaymentTypeFilter> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_payment_type_filter(item, serializer);
    }
  }

  @protected
  void sse_encode_list_payments_request(ListPaymentsRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_opt_list_payment_type_filter(self.filters, serializer);
    sse_encode_opt_list_metadata_filter(self.metadataFilters, serializer);
    sse_encode_opt_box_autoadd_i_64(self.fromTimestamp, serializer);
    sse_encode_opt_box_autoadd_i_64(self.toTimestamp, serializer);
    sse_encode_opt_box_autoadd_bool(self.includeFailures, serializer);
    sse_encode_opt_box_autoadd_u_32(self.offset, serializer);
    sse_encode_opt_box_autoadd_u_32(self.limit, serializer);
  }

  @protected
  void sse_encode_list_prim_u_8_strict(Uint8List self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putUint8List(self);
  }

  @protected
  void sse_encode_list_rate(List<Rate> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_rate(item, serializer);
    }
  }

  @protected
  void sse_encode_list_reverse_swap_info(List<ReverseSwapInfo> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_reverse_swap_info(item, serializer);
    }
  }

  @protected
  void sse_encode_list_route_hint(List<RouteHint> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_route_hint(item, serializer);
    }
  }

  @protected
  void sse_encode_list_route_hint_hop(List<RouteHintHop> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_route_hint_hop(item, serializer);
    }
  }

  @protected
  void sse_encode_list_swap_info(List<SwapInfo> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_swap_info(item, serializer);
    }
  }

  @protected
  void sse_encode_list_tlv_entry(List<TlvEntry> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_tlv_entry(item, serializer);
    }
  }

  @protected
  void sse_encode_list_unspent_transaction_output(
      List<UnspentTransactionOutput> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_unspent_transaction_output(item, serializer);
    }
  }

  @protected
  void sse_encode_ln_invoice(LNInvoice self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.bolt11, serializer);
    sse_encode_network(self.network, serializer);
    sse_encode_String(self.payeePubkey, serializer);
    sse_encode_String(self.paymentHash, serializer);
    sse_encode_opt_String(self.description, serializer);
    sse_encode_opt_String(self.descriptionHash, serializer);
    sse_encode_opt_box_autoadd_u_64(self.amountMsat, serializer);
    sse_encode_u_64(self.timestamp, serializer);
    sse_encode_u_64(self.expiry, serializer);
    sse_encode_list_route_hint(self.routingHints, serializer);
    sse_encode_list_prim_u_8_strict(self.paymentSecret, serializer);
    sse_encode_u_64(self.minFinalCltvExpiryDelta, serializer);
  }

  @protected
  void sse_encode_ln_payment_details(LnPaymentDetails self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.paymentHash, serializer);
    sse_encode_String(self.label, serializer);
    sse_encode_String(self.destinationPubkey, serializer);
    sse_encode_String(self.paymentPreimage, serializer);
    sse_encode_bool(self.keysend, serializer);
    sse_encode_String(self.bolt11, serializer);
    sse_encode_opt_String(self.openChannelBolt11, serializer);
    sse_encode_opt_box_autoadd_success_action_processed(self.lnurlSuccessAction, serializer);
    sse_encode_opt_String(self.lnurlPayDomain, serializer);
    sse_encode_opt_String(self.lnurlPayComment, serializer);
    sse_encode_opt_String(self.lnAddress, serializer);
    sse_encode_opt_String(self.lnurlMetadata, serializer);
    sse_encode_opt_String(self.lnurlWithdrawEndpoint, serializer);
    sse_encode_opt_box_autoadd_swap_info(self.swapInfo, serializer);
    sse_encode_opt_box_autoadd_reverse_swap_info(self.reverseSwapInfo, serializer);
    sse_encode_opt_box_autoadd_u_32(self.pendingExpirationBlock, serializer);
  }

  @protected
  void sse_encode_ln_url_auth_request_data(LnUrlAuthRequestData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.k1, serializer);
    sse_encode_opt_String(self.action, serializer);
    sse_encode_String(self.domain, serializer);
    sse_encode_String(self.url, serializer);
  }

  @protected
  void sse_encode_ln_url_callback_status(LnUrlCallbackStatus self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case LnUrlCallbackStatus_Ok():
        sse_encode_i_32(0, serializer);
      case LnUrlCallbackStatus_ErrorStatus(data: final data):
        sse_encode_i_32(1, serializer);
        sse_encode_box_autoadd_ln_url_error_data(data, serializer);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  void sse_encode_ln_url_error_data(LnUrlErrorData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.reason, serializer);
  }

  @protected
  void sse_encode_ln_url_pay_error_data(LnUrlPayErrorData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.paymentHash, serializer);
    sse_encode_String(self.reason, serializer);
  }

  @protected
  void sse_encode_ln_url_pay_request(LnUrlPayRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ln_url_pay_request_data(self.data, serializer);
    sse_encode_u_64(self.amountMsat, serializer);
    sse_encode_opt_String(self.comment, serializer);
    sse_encode_opt_String(self.paymentLabel, serializer);
  }

  @protected
  void sse_encode_ln_url_pay_request_data(LnUrlPayRequestData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.callback, serializer);
    sse_encode_u_64(self.minSendable, serializer);
    sse_encode_u_64(self.maxSendable, serializer);
    sse_encode_String(self.metadataStr, serializer);
    sse_encode_u_16(self.commentAllowed, serializer);
    sse_encode_String(self.domain, serializer);
    sse_encode_bool(self.allowsNostr, serializer);
    sse_encode_opt_String(self.nostrPubkey, serializer);
    sse_encode_opt_String(self.lnAddress, serializer);
  }

  @protected
  void sse_encode_ln_url_pay_result(LnUrlPayResult self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case LnUrlPayResult_EndpointSuccess(data: final data):
        sse_encode_i_32(0, serializer);
        sse_encode_box_autoadd_ln_url_pay_success_data(data, serializer);
      case LnUrlPayResult_EndpointError(data: final data):
        sse_encode_i_32(1, serializer);
        sse_encode_box_autoadd_ln_url_error_data(data, serializer);
      case LnUrlPayResult_PayError(data: final data):
        sse_encode_i_32(2, serializer);
        sse_encode_box_autoadd_ln_url_pay_error_data(data, serializer);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  void sse_encode_ln_url_pay_success_data(LnUrlPaySuccessData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_payment(self.payment, serializer);
    sse_encode_opt_box_autoadd_success_action_processed(self.successAction, serializer);
  }

  @protected
  void sse_encode_ln_url_withdraw_request(LnUrlWithdrawRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ln_url_withdraw_request_data(self.data, serializer);
    sse_encode_u_64(self.amountMsat, serializer);
    sse_encode_opt_String(self.description, serializer);
  }

  @protected
  void sse_encode_ln_url_withdraw_request_data(LnUrlWithdrawRequestData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.callback, serializer);
    sse_encode_String(self.k1, serializer);
    sse_encode_String(self.defaultDescription, serializer);
    sse_encode_u_64(self.minWithdrawable, serializer);
    sse_encode_u_64(self.maxWithdrawable, serializer);
  }

  @protected
  void sse_encode_ln_url_withdraw_result(LnUrlWithdrawResult self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case LnUrlWithdrawResult_Ok(data: final data):
        sse_encode_i_32(0, serializer);
        sse_encode_box_autoadd_ln_url_withdraw_success_data(data, serializer);
      case LnUrlWithdrawResult_ErrorStatus(data: final data):
        sse_encode_i_32(1, serializer);
        sse_encode_box_autoadd_ln_url_error_data(data, serializer);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  void sse_encode_ln_url_withdraw_success_data(LnUrlWithdrawSuccessData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ln_invoice(self.invoice, serializer);
  }

  @protected
  void sse_encode_locale_overrides(LocaleOverrides self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.locale, serializer);
    sse_encode_opt_box_autoadd_u_32(self.spacing, serializer);
    sse_encode_symbol(self.symbol, serializer);
  }

  @protected
  void sse_encode_localized_name(LocalizedName self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.locale, serializer);
    sse_encode_String(self.name, serializer);
  }

  @protected
  void sse_encode_log_entry(LogEntry self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.line, serializer);
    sse_encode_String(self.level, serializer);
  }

  @protected
  void sse_encode_lsp_information(LspInformation self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.id, serializer);
    sse_encode_String(self.name, serializer);
    sse_encode_String(self.widgetUrl, serializer);
    sse_encode_String(self.pubkey, serializer);
    sse_encode_String(self.host, serializer);
    sse_encode_i_64(self.baseFeeMsat, serializer);
    sse_encode_f_64(self.feeRate, serializer);
    sse_encode_u_32(self.timeLockDelta, serializer);
    sse_encode_i_64(self.minHtlcMsat, serializer);
    sse_encode_list_prim_u_8_strict(self.lspPubkey, serializer);
    sse_encode_opening_fee_params_menu(self.openingFeeParamsList, serializer);
  }

  @protected
  void sse_encode_max_reverse_swap_amount_response(
      MaxReverseSwapAmountResponse self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_64(self.totalSat, serializer);
  }

  @protected
  void sse_encode_message_success_action_data(MessageSuccessActionData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.message, serializer);
  }

  @protected
  void sse_encode_metadata_filter(MetadataFilter self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.jsonPath, serializer);
    sse_encode_String(self.jsonValue, serializer);
  }

  @protected
  void sse_encode_network(Network self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_node_config(NodeConfig self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case NodeConfig_Greenlight(config: final config):
        sse_encode_i_32(0, serializer);
        sse_encode_box_autoadd_greenlight_node_config(config, serializer);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  void sse_encode_node_credentials(NodeCredentials self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case NodeCredentials_Greenlight(credentials: final credentials):
        sse_encode_i_32(0, serializer);
        sse_encode_box_autoadd_greenlight_credentials(credentials, serializer);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  void sse_encode_node_state(NodeState self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.id, serializer);
    sse_encode_u_32(self.blockHeight, serializer);
    sse_encode_u_64(self.channelsBalanceMsat, serializer);
    sse_encode_u_64(self.onchainBalanceMsat, serializer);
    sse_encode_u_64(self.pendingOnchainBalanceMsat, serializer);
    sse_encode_list_unspent_transaction_output(self.utxos, serializer);
    sse_encode_u_64(self.maxPayableMsat, serializer);
    sse_encode_u_64(self.maxReceivableMsat, serializer);
    sse_encode_u_64(self.maxSinglePaymentAmountMsat, serializer);
    sse_encode_u_64(self.maxChanReserveMsats, serializer);
    sse_encode_list_String(self.connectedPeers, serializer);
    sse_encode_u_64(self.inboundLiquidityMsats, serializer);
  }

  @protected
  void sse_encode_onchain_payment_limits_response(
      OnchainPaymentLimitsResponse self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_64(self.minSat, serializer);
    sse_encode_u_64(self.maxSat, serializer);
  }

  @protected
  void sse_encode_open_channel_fee_request(OpenChannelFeeRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_opt_box_autoadd_u_64(self.amountMsat, serializer);
    sse_encode_opt_box_autoadd_u_32(self.expiry, serializer);
  }

  @protected
  void sse_encode_open_channel_fee_response(OpenChannelFeeResponse self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_opt_box_autoadd_u_64(self.feeMsat, serializer);
    sse_encode_opening_fee_params(self.feeParams, serializer);
  }

  @protected
  void sse_encode_opening_fee_params(OpeningFeeParams self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_64(self.minMsat, serializer);
    sse_encode_u_32(self.proportional, serializer);
    sse_encode_String(self.validUntil, serializer);
    sse_encode_u_32(self.maxIdleTime, serializer);
    sse_encode_u_32(self.maxClientToSelfDelay, serializer);
    sse_encode_String(self.promise, serializer);
  }

  @protected
  void sse_encode_opening_fee_params_menu(OpeningFeeParamsMenu self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_opening_fee_params(self.values, serializer);
  }

  @protected
  void sse_encode_opt_String(String? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_String(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_bool(bool? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_bool(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_greenlight_credentials(
      GreenlightCredentials? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_greenlight_credentials(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_i_64(PlatformInt64? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_i_64(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_ln_invoice(LNInvoice? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_ln_invoice(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_lsp_information(LspInformation? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_lsp_information(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_node_credentials(NodeCredentials? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_node_credentials(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_opening_fee_params(OpeningFeeParams? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_opening_fee_params(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_payment(Payment? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_payment(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_reverse_swap_info(ReverseSwapInfo? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_reverse_swap_info(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_success_action_processed(
      SuccessActionProcessed? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_success_action_processed(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_swap_info(SwapInfo? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_swap_info(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_symbol(Symbol? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_symbol(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_u_32(int? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_u_32(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_u_64(BigInt? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_u_64(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_list_String(List<String>? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_list_String(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_list_locale_overrides(List<LocaleOverrides>? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_list_locale_overrides(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_list_localized_name(List<LocalizedName>? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_list_localized_name(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_list_metadata_filter(List<MetadataFilter>? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_list_metadata_filter(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_list_payment_type_filter(List<PaymentTypeFilter>? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_list_payment_type_filter(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_list_prim_u_8_strict(Uint8List? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_list_prim_u_8_strict(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_list_tlv_entry(List<TlvEntry>? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_list_tlv_entry(self, serializer);
    }
  }

  @protected
  void sse_encode_pay_onchain_request(PayOnchainRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.recipientAddress, serializer);
    sse_encode_prepare_onchain_payment_response(self.prepareRes, serializer);
  }

  @protected
  void sse_encode_pay_onchain_response(PayOnchainResponse self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_reverse_swap_info(self.reverseSwapInfo, serializer);
  }

  @protected
  void sse_encode_payment(Payment self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.id, serializer);
    sse_encode_payment_type(self.paymentType, serializer);
    sse_encode_i_64(self.paymentTime, serializer);
    sse_encode_u_64(self.amountMsat, serializer);
    sse_encode_u_64(self.feeMsat, serializer);
    sse_encode_payment_status(self.status, serializer);
    sse_encode_opt_String(self.error, serializer);
    sse_encode_opt_String(self.description, serializer);
    sse_encode_payment_details(self.details, serializer);
    sse_encode_opt_String(self.metadata, serializer);
  }

  @protected
  void sse_encode_payment_details(PaymentDetails self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case PaymentDetails_Ln(data: final data):
        sse_encode_i_32(0, serializer);
        sse_encode_box_autoadd_ln_payment_details(data, serializer);
      case PaymentDetails_ClosedChannel(data: final data):
        sse_encode_i_32(1, serializer);
        sse_encode_box_autoadd_closed_channel_payment_details(data, serializer);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  void sse_encode_payment_failed_data(PaymentFailedData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.error, serializer);
    sse_encode_String(self.nodeId, serializer);
    sse_encode_opt_box_autoadd_ln_invoice(self.invoice, serializer);
    sse_encode_opt_String(self.label, serializer);
  }

  @protected
  void sse_encode_payment_status(PaymentStatus self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_payment_type(PaymentType self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_payment_type_filter(PaymentTypeFilter self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_prepare_onchain_payment_request(
      PrepareOnchainPaymentRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_64(self.amountSat, serializer);
    sse_encode_swap_amount_type(self.amountType, serializer);
    sse_encode_u_32(self.claimTxFeerate, serializer);
  }

  @protected
  void sse_encode_prepare_onchain_payment_response(
      PrepareOnchainPaymentResponse self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.feesHash, serializer);
    sse_encode_f_64(self.feesPercentage, serializer);
    sse_encode_u_64(self.feesLockup, serializer);
    sse_encode_u_64(self.feesClaim, serializer);
    sse_encode_u_64(self.senderAmountSat, serializer);
    sse_encode_u_64(self.recipientAmountSat, serializer);
    sse_encode_u_64(self.totalFees, serializer);
  }

  @protected
  void sse_encode_prepare_redeem_onchain_funds_request(
      PrepareRedeemOnchainFundsRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.toAddress, serializer);
    sse_encode_u_32(self.satPerVbyte, serializer);
  }

  @protected
  void sse_encode_prepare_redeem_onchain_funds_response(
      PrepareRedeemOnchainFundsResponse self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_64(self.txWeight, serializer);
    sse_encode_u_64(self.txFeeSat, serializer);
  }

  @protected
  void sse_encode_prepare_refund_request(PrepareRefundRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.swapAddress, serializer);
    sse_encode_String(self.toAddress, serializer);
    sse_encode_u_32(self.satPerVbyte, serializer);
  }

  @protected
  void sse_encode_prepare_refund_response(PrepareRefundResponse self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_32(self.refundTxWeight, serializer);
    sse_encode_u_64(self.refundTxFeeSat, serializer);
  }

  @protected
  void sse_encode_rate(Rate self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.coin, serializer);
    sse_encode_f_64(self.value, serializer);
  }

  @protected
  void sse_encode_receive_onchain_request(ReceiveOnchainRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_opt_box_autoadd_opening_fee_params(self.openingFeeParams, serializer);
  }

  @protected
  void sse_encode_receive_payment_request(ReceivePaymentRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_64(self.amountMsat, serializer);
    sse_encode_String(self.description, serializer);
    sse_encode_opt_list_prim_u_8_strict(self.preimage, serializer);
    sse_encode_opt_box_autoadd_opening_fee_params(self.openingFeeParams, serializer);
    sse_encode_opt_box_autoadd_bool(self.useDescriptionHash, serializer);
    sse_encode_opt_box_autoadd_u_32(self.expiry, serializer);
    sse_encode_opt_box_autoadd_u_32(self.cltv, serializer);
  }

  @protected
  void sse_encode_receive_payment_response(ReceivePaymentResponse self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ln_invoice(self.lnInvoice, serializer);
    sse_encode_opt_box_autoadd_opening_fee_params(self.openingFeeParams, serializer);
    sse_encode_opt_box_autoadd_u_64(self.openingFeeMsat, serializer);
  }

  @protected
  void sse_encode_recommended_fees(RecommendedFees self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_64(self.fastestFee, serializer);
    sse_encode_u_64(self.halfHourFee, serializer);
    sse_encode_u_64(self.hourFee, serializer);
    sse_encode_u_64(self.economyFee, serializer);
    sse_encode_u_64(self.minimumFee, serializer);
  }

  @protected
  void sse_encode_redeem_onchain_funds_request(RedeemOnchainFundsRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.toAddress, serializer);
    sse_encode_u_32(self.satPerVbyte, serializer);
  }

  @protected
  void sse_encode_redeem_onchain_funds_response(RedeemOnchainFundsResponse self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(self.txid, serializer);
  }

  @protected
  void sse_encode_refund_request(RefundRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.swapAddress, serializer);
    sse_encode_String(self.toAddress, serializer);
    sse_encode_u_32(self.satPerVbyte, serializer);
  }

  @protected
  void sse_encode_refund_response(RefundResponse self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.refundTxId, serializer);
  }

  @protected
  void sse_encode_report_issue_request(ReportIssueRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case ReportIssueRequest_PaymentFailure(data: final data):
        sse_encode_i_32(0, serializer);
        sse_encode_box_autoadd_report_payment_failure_details(data, serializer);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  void sse_encode_report_payment_failure_details(ReportPaymentFailureDetails self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.paymentHash, serializer);
    sse_encode_opt_String(self.comment, serializer);
  }

  @protected
  void sse_encode_reverse_swap_fees_request(ReverseSwapFeesRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_opt_box_autoadd_u_64(self.sendAmountSat, serializer);
    sse_encode_opt_box_autoadd_u_32(self.claimTxFeerate, serializer);
  }

  @protected
  void sse_encode_reverse_swap_info(ReverseSwapInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.id, serializer);
    sse_encode_String(self.claimPubkey, serializer);
    sse_encode_opt_String(self.lockupTxid, serializer);
    sse_encode_opt_String(self.claimTxid, serializer);
    sse_encode_u_64(self.onchainAmountSat, serializer);
    sse_encode_reverse_swap_status(self.status, serializer);
  }

  @protected
  void sse_encode_reverse_swap_pair_info(ReverseSwapPairInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_64(self.min, serializer);
    sse_encode_u_64(self.max, serializer);
    sse_encode_String(self.feesHash, serializer);
    sse_encode_f_64(self.feesPercentage, serializer);
    sse_encode_u_64(self.feesLockup, serializer);
    sse_encode_u_64(self.feesClaim, serializer);
    sse_encode_opt_box_autoadd_u_64(self.totalFees, serializer);
  }

  @protected
  void sse_encode_reverse_swap_status(ReverseSwapStatus self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_route_hint(RouteHint self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_route_hint_hop(self.hops, serializer);
  }

  @protected
  void sse_encode_route_hint_hop(RouteHintHop self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.srcNodeId, serializer);
    sse_encode_u_64(self.shortChannelId, serializer);
    sse_encode_u_32(self.feesBaseMsat, serializer);
    sse_encode_u_32(self.feesProportionalMillionths, serializer);
    sse_encode_u_64(self.cltvExpiryDelta, serializer);
    sse_encode_opt_box_autoadd_u_64(self.htlcMinimumMsat, serializer);
    sse_encode_opt_box_autoadd_u_64(self.htlcMaximumMsat, serializer);
  }

  @protected
  void sse_encode_send_onchain_request(SendOnchainRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_64(self.amountSat, serializer);
    sse_encode_String(self.onchainRecipientAddress, serializer);
    sse_encode_String(self.pairHash, serializer);
    sse_encode_u_32(self.satPerVbyte, serializer);
  }

  @protected
  void sse_encode_send_onchain_response(SendOnchainResponse self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_reverse_swap_info(self.reverseSwapInfo, serializer);
  }

  @protected
  void sse_encode_send_payment_request(SendPaymentRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.bolt11, serializer);
    sse_encode_opt_box_autoadd_u_64(self.amountMsat, serializer);
    sse_encode_opt_String(self.label, serializer);
  }

  @protected
  void sse_encode_send_payment_response(SendPaymentResponse self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_payment(self.payment, serializer);
  }

  @protected
  void sse_encode_send_spontaneous_payment_request(
      SendSpontaneousPaymentRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.nodeId, serializer);
    sse_encode_u_64(self.amountMsat, serializer);
    sse_encode_opt_list_tlv_entry(self.extraTlvs, serializer);
    sse_encode_opt_String(self.label, serializer);
  }

  @protected
  void sse_encode_service_health_check_response(ServiceHealthCheckResponse self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_health_check_status(self.status, serializer);
  }

  @protected
  void sse_encode_sign_message_request(SignMessageRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.message, serializer);
  }

  @protected
  void sse_encode_sign_message_response(SignMessageResponse self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.signature, serializer);
  }

  @protected
  void sse_encode_static_backup_request(StaticBackupRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.workingDir, serializer);
  }

  @protected
  void sse_encode_static_backup_response(StaticBackupResponse self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_opt_list_String(self.backup, serializer);
  }

  @protected
  void sse_encode_success_action_processed(SuccessActionProcessed self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case SuccessActionProcessed_Aes(result: final result):
        sse_encode_i_32(0, serializer);
        sse_encode_box_autoadd_aes_success_action_data_result(result, serializer);
      case SuccessActionProcessed_Message(data: final data):
        sse_encode_i_32(1, serializer);
        sse_encode_box_autoadd_message_success_action_data(data, serializer);
      case SuccessActionProcessed_Url(data: final data):
        sse_encode_i_32(2, serializer);
        sse_encode_box_autoadd_url_success_action_data(data, serializer);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  void sse_encode_swap_amount_type(SwapAmountType self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_swap_info(SwapInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.bitcoinAddress, serializer);
    sse_encode_i_64(self.createdAt, serializer);
    sse_encode_i_64(self.lockHeight, serializer);
    sse_encode_list_prim_u_8_strict(self.paymentHash, serializer);
    sse_encode_list_prim_u_8_strict(self.preimage, serializer);
    sse_encode_list_prim_u_8_strict(self.privateKey, serializer);
    sse_encode_list_prim_u_8_strict(self.publicKey, serializer);
    sse_encode_list_prim_u_8_strict(self.swapperPublicKey, serializer);
    sse_encode_list_prim_u_8_strict(self.script, serializer);
    sse_encode_opt_String(self.bolt11, serializer);
    sse_encode_u_64(self.paidMsat, serializer);
    sse_encode_u_64(self.totalIncomingTxs, serializer);
    sse_encode_u_64(self.confirmedSats, serializer);
    sse_encode_u_64(self.unconfirmedSats, serializer);
    sse_encode_swap_status(self.status, serializer);
    sse_encode_list_String(self.refundTxIds, serializer);
    sse_encode_list_String(self.unconfirmedTxIds, serializer);
    sse_encode_list_String(self.confirmedTxIds, serializer);
    sse_encode_i_64(self.minAllowedDeposit, serializer);
    sse_encode_i_64(self.maxAllowedDeposit, serializer);
    sse_encode_i_64(self.maxSwapperPayable, serializer);
    sse_encode_opt_String(self.lastRedeemError, serializer);
    sse_encode_opt_box_autoadd_opening_fee_params(self.channelOpeningFees, serializer);
    sse_encode_opt_box_autoadd_u_32(self.confirmedAt, serializer);
  }

  @protected
  void sse_encode_swap_status(SwapStatus self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_symbol(Symbol self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_opt_String(self.grapheme, serializer);
    sse_encode_opt_String(self.template, serializer);
    sse_encode_opt_box_autoadd_bool(self.rtl, serializer);
    sse_encode_opt_box_autoadd_u_32(self.position, serializer);
  }

  @protected
  void sse_encode_tlv_entry(TlvEntry self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_64(self.fieldNumber, serializer);
    sse_encode_list_prim_u_8_strict(self.value, serializer);
  }

  @protected
  void sse_encode_u_16(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint16(self);
  }

  @protected
  void sse_encode_u_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint32(self);
  }

  @protected
  void sse_encode_u_64(BigInt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putBigUint64(self);
  }

  @protected
  void sse_encode_u_8(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self);
  }

  @protected
  void sse_encode_unit(void self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  void sse_encode_unspent_transaction_output(UnspentTransactionOutput self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(self.txid, serializer);
    sse_encode_u_32(self.outnum, serializer);
    sse_encode_u_64(self.amountMillisatoshi, serializer);
    sse_encode_String(self.address, serializer);
    sse_encode_bool(self.reserved, serializer);
  }

  @protected
  void sse_encode_url_success_action_data(UrlSuccessActionData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.description, serializer);
    sse_encode_String(self.url, serializer);
  }
}
