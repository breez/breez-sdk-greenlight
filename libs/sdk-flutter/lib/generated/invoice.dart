// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.0.0-dev.38.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'frb_generated.dart';
import 'models.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

/// Wrapper for a BOLT11 LN invoice
class LNInvoice {
  final String bolt11;
  final Network network;
  final String payeePubkey;
  final String paymentHash;
  final String? description;
  final String? descriptionHash;
  final BigInt? amountMsat;
  final BigInt timestamp;
  final BigInt expiry;
  final List<RouteHint> routingHints;
  final Uint8List paymentSecret;
  final BigInt minFinalCltvExpiryDelta;

  const LNInvoice({
    required this.bolt11,
    required this.network,
    required this.payeePubkey,
    required this.paymentHash,
    this.description,
    this.descriptionHash,
    this.amountMsat,
    required this.timestamp,
    required this.expiry,
    required this.routingHints,
    required this.paymentSecret,
    required this.minFinalCltvExpiryDelta,
  });

  @override
  int get hashCode =>
      bolt11.hashCode ^
      network.hashCode ^
      payeePubkey.hashCode ^
      paymentHash.hashCode ^
      description.hashCode ^
      descriptionHash.hashCode ^
      amountMsat.hashCode ^
      timestamp.hashCode ^
      expiry.hashCode ^
      routingHints.hashCode ^
      paymentSecret.hashCode ^
      minFinalCltvExpiryDelta.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is LNInvoice &&
          runtimeType == other.runtimeType &&
          bolt11 == other.bolt11 &&
          network == other.network &&
          payeePubkey == other.payeePubkey &&
          paymentHash == other.paymentHash &&
          description == other.description &&
          descriptionHash == other.descriptionHash &&
          amountMsat == other.amountMsat &&
          timestamp == other.timestamp &&
          expiry == other.expiry &&
          routingHints == other.routingHints &&
          paymentSecret == other.paymentSecret &&
          minFinalCltvExpiryDelta == other.minFinalCltvExpiryDelta;
}

/// A route hint for a LN payment
class RouteHint {
  final List<RouteHintHop> hops;

  const RouteHint({
    required this.hops,
  });

  @override
  int get hashCode => hops.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) || other is RouteHint && runtimeType == other.runtimeType && hops == other.hops;
}

/// Details of a specific hop in a larger route hint
class RouteHintHop {
  /// The node_id of the non-target end of the route
  final String srcNodeId;

  /// The short_channel_id of this channel
  final BigInt shortChannelId;

  /// The fees which must be paid to use this channel
  final int feesBaseMsat;
  final int feesProportionalMillionths;

  /// The difference in CLTV values between this node and the next node.
  final BigInt cltvExpiryDelta;

  /// The minimum value, in msat, which must be relayed to the next hop.
  final BigInt? htlcMinimumMsat;

  /// The maximum value in msat available for routing with a single HTLC.
  final BigInt? htlcMaximumMsat;

  const RouteHintHop({
    required this.srcNodeId,
    required this.shortChannelId,
    required this.feesBaseMsat,
    required this.feesProportionalMillionths,
    required this.cltvExpiryDelta,
    this.htlcMinimumMsat,
    this.htlcMaximumMsat,
  });

  @override
  int get hashCode =>
      srcNodeId.hashCode ^
      shortChannelId.hashCode ^
      feesBaseMsat.hashCode ^
      feesProportionalMillionths.hashCode ^
      cltvExpiryDelta.hashCode ^
      htlcMinimumMsat.hashCode ^
      htlcMaximumMsat.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is RouteHintHop &&
          runtimeType == other.runtimeType &&
          srcNodeId == other.srcNodeId &&
          shortChannelId == other.shortChannelId &&
          feesBaseMsat == other.feesBaseMsat &&
          feesProportionalMillionths == other.feesProportionalMillionths &&
          cltvExpiryDelta == other.cltvExpiryDelta &&
          htlcMinimumMsat == other.htlcMinimumMsat &&
          htlcMaximumMsat == other.htlcMaximumMsat;
}
