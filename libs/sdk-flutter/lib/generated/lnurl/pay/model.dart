// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.0.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../../frb_generated.dart';
import '../../input_parser.dart';
import '../../models.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
part 'model.freezed.dart';

/// Wrapper for the decrypted [AesSuccessActionData] payload
class AesSuccessActionDataDecrypted {
  /// Contents description, up to 144 characters
  final String description;

  /// Decrypted content
  final String plaintext;

  const AesSuccessActionDataDecrypted({
    required this.description,
    required this.plaintext,
  });

  @override
  int get hashCode => description.hashCode ^ plaintext.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AesSuccessActionDataDecrypted &&
          runtimeType == other.runtimeType &&
          description == other.description &&
          plaintext == other.plaintext;
}

@freezed
sealed class AesSuccessActionDataResult with _$AesSuccessActionDataResult {
  const AesSuccessActionDataResult._();

  const factory AesSuccessActionDataResult.decrypted({
    required AesSuccessActionDataDecrypted data,
  }) = AesSuccessActionDataResult_Decrypted;
  const factory AesSuccessActionDataResult.errorStatus({
    required String reason,
  }) = AesSuccessActionDataResult_ErrorStatus;
}

class LnUrlPayErrorData {
  final String paymentHash;
  final String reason;

  const LnUrlPayErrorData({
    required this.paymentHash,
    required this.reason,
  });

  @override
  int get hashCode => paymentHash.hashCode ^ reason.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is LnUrlPayErrorData &&
          runtimeType == other.runtimeType &&
          paymentHash == other.paymentHash &&
          reason == other.reason;
}

@freezed
sealed class LnUrlPayResult with _$LnUrlPayResult {
  const LnUrlPayResult._();

  const factory LnUrlPayResult.endpointSuccess({
    required LnUrlPaySuccessData data,
  }) = LnUrlPayResult_EndpointSuccess;
  const factory LnUrlPayResult.endpointError({
    required LnUrlErrorData data,
  }) = LnUrlPayResult_EndpointError;
  const factory LnUrlPayResult.payError({
    required LnUrlPayErrorData data,
  }) = LnUrlPayResult_PayError;
}

class LnUrlPaySuccessData {
  final Payment payment;
  final SuccessActionProcessed? successAction;

  const LnUrlPaySuccessData({
    required this.payment,
    this.successAction,
  });

  @override
  int get hashCode => payment.hashCode ^ successAction.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is LnUrlPaySuccessData &&
          runtimeType == other.runtimeType &&
          payment == other.payment &&
          successAction == other.successAction;
}

class MessageSuccessActionData {
  final String message;

  const MessageSuccessActionData({
    required this.message,
  });

  @override
  int get hashCode => message.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is MessageSuccessActionData && runtimeType == other.runtimeType && message == other.message;
}

@freezed
sealed class SuccessActionProcessed with _$SuccessActionProcessed {
  const SuccessActionProcessed._();

  /// See [SuccessAction::Aes] for received payload
  ///
  /// See [AesSuccessActionDataDecrypted] for decrypted payload
  const factory SuccessActionProcessed.aes({
    required AesSuccessActionDataResult result,
  }) = SuccessActionProcessed_Aes;

  /// See [SuccessAction::Message]
  const factory SuccessActionProcessed.message({
    required MessageSuccessActionData data,
  }) = SuccessActionProcessed_Message;

  /// See [SuccessAction::Url]
  const factory SuccessActionProcessed.url({
    required UrlSuccessActionData data,
  }) = SuccessActionProcessed_Url;
}

class UrlSuccessActionData {
  final String description;
  final String url;

  const UrlSuccessActionData({
    required this.description,
    required this.url,
  });

  @override
  int get hashCode => description.hashCode ^ url.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is UrlSuccessActionData &&
          runtimeType == other.runtimeType &&
          description == other.description &&
          url == other.url;
}
